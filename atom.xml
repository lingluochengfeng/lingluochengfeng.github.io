<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>树深时见鹿</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.letmefly.cc/"/>
  <updated>2020-12-28T23:23:32.568Z</updated>
  <id>http://blog.letmefly.cc/</id>
  
  <author>
    <name>树深时见鹿</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>mysql安装启动和配置</title>
    <link href="http://blog.letmefly.cc/2020/12/29/mysql%E5%AE%89%E8%A3%85%E5%90%AF%E5%8A%A8%E5%92%8C%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.letmefly.cc/2020/12/29/mysql安装启动和配置/</id>
    <published>2020-12-28T23:22:24.000Z</published>
    <updated>2020-12-28T23:23:32.568Z</updated>
    
    <content type="html"><![CDATA[<p>mysql常用的一些命令 mysql启动2种方式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;mysql常用的一些命令 mysql启动2种方式&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>SpringBoot与缓存</title>
    <link href="http://blog.letmefly.cc/2019/08/10/SpringBoot%E4%B8%8E%E7%BC%93%E5%AD%98/"/>
    <id>http://blog.letmefly.cc/2019/08/10/SpringBoot与缓存/</id>
    <published>2019-08-10T11:15:15.000Z</published>
    <updated>2019-08-15T03:29:29.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot与缓存"><a href="#SpringBoot与缓存" class="headerlink" title="SpringBoot与缓存"></a>SpringBoot与缓存</h1><h2 id="JSR107简介"><a href="#JSR107简介" class="headerlink" title="JSR107简介"></a>JSR107简介</h2><p>JSR-107缓存规范（使用较少）、Spring缓存抽象、整合Redis</p><ul><li>CachingProvider：定义了创建、配置、获取、管理和控制多个CacheManager。一个应用可以在运行期间访问多个CachingProvider</li><li>CacheManager：定义了创建、配置、获取、管理和控制多个唯一命名的Cache，这些Cache存在于CacheManager的上下文中。一个CacheManager只能被一个CachingProvider所拥有。</li><li>Cache是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CaCheManager所拥有</li><li>Entry是一个存储在Cache中的key-value对</li><li>Expiry：每个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy来设置。</li></ul><h2 id="基于Spring抽象缓存简介"><a href="#基于Spring抽象缓存简介" class="headerlink" title="基于Spring抽象缓存简介"></a>基于Spring抽象缓存简介</h2><p>Spring3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache(JSR-107)注解简化我们开发；</p><ul><li>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</li><li>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCache,ConcurrentMapCache等</li><li>每次调用需要缓存功能的方法时，Spring会检查指定参数的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</li><li>使用Spring缓存抽象时我们需要关注以下两点：<ul><li>1、确定方法需要被缓存以及它们的缓存策略</li><li>2、从缓存中读取之前缓存存储的数据</li></ul></li></ul><table><thead><tr><th>注解</th><th>说明</th></tr></thead><tbody><tr><td>Cache</td><td>缓存接口，定义缓存操作。实现：RedisCache、EhCache、ConcurrentMapCache等</td></tr><tr><td>CacheManager</td><td>缓存管理器，管理各种缓存(Cache)组件</td></tr><tr><td>@Cacheable</td><td>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</td></tr><tr><td>@CacheEvict</td><td>清空缓存</td></tr><tr><td>@CachePut</td><td>保证方法被调用，又希望结果被缓存</td></tr><tr><td>@EnableCaching</td><td>开启基于注解的缓存</td></tr><tr><td>KeyGenerator</td><td>缓存数据时key生成策略</td></tr><tr><td>serialize</td><td>缓存数据时value序列化策略</td></tr></tbody></table><h2 id="基本环境搭建"><a href="#基本环境搭建" class="headerlink" title="基本环境搭建"></a>基本环境搭建</h2><p>需要引入的四个模块，web模块、spring abstract模块，mysql模块以及MyBatis模块</p><p>application.yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    url: jdbc:mysql://localhost:3306/spring_cache</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">mybatis:</span><br><span class="line">  configuration:</span><br><span class="line">#  开启驼峰命名匹配规则</span><br><span class="line">    map-underscore-to-camel-case: true</span><br><span class="line">#    driver-class-name: com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 搭建基本环境</span><br><span class="line"> * 1、导入数据库文件,创建出两张表，department和employee</span><br><span class="line"> * 2、创建JavaBean封装数据</span><br><span class="line"> * 3、整合MyBatis数据库</span><br><span class="line"> *  （1）配置数据库信息</span><br><span class="line"> *   (2)使用注解版的MyBatis：</span><br><span class="line"> *     （a）@MapperScan指定需要扫描的mapper接口所在的包</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><ul><li>1、新建数据表  </li><li>2、创建JavaBean封装数据</li></ul><p>Department.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.bean;</span><br><span class="line"></span><br><span class="line">public class Department &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String departmentName;</span><br><span class="line"></span><br><span class="line">    public Department() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Department(Integer id, String departmentName) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.departmentName = departmentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getDepartmentName() &#123;</span><br><span class="line">        return departmentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDepartmentName(String departmentName) &#123;</span><br><span class="line">        this.departmentName = departmentName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Department&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, departmentName=&apos;&quot; + departmentName + &apos;\&apos;&apos; +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>employee.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.bean;</span><br><span class="line"></span><br><span class="line">public class Employee &#123;</span><br><span class="line"></span><br><span class="line">    private Integer id;</span><br><span class="line"></span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    private Integer gender; // 性别：1：男    2：女</span><br><span class="line"></span><br><span class="line">    private Integer dId;</span><br><span class="line"></span><br><span class="line">    public Employee() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Employee(Integer id, String lastName, String email, Integer gender, Integer dId) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">        this.email = email;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">        this.dId = dId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">        return email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getGender() &#123;</span><br><span class="line">        return gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setGender(Integer gender) &#123;</span><br><span class="line">        this.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getdId() &#123;</span><br><span class="line">        return dId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setdId(Integer dId) &#123;</span><br><span class="line">        this.dId = dId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Employee&#123;&quot; +</span><br><span class="line">                &quot;id=&quot; + id +</span><br><span class="line">                &quot;, lastName=&apos;&quot; + lastName + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, email=&apos;&quot; + email + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, gender=&quot; + gender +</span><br><span class="line">                &quot;, dId=&quot; + dId +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、创建Mapper和Service</li></ul><p>DepartmentMapper.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.mapper;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface DepartmentMapper &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DepartmentService.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>EmployeeMapper.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.mapper;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">import org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface EmployeeMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from employee where id=#&#123;id&#125;&quot;)</span><br><span class="line">    Employee getEmpById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update employee set lastName=#&#123;lastName&#125;, email=#&#123;email&#125;,&quot; +</span><br><span class="line">            &quot;gender=#&#123;gender&#125;,d_id=#&#123;dId&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void updateEmp(Employee employee);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from employee where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void deleteEmpById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into employee(lastName,email,gender,d_id) values(#&#123;lastName&#125;,&quot; +</span><br><span class="line">            &quot;#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;)&quot;)</span><br><span class="line">    void insertEmployee(Employee employee);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>EmployeeService.java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.service;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    public Employee getEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;查询&quot; + id + &quot;号员工&quot;);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写Controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.controller;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">import com.usst.springboot01cache.service.EmployeeService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class EmployeeController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;emp/&#123;id&#125;&quot;)</span><br><span class="line">    public Employee getEmp(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        Employee emp = employeeService.getEmp(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主启动程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 搭建基本环境</span><br><span class="line"> * 1、导入数据库文件,创建出两张表，department和employee</span><br><span class="line"> * 2、创建JavaBean封装数据</span><br><span class="line"> * 3、整合MyBatis数据库</span><br><span class="line"> *  （1）配置数据库信息</span><br><span class="line"> *   (2)使用注解版的MyBatis：</span><br><span class="line"> *     （a）@MapperScan指定需要扫描的mapper接口所在的包</span><br><span class="line"> */</span><br><span class="line">@MapperScan(&quot;com.usst.springboot01cache.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot01cacheApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01cacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Cacheable初体验"><a href="#Cacheable初体验" class="headerlink" title="@Cacheable初体验"></a>@Cacheable初体验</h2><p>修改主配置类，添加相应的注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一、搭建基本环境</span><br><span class="line"> * 1、导入数据库文件,创建出两张表，department和employee</span><br><span class="line"> * 2、创建JavaBean封装数据</span><br><span class="line"> * 3、整合MyBatis数据库</span><br><span class="line"> *  （1）配置数据库信息</span><br><span class="line"> *   (2)使用注解版的MyBatis：</span><br><span class="line"> *     （a）@MapperScan指定需要扫描的mapper接口所在的包</span><br><span class="line"> *</span><br><span class="line"> * 二、快速体验缓存</span><br><span class="line"> *  步骤：</span><br><span class="line"> *      1、开启基于注解的缓存</span><br><span class="line"> *      2、标注缓存注解即可</span><br><span class="line"> *          /@Cacheable</span><br><span class="line"> *          /@CacheEvict</span><br><span class="line"> *          /@CachePut</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@MapperScan(&quot;com.usst.springboot01cache.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCaching</span><br><span class="line">public class Springboot01cacheApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01cacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主程序入口添加@Cacheable的注解</p><p>在Service层中对某个方法进行缓存,具体代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.service;</span><br><span class="line"></span><br><span class="line">        import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">        import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">        import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">        import org.springframework.cache.annotation.Cacheable;</span><br><span class="line">        import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将方法的运行结果进行缓存，以后如果再有相同的数据，直接从缓存获取，不用调用方法</span><br><span class="line">     *</span><br><span class="line">     * CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，</span><br><span class="line">     * 每一个缓存有自己唯一一个名字</span><br><span class="line">     *</span><br><span class="line">     * 几个属性：</span><br><span class="line">     *  cacheNames/value:指定缓存的名字；</span><br><span class="line">     *  key：缓存数据使用的key，可以用它来指定。默认是使用方法参数的值，1-方法的返回值</span><br><span class="line">     *      编写SpEL: #id；参数id的值   #root.args[0]</span><br><span class="line">     *  keyGenerator: key的生成器；也可以自己指定key的生成器的组件id</span><br><span class="line">     *      key/keyGenerator: 二选一使用</span><br><span class="line">     *  cacheManager：指定缓存管理器，或者cacheResolver指定获取解析器</span><br><span class="line">     *  condition: 指定符合条件的情况下才缓存</span><br><span class="line">     *  unless: 否定缓存，当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判定</span><br><span class="line">     *      unless = &quot;#result == null &quot;</span><br><span class="line">     *  sync: 是否使用异步模式</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">    @Cacheable(value = &quot;emp&quot;)</span><br><span class="line">    public Employee getEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;查询&quot; + id + &quot;号员工&quot;);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法名上添加@Cacheable注解，value/cacheNames用于指定缓存的名字，还有其他属性，后面的章节再做解释.</p><h2 id="缓存工作原理-amp-Cacheable"><a href="#缓存工作原理-amp-Cacheable" class="headerlink" title="缓存工作原理&amp;@Cacheable"></a>缓存工作原理&amp;@Cacheable</h2><pre><code>*  原理：*      1、自动配置类：CacheAutoConfiguration*      2、缓存的配置类：org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration*      3、哪个配置类生效？ SimpleCacheConfiguration**      4、给容器注册了一个CacheManager：ConcurrentMapCacheManager*      5、可以获取和创建ConcurrentMapCache类型的缓存组件：其作用是将数据保存在ConcurrentMap中；**      运行过程：*      、@Cahceable*      1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；*          （CacheManager先获取相应的缓存），如果没有，第一次获取缓存会自动创建出来；*      2、去Cache中查找缓存的内容，使用一个key，默认是方法的参数；*          key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key*          SimpleKeyGenerator生成key的默认策略；*              如果没有参数：key = new SimpleKey();*              如果有一个参数：key = 参数值*              如果有多个参数：key = new SimpleKey(params);*      3、没有查到缓存就调用目标方法；*      4、将目标方法返回的结果，放进缓存中**      @Cacheable标注的方法：方法执行之前先检查缓存中有没有这个数据，*      默认按照参数的值作为key去查询缓存，如果没有，就将运行方法并将结果放入缓存*      核心：*          （1）使用CacheManager[ConcurrentMapCacheManager]按照名字得到Cache[ConcurrentMapCache]组件*          （2）key使用keyGenerator生成的，默认使用SimpleKeyGenerator</code></pre><h2 id="Cacheable其他属性"><a href="#Cacheable其他属性" class="headerlink" title="@Cacheable其他属性"></a>@Cacheable其他属性</h2><p>SPEL表达式可以应用于@Cacheable的属性中</p><table><thead><tr><th>名字</th><th>位置</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>methodName</td><td>root object</td><td>当前被调用的方法名</td><td>#root.methodName</td></tr><tr><td>method</td><td>root object</td><td>当前被调用的方法</td><td>#root.method.name</td></tr><tr><td>target</td><td>root object</td><td>当前被调用的目标对象</td><td>#root.target</td></tr><tr><td>targetClass</td><td>root object</td><td>当前被调用的目标对象类</td><td>#root.targetClass</td></tr><tr><td>args</td><td>root object</td><td>当前被调用的方法的参数列表</td><td>#root.args[0]</td></tr><tr><td>caches</td><td>root object</td><td>当前方法调用使用的缓存列表(如@Cacheable(value={“cache1”, “cache2”})),则有两个cache</td><td>#root.caches[0].name</td></tr><tr><td>argumentname</td><td>evaluation context</td><td>方法参数的名字，可以直接 #参数名， 也可以使用 #p0或#a0的#iban、#a0的形式，0代表参数的索引</td><td>#iban、#a0、#p0</td></tr><tr><td>result</td><td>evaluation context</td><td>方法执行后的返回值(仅当方法执行后的判断有效，如’unless’,’cache put’的表达式’cache evice’的表达式beforeInvocation=false)</td><td>#result</td></tr></tbody></table><p>具体示例看如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.service;</span><br><span class="line"></span><br><span class="line">        import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">        import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">        import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">        import org.springframework.cache.annotation.Cacheable;</span><br><span class="line">        import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将方法的运行结果进行缓存，以后如果再有相同的数据，直接从缓存获取，不用调用方法</span><br><span class="line">     *</span><br><span class="line">     * CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，</span><br><span class="line">     * 每一个缓存有自己唯一一个名字</span><br><span class="line">     *</span><br><span class="line">     * 几个属性：</span><br><span class="line">     *  cacheNames/value:指定缓存的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存；</span><br><span class="line">     *  key：缓存数据使用的key，可以用它来指定。默认是使用方法参数的值，1-方法的返回值</span><br><span class="line">     *      编写SpEL: #i d；参数id的值   #a0  #p0   #root.args[0]</span><br><span class="line">     *      getEmp[2]</span><br><span class="line">     *  keyGenerator: key的生成器；也可以自己指定key的生成器的组件id</span><br><span class="line">     *      key/keyGenerator: 二选一使用</span><br><span class="line">     *  cacheManager：指定缓存管理器，或者cacheResolver指定获取解析器</span><br><span class="line">     *  condition: 指定符合条件的情况下才缓存</span><br><span class="line">     *      , condition = &quot;#id&gt;0&quot;</span><br><span class="line">     *      condition = &quot;#a0&gt;1&quot;：当第一个参数的值&gt;1的时候才进行缓存(1号员工不满足condition条件，无法缓存)</span><br><span class="line">     *</span><br><span class="line">     *  unless: 否定缓存，当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判定</span><br><span class="line">     *      unless = &quot;#result == null &quot;</span><br><span class="line">     *      unless = &quot;#a0 == 2&quot;;如果第一个参数的值是2，结果不缓存（2号员工满足unless条件，无法缓存）</span><br><span class="line">     *  sync: 是否使用异步模式,默认是异步</span><br><span class="line">     *      </span><br><span class="line">     *</span><br><span class="line">     *  原理：</span><br><span class="line">     *      1、自动配置类：CacheAutoConfiguration</span><br><span class="line">     *      2、缓存的配置类：org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration</span><br><span class="line">     *      3、哪个配置类生效？ SimpleCacheConfiguration</span><br><span class="line">     *</span><br><span class="line">     *      4、给容器注册了一个CacheManager：ConcurrentMapCacheManager</span><br><span class="line">     *      5、可以获取和创建ConcurrentMapCache类型的缓存组件：其作用是将数据保存在ConcurrentMap中；</span><br><span class="line">     *</span><br><span class="line">     *      运行过程：</span><br><span class="line">     *      、@Cahceable</span><br><span class="line">     *      1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；</span><br><span class="line">     *          （CacheManager先获取相应的缓存），如果没有，第一次获取缓存会自动创建出来；</span><br><span class="line">     *      2、去Cache中查找缓存的内容，使用一个key，默认是方法的参数；</span><br><span class="line">     *          key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key</span><br><span class="line">     *          SimpleKeyGenerator生成key的默认策略；</span><br><span class="line">     *              如果没有参数：key = new SimpleKey();</span><br><span class="line">     *              如果有一个参数：key = 参数值</span><br><span class="line">     *              如果有多个参数：key = new SimpleKey(params);</span><br><span class="line">     *      3、没有查到缓存就调用目标方法；</span><br><span class="line">     *      4、将目标方法返回的结果，放进缓存中</span><br><span class="line">     *</span><br><span class="line">     *      @Cacheable标注的方法：方法执行之前先检查缓存中有没有这个数据，</span><br><span class="line">     *      默认按照参数的值作为key去查询缓存，如果没有，就将运行方法并将结果放入缓存;</span><br><span class="line">     *      以后再来调用就可以直接使用缓存中的数据；</span><br><span class="line">     *</span><br><span class="line">     *      核心：</span><br><span class="line">     *          （1）使用CacheManager[ConcurrentMapCacheManager]按照名字得到Cache[ConcurrentMapCache]组件</span><br><span class="line">     *          （2）key使用keyGenerator生成的，默认使用SimpleKeyGenerator</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">//    @Cacheable(value = &quot;emp&quot;, key = &quot;#root.methodName+&apos;[&apos;+#id+&apos;]&apos;&quot;)</span><br><span class="line">    @Cacheable(value = &quot;emp&quot;, keyGenerator = &quot;myKeyGenerator&quot;, condition = &quot;#a0&gt;1&quot;, unless = &quot;#a0 == 2&quot;)</span><br><span class="line">    public Employee getEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;查询&quot; + id + &quot;号员工&quot;);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="CachePut"><a href="#CachePut" class="headerlink" title="@CachePut"></a>@CachePut</h2><p>示例：验证数据更新之后缓存是否能同步更新</p><p>编写Controller：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.controller;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">import com.usst.springboot01cache.service.EmployeeService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class EmployeeController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;emp/&#123;id&#125;&quot;)</span><br><span class="line">    public Employee getEmp(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        Employee emp = employeeService.getEmp(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;emp&quot;)</span><br><span class="line">    public Employee update(Employee employee)&#123;</span><br><span class="line">        Employee emp = employeeService.update(employee);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重点是update方法，在Service层新增加一个注解@CachePut</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.service;</span><br><span class="line"></span><br><span class="line">        import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">        import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">        import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">        import org.springframework.cache.annotation.CachePut;</span><br><span class="line">        import org.springframework.cache.annotation.Cacheable;</span><br><span class="line">        import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将方法的运行结果进行缓存，以后如果再有相同的数据，直接从缓存获取，不用调用方法</span><br><span class="line">     *</span><br><span class="line">     * CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，</span><br><span class="line">     * 每一个缓存有自己唯一一个名字</span><br><span class="line">     *</span><br><span class="line">     * 几个属性：</span><br><span class="line">     *  cacheNames/value:指定缓存的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存；</span><br><span class="line">     *  key：缓存数据使用的key，可以用它来指定。默认是使用方法参数的值，1-方法的返回值</span><br><span class="line">     *      编写SpEL: #i d；参数id的值   #a0  #p0   #root.args[0]</span><br><span class="line">     *      getEmp[2]</span><br><span class="line">     *  keyGenerator: key的生成器；也可以自己指定key的生成器的组件id</span><br><span class="line">     *      key/keyGenerator: 二选一使用</span><br><span class="line">     *  cacheManager：指定缓存管理器，或者cacheResolver指定获取解析器</span><br><span class="line">     *  condition: 指定符合条件的情况下才缓存</span><br><span class="line">     *      , condition = &quot;#id&gt;0&quot;</span><br><span class="line">     *      condition = &quot;#a0&gt;1&quot;：当第一个参数的值&gt;1的时候才进行缓存(1号员工不满足condition条件，无法缓存)</span><br><span class="line">     *</span><br><span class="line">     *  unless: 否定缓存，当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判定</span><br><span class="line">     *      unless = &quot;#result == null &quot;</span><br><span class="line">     *      unless = &quot;#a0 == 2&quot;;如果第一个参数的值是2，结果不缓存（2号员工满足unless条件，无法缓存）</span><br><span class="line">     *  sync: 是否使用异步模式,默认是异步</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     *  原理：</span><br><span class="line">     *      1、自动配置类：CacheAutoConfiguration</span><br><span class="line">     *      2、缓存的配置类：org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration</span><br><span class="line">     *      3、哪个配置类生效？ SimpleCacheConfiguration</span><br><span class="line">     *</span><br><span class="line">     *      4、给容器注册了一个CacheManager：ConcurrentMapCacheManager</span><br><span class="line">     *      5、可以获取和创建ConcurrentMapCache类型的缓存组件：其作用是将数据保存在ConcurrentMap中；</span><br><span class="line">     *</span><br><span class="line">     *      运行过程：</span><br><span class="line">     *      、@Cahceable</span><br><span class="line">     *      1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；</span><br><span class="line">     *          （CacheManager先获取相应的缓存），如果没有，第一次获取缓存会自动创建出来；</span><br><span class="line">     *      2、去Cache中查找缓存的内容，使用一个key，默认是方法的参数；</span><br><span class="line">     *          key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key</span><br><span class="line">     *          SimpleKeyGenerator生成key的默认策略；</span><br><span class="line">     *              如果没有参数：key = new SimpleKey();</span><br><span class="line">     *              如果有一个参数：key = 参数值</span><br><span class="line">     *              如果有多个参数：key = new SimpleKey(params);</span><br><span class="line">     *      3、没有查到缓存就调用目标方法；</span><br><span class="line">     *      4、将目标方法返回的结果，放进缓存中</span><br><span class="line">     *</span><br><span class="line">     *      @Cacheable标注的方法：方法执行之前先检查缓存中有没有这个数据，</span><br><span class="line">     *      默认按照参数的值作为key去查询缓存，如果没有，就将运行方法并将结果放入缓存;</span><br><span class="line">     *      以后再来调用就可以直接使用缓存中的数据；</span><br><span class="line">     *</span><br><span class="line">     *      核心：</span><br><span class="line">     *          （1）使用CacheManager[ConcurrentMapCacheManager]按照名字得到Cache[ConcurrentMapCache]组件</span><br><span class="line">     *          （2）key使用keyGenerator生成的，默认使用SimpleKeyGenerator</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">//    @Cacheable(value = &quot;emp&quot;, key = &quot;#root.methodName+&apos;[&apos;+#id+&apos;]&apos;&quot;)</span><br><span class="line">//    @Cacheable(value = &quot;emp&quot;, keyGenerator = &quot;myKeyGenerator&quot;, condition = &quot;#a0&gt;1&quot;, unless = &quot;#a0 == 2&quot;)</span><br><span class="line">    @Cacheable(value = &quot;emp&quot;)</span><br><span class="line">    public Employee getEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;查询&quot; + id + &quot;号员工&quot;);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @CachePut，既调用方法，又更新缓存数据；同步更新缓存</span><br><span class="line">     * 修改了数据库的某个数据，同时更新缓存</span><br><span class="line">     *</span><br><span class="line">     * 运行时机</span><br><span class="line">     *  1、先调用目标方法</span><br><span class="line">     *  2、将目标结果的方法缓存起来</span><br><span class="line">     *</span><br><span class="line">     * 测试步骤：</span><br><span class="line">     * @Cacheable</span><br><span class="line">     *  1、查询1号员工，查询的结果会放在缓存中</span><br><span class="line">     *      key: 1      value  lastName: 张三</span><br><span class="line">     *  2、以后查询还是之前的结果</span><br><span class="line">     *  3、更新1号员工，更新后信息改变</span><br><span class="line">     *      将方法的返回值也放入了缓存</span><br><span class="line">     *      key：传入的Employee对象，值是返回的Employee对象</span><br><span class="line">     *  4、查询更新后的员工</span><br><span class="line">     *      应该是更新后的员工</span><br><span class="line">     *          key = &quot;#employee.id&quot;,使用传入的参数的员工id;</span><br><span class="line">     *          key = &quot;#result.id&quot;,使用返回后的id</span><br><span class="line">     *          、@Cacheable的key是不能用#result.id获取返回结果的</span><br><span class="line">     *      为什么还是未更新之前的缓存？</span><br><span class="line">     *          【1号员工没有在缓存中更新】</span><br><span class="line">     */</span><br><span class="line">    @CachePut(value = &quot;emp&quot;, key = &quot;#employee.id&quot;)</span><br><span class="line">    public Employee update(Employee employee)&#123;</span><br><span class="line">        System.out.println(&quot;updateEmp:&quot; + employee);</span><br><span class="line">        employeeMapper.updateEmp(employee);</span><br><span class="line">        return employee;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：@CachePut(value = “emp”, key = “#employee.id”)和    @Cacheable的key是同一个key，即取和放的key都相同即可完成同步更新缓存操作。</p><h2 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a>@Caching</h2><p>@Caching是Cacheable、Evict和Put的集合。用于较为复杂的缓存规则。</p><p>老三样：</p><p>修改Controller,增加方法getEmpByLastName</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.controller;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">import com.usst.springboot01cache.service.EmployeeService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class EmployeeController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeService employeeService;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;emp/&#123;id&#125;&quot;)</span><br><span class="line">    public Employee getEmp(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        Employee emp = employeeService.getEmp(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;emp&quot;)</span><br><span class="line">    public Employee update(Employee employee)&#123;</span><br><span class="line">        Employee emp = employeeService.update(employee);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;delemp&quot;)</span><br><span class="line">    public String deleteEmp(Integer id)&#123;</span><br><span class="line">        employeeService.deleteEmp(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;emp/lastName/&#123;lastName&#125;&quot;)</span><br><span class="line">    public Employee getEmpByLastName(@PathVariable(&quot;lastName&quot;) String lastName)&#123;</span><br><span class="line">        return employeeService.getEmpByLastName(lastName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Mapper，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.mapper;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">import org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line">@Mapper</span><br><span class="line">public interface EmployeeMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from employee where id=#&#123;id&#125;&quot;)</span><br><span class="line">    Employee getEmpById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update employee set lastName=#&#123;lastName&#125;, email=#&#123;email&#125;,&quot; +</span><br><span class="line">            &quot;gender=#&#123;gender&#125;,d_id=#&#123;dId&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void updateEmp(Employee employee);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from employee where id=#&#123;id&#125;&quot;)</span><br><span class="line">    void deleteEmpById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into employee(lastName,email,gender,d_id) values(#&#123;lastName&#125;,&quot; +</span><br><span class="line">            &quot;#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;)&quot;)</span><br><span class="line">    void insertEmployee(Employee employee);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from employee where lastName=#&#123;lastName&#125;&quot;)</span><br><span class="line">    Employee getEmpByLastName(String lastName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改Service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.service;</span><br><span class="line"></span><br><span class="line">        import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">        import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">        import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">        import org.springframework.cache.annotation.CacheEvict;</span><br><span class="line">        import org.springframework.cache.annotation.CachePut;</span><br><span class="line">        import org.springframework.cache.annotation.Cacheable;</span><br><span class="line">        import org.springframework.cache.annotation.Caching;</span><br><span class="line">        import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将方法的运行结果进行缓存，以后如果再有相同的数据，直接从缓存获取，不用调用方法</span><br><span class="line">     *</span><br><span class="line">     * CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，</span><br><span class="line">     * 每一个缓存有自己唯一一个名字</span><br><span class="line">     *</span><br><span class="line">     * 几个属性：</span><br><span class="line">     *  cacheNames/value:指定缓存的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存；</span><br><span class="line">     *  key：缓存数据使用的key，可以用它来指定。默认是使用方法参数的值，1-方法的返回值</span><br><span class="line">     *      编写SpEL: #i d；参数id的值   #a0  #p0   #root.args[0]</span><br><span class="line">     *      getEmp[2]</span><br><span class="line">     *  keyGenerator: key的生成器；也可以自己指定key的生成器的组件id</span><br><span class="line">     *      key/keyGenerator: 二选一使用</span><br><span class="line">     *  cacheManager：指定缓存管理器，或者cacheResolver指定获取解析器</span><br><span class="line">     *  condition: 指定符合条件的情况下才缓存</span><br><span class="line">     *      , condition = &quot;#id&gt;0&quot;</span><br><span class="line">     *      condition = &quot;#a0&gt;1&quot;：当第一个参数的值&gt;1的时候才进行缓存(1号员工不满足condition条件，无法缓存)</span><br><span class="line">     *</span><br><span class="line">     *  unless: 否定缓存，当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判定</span><br><span class="line">     *      unless = &quot;#result == null &quot;</span><br><span class="line">     *      unless = &quot;#a0 == 2&quot;;如果第一个参数的值是2，结果不缓存（2号员工满足unless条件，无法缓存）</span><br><span class="line">     *  sync: 是否使用异步模式,默认是异步</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     *  原理：</span><br><span class="line">     *      1、自动配置类：CacheAutoConfiguration</span><br><span class="line">     *      2、缓存的配置类：org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration</span><br><span class="line">     *      3、哪个配置类生效？ SimpleCacheConfiguration</span><br><span class="line">     *</span><br><span class="line">     *      4、给容器注册了一个CacheManager：ConcurrentMapCacheManager</span><br><span class="line">     *      5、可以获取和创建ConcurrentMapCache类型的缓存组件：其作用是将数据保存在ConcurrentMap中；</span><br><span class="line">     *</span><br><span class="line">     *      运行过程：</span><br><span class="line">     *      、@Cahceable</span><br><span class="line">     *      1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；</span><br><span class="line">     *          （CacheManager先获取相应的缓存），如果没有，第一次获取缓存会自动创建出来；</span><br><span class="line">     *      2、去Cache中查找缓存的内容，使用一个key，默认是方法的参数；</span><br><span class="line">     *          key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key</span><br><span class="line">     *          SimpleKeyGenerator生成key的默认策略；</span><br><span class="line">     *              如果没有参数：key = new SimpleKey();</span><br><span class="line">     *              如果有一个参数：key = 参数值</span><br><span class="line">     *              如果有多个参数：key = new SimpleKey(params);</span><br><span class="line">     *      3、没有查到缓存就调用目标方法；</span><br><span class="line">     *      4、将目标方法返回的结果，放进缓存中</span><br><span class="line">     *</span><br><span class="line">     *      @Cacheable标注的方法：方法执行之前先检查缓存中有没有这个数据，</span><br><span class="line">     *      默认按照参数的值作为key去查询缓存，如果没有，就将运行方法并将结果放入缓存;</span><br><span class="line">     *      以后再来调用就可以直接使用缓存中的数据；</span><br><span class="line">     *</span><br><span class="line">     *      核心：</span><br><span class="line">     *          （1）使用CacheManager[ConcurrentMapCacheManager]按照名字得到Cache[ConcurrentMapCache]组件</span><br><span class="line">     *          （2）key使用keyGenerator生成的，默认使用SimpleKeyGenerator</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">//    @Cacheable(value = &quot;emp&quot;, key = &quot;#root.methodName+&apos;[&apos;+#id+&apos;]&apos;&quot;)</span><br><span class="line">//    @Cacheable(value = &quot;emp&quot;, keyGenerator = &quot;myKeyGenerator&quot;, condition = &quot;#a0&gt;1&quot;, unless = &quot;#a0 == 2&quot;)</span><br><span class="line">    @Cacheable(value = &quot;emp&quot;)</span><br><span class="line">    public Employee getEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;查询&quot; + id + &quot;号员工&quot;);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @CachePut，既调用方法，又更新缓存数据；同步更新缓存</span><br><span class="line">     * 修改了数据库的某个数据，同时更新缓存</span><br><span class="line">     *</span><br><span class="line">     * 运行时机</span><br><span class="line">     *  1、先调用目标方法</span><br><span class="line">     *  2、将目标结果的方法缓存起来</span><br><span class="line">     *</span><br><span class="line">     * 测试步骤：</span><br><span class="line">     * @Cacheable</span><br><span class="line">     *  1、查询1号员工，查询的结果会放在缓存中</span><br><span class="line">     *      key: 1      value  lastName: 张三</span><br><span class="line">     *  2、以后查询还是之前的结果</span><br><span class="line">     *  3、更新1号员工，更新后信息改变</span><br><span class="line">     *      将方法的返回值也放入了缓存</span><br><span class="line">     *      key：传入的Employee对象，值是返回的Employee对象</span><br><span class="line">     *  4、查询更新后的员工</span><br><span class="line">     *      应该是更新后的员工</span><br><span class="line">     *          key = &quot;#employee.id&quot;,使用传入的参数的员工id;</span><br><span class="line">     *          key = &quot;#result.id&quot;,使用返回后的id</span><br><span class="line">     *          、@Cacheable的key是不能用#result.id获取返回结果的</span><br><span class="line">     *      为什么还是未更新之前的缓存？</span><br><span class="line">     *          【1号员工没有在缓存中更新】</span><br><span class="line">     */</span><br><span class="line">    @CachePut(value = &quot;emp&quot;, key = &quot;#employee.id&quot;)</span><br><span class="line">    public Employee update(Employee employee)&#123;</span><br><span class="line">        System.out.println(&quot;updateEmp:&quot; + employee);</span><br><span class="line">        employeeMapper.updateEmp(employee);</span><br><span class="line">        return employee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存清除</span><br><span class="line">     *  key：指定要清除的数据</span><br><span class="line">     *  allEntries = true：指定清除这个缓存中所有的数据</span><br><span class="line">     *  beforeInvocation = false,缓存的清除是否在方法之前执行</span><br><span class="line">     *      默认代表缓存清除操作是在方法之后执行，如果出现异常，缓存就不会清除</span><br><span class="line">     *  beforeInvocation = true,</span><br><span class="line">     *      代表缓存清除操作是在方法之前执行，无论是否出现异常，缓存都会清除</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">//    @CacheEvict(value = &quot;emp&quot;, key = &quot;#id&quot;) // 按照指定的key删除缓存</span><br><span class="line">//    @CacheEvict(value = &quot;emp&quot;, allEntries = true) // 删除所有的缓存</span><br><span class="line">    @CacheEvict(value = &quot;emp&quot;, beforeInvocation = true)</span><br><span class="line">    public void deleteEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;deleteEmp&quot; + id);</span><br><span class="line">        int i = 10 / 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Caching：定义复杂的缓存规则</span><br><span class="line">    @Caching(</span><br><span class="line">            cacheable = &#123;</span><br><span class="line">                    @Cacheable(value = &quot;emp&quot;, key = &quot;#lastName&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            put = &#123;</span><br><span class="line">                    @CachePut(value = &quot;emp&quot;, key = &quot;#result.id&quot;), // 可以按照id查询缓存</span><br><span class="line">                    @CachePut(value = &quot;emp&quot;, key = &quot;#result.email&quot;) // 可以按照email查询缓存</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">    public Employee getEmpByLastName(String lastName) &#123;</span><br><span class="line"></span><br><span class="line">        return employeeMapper.getEmpByLastName(lastName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Service层中，除了利用@Caching注解定义复杂的缓存规则之外，还可以在类上添加注解@CacheConfig，以下是Service示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache.service;</span><br><span class="line"></span><br><span class="line">        import com.usst.springboot01cache.bean.Employee;</span><br><span class="line">        import com.usst.springboot01cache.mapper.EmployeeMapper;</span><br><span class="line">        import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">        import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">        import org.springframework.cache.annotation.*;</span><br><span class="line">        import org.springframework.stereotype.Service;</span><br><span class="line">@CacheConfig(cacheNames = &quot;emp&quot;) // 抽取缓存的公共配置</span><br><span class="line">@Service</span><br><span class="line">public class EmployeeService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    EmployeeMapper employeeMapper;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 将方法的运行结果进行缓存，以后如果再有相同的数据，直接从缓存获取，不用调用方法</span><br><span class="line">     *</span><br><span class="line">     * CacheManager管理多个Cache组件，对缓存的真正CRUD操作在Cache组件中，</span><br><span class="line">     * 每一个缓存有自己唯一一个名字</span><br><span class="line">     *</span><br><span class="line">     * 几个属性：</span><br><span class="line">     *  cacheNames/value:指定缓存的名字，将方法的返回结果放在哪个缓存中，是数组的方式，可以指定多个缓存；</span><br><span class="line">     *  key：缓存数据使用的key，可以用它来指定。默认是使用方法参数的值，1-方法的返回值</span><br><span class="line">     *      编写SpEL: #i d；参数id的值   #a0  #p0   #root.args[0]</span><br><span class="line">     *      getEmp[2]</span><br><span class="line">     *  keyGenerator: key的生成器；也可以自己指定key的生成器的组件id</span><br><span class="line">     *      key/keyGenerator: 二选一使用</span><br><span class="line">     *  cacheManager：指定缓存管理器，或者cacheResolver指定获取解析器</span><br><span class="line">     *  condition: 指定符合条件的情况下才缓存</span><br><span class="line">     *      , condition = &quot;#id&gt;0&quot;</span><br><span class="line">     *      condition = &quot;#a0&gt;1&quot;：当第一个参数的值&gt;1的时候才进行缓存(1号员工不满足condition条件，无法缓存)</span><br><span class="line">     *</span><br><span class="line">     *  unless: 否定缓存，当unless指定的条件为true，方法的返回值就不会被缓存；可以获取到结果进行判定</span><br><span class="line">     *      unless = &quot;#result == null &quot;</span><br><span class="line">     *      unless = &quot;#a0 == 2&quot;;如果第一个参数的值是2，结果不缓存（2号员工满足unless条件，无法缓存）</span><br><span class="line">     *  sync: 是否使用异步模式,默认是异步</span><br><span class="line">     *</span><br><span class="line">     *</span><br><span class="line">     *  原理：</span><br><span class="line">     *      1、自动配置类：CacheAutoConfiguration</span><br><span class="line">     *      2、缓存的配置类：org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration</span><br><span class="line">     *      3、哪个配置类生效？ SimpleCacheConfiguration</span><br><span class="line">     *</span><br><span class="line">     *      4、给容器注册了一个CacheManager：ConcurrentMapCacheManager</span><br><span class="line">     *      5、可以获取和创建ConcurrentMapCache类型的缓存组件：其作用是将数据保存在ConcurrentMap中；</span><br><span class="line">     *</span><br><span class="line">     *      运行过程：</span><br><span class="line">     *      、@Cahceable</span><br><span class="line">     *      1、方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取；</span><br><span class="line">     *          （CacheManager先获取相应的缓存），如果没有，第一次获取缓存会自动创建出来；</span><br><span class="line">     *      2、去Cache中查找缓存的内容，使用一个key，默认是方法的参数；</span><br><span class="line">     *          key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key</span><br><span class="line">     *          SimpleKeyGenerator生成key的默认策略；</span><br><span class="line">     *              如果没有参数：key = new SimpleKey();</span><br><span class="line">     *              如果有一个参数：key = 参数值</span><br><span class="line">     *              如果有多个参数：key = new SimpleKey(params);</span><br><span class="line">     *      3、没有查到缓存就调用目标方法；</span><br><span class="line">     *      4、将目标方法返回的结果，放进缓存中</span><br><span class="line">     *</span><br><span class="line">     *      @Cacheable标注的方法：方法执行之前先检查缓存中有没有这个数据，</span><br><span class="line">     *      默认按照参数的值作为key去查询缓存，如果没有，就将运行方法并将结果放入缓存;</span><br><span class="line">     *      以后再来调用就可以直接使用缓存中的数据；</span><br><span class="line">     *</span><br><span class="line">     *      核心：</span><br><span class="line">     *          （1）使用CacheManager[ConcurrentMapCacheManager]按照名字得到Cache[ConcurrentMapCache]组件</span><br><span class="line">     *          （2）key使用keyGenerator生成的，默认使用SimpleKeyGenerator</span><br><span class="line">     *</span><br><span class="line">     * @param id</span><br><span class="line">     * @return</span><br><span class="line">     */</span><br><span class="line">//    @Cacheable(value = &quot;emp&quot;, key = &quot;#root.methodName+&apos;[&apos;+#id+&apos;]&apos;&quot;)</span><br><span class="line">//    @Cacheable(value = &quot;emp&quot;, keyGenerator = &quot;myKeyGenerator&quot;, condition = &quot;#a0&gt;1&quot;, unless = &quot;#a0 == 2&quot;)</span><br><span class="line">    @Cacheable(value = &quot;emp&quot;)</span><br><span class="line">    public Employee getEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;查询&quot; + id + &quot;号员工&quot;);</span><br><span class="line">        Employee emp = employeeMapper.getEmpById(id);</span><br><span class="line">        return emp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * @CachePut，既调用方法，又更新缓存数据；同步更新缓存</span><br><span class="line">     * 修改了数据库的某个数据，同时更新缓存</span><br><span class="line">     *</span><br><span class="line">     * 运行时机</span><br><span class="line">     *  1、先调用目标方法</span><br><span class="line">     *  2、将目标结果的方法缓存起来</span><br><span class="line">     *</span><br><span class="line">     * 测试步骤：</span><br><span class="line">     * @Cacheable</span><br><span class="line">     *  1、查询1号员工，查询的结果会放在缓存中</span><br><span class="line">     *      key: 1      value  lastName: 张三</span><br><span class="line">     *  2、以后查询还是之前的结果</span><br><span class="line">     *  3、更新1号员工，更新后信息改变</span><br><span class="line">     *      将方法的返回值也放入了缓存</span><br><span class="line">     *      key：传入的Employee对象，值是返回的Employee对象</span><br><span class="line">     *  4、查询更新后的员工</span><br><span class="line">     *      应该是更新后的员工</span><br><span class="line">     *          key = &quot;#employee.id&quot;,使用传入的参数的员工id;</span><br><span class="line">     *          key = &quot;#result.id&quot;,使用返回后的id</span><br><span class="line">     *          、@Cacheable的key是不能用#result.id获取返回结果的</span><br><span class="line">     *      为什么还是未更新之前的缓存？</span><br><span class="line">     *          【1号员工没有在缓存中更新】</span><br><span class="line">     */</span><br><span class="line">    @CachePut(key = &quot;#employee.id&quot;)</span><br><span class="line">    public Employee update(Employee employee)&#123;</span><br><span class="line">        System.out.println(&quot;updateEmp:&quot; + employee);</span><br><span class="line">        employeeMapper.updateEmp(employee);</span><br><span class="line">        return employee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 缓存清除</span><br><span class="line">     *  key：指定要清除的数据</span><br><span class="line">     *  allEntries = true：指定清除这个缓存中所有的数据</span><br><span class="line">     *  beforeInvocation = false,缓存的清除是否在方法之前执行</span><br><span class="line">     *      默认代表缓存清除操作是在方法之后执行，如果出现异常，缓存就不会清除</span><br><span class="line">     *  beforeInvocation = true,</span><br><span class="line">     *      代表缓存清除操作是在方法之前执行，无论是否出现异常，缓存都会清除</span><br><span class="line">     *</span><br><span class="line">     */</span><br><span class="line">//    @CacheEvict(value = &quot;emp&quot;, key = &quot;#id&quot;) // 按照指定的key删除缓存</span><br><span class="line">//    @CacheEvict(value = &quot;emp&quot;, allEntries = true) // 删除所有的缓存</span><br><span class="line">    @CacheEvict(value = &quot;emp&quot;, beforeInvocation = true)</span><br><span class="line">    public void deleteEmp(Integer id)&#123;</span><br><span class="line">        System.out.println(&quot;deleteEmp&quot; + id);</span><br><span class="line">        int i = 10 / 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // @Caching：定义复杂的缓存规则</span><br><span class="line">    @Caching(</span><br><span class="line">            cacheable = &#123;</span><br><span class="line">                    @Cacheable(key = &quot;#lastName&quot;)</span><br><span class="line">            &#125;,</span><br><span class="line">            put = &#123;</span><br><span class="line">                    @CachePut(key = &quot;#result.id&quot;), // 可以按照id查询缓存</span><br><span class="line">                    @CachePut(key = &quot;#result.email&quot;) // 可以按照email查询缓存</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">    )</span><br><span class="line">    public Employee getEmpByLastName(String lastName) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(lastName);</span><br><span class="line">        return employeeMapper.getEmpByLastName(lastName);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个有些问题，效果没出来。。先大体知道这个流程吧</p><p>总结</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot01cache;</span><br><span class="line"></span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.cache.annotation.EnableCaching;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 一、搭建基本环境</span><br><span class="line"> * 1、导入数据库文件,创建出两张表，department和employee</span><br><span class="line"> * 2、创建JavaBean封装数据</span><br><span class="line"> * 3、整合MyBatis数据库</span><br><span class="line"> *  （1）配置数据库信息</span><br><span class="line"> *   (2)使用注解版的MyBatis：</span><br><span class="line"> *     （a）@MapperScan指定需要扫描的mapper接口所在的包</span><br><span class="line"> *</span><br><span class="line"> * 二、快速体验缓存</span><br><span class="line"> *  步骤：</span><br><span class="line"> *      1、开启基于注解的缓存</span><br><span class="line"> *      2、标注缓存注解即可</span><br><span class="line"> *          /@Cacheable</span><br><span class="line"> *          /@CacheEvict</span><br><span class="line"> *          /@CachePut</span><br><span class="line"> *</span><br><span class="line"> *  默认使用的是ConcurrentMapCacheManager=ConcurrentMapCache:将数据保存在ConcurrentMap&lt;Object, Object&gt;</span><br><span class="line"> *      开发中经常使用缓存中间件，比如：redis、Memcached、ehcache</span><br><span class="line"> *</span><br><span class="line"> * 三、整合Redis</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">@MapperScan(&quot;com.usst.springboot01cache.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCaching</span><br><span class="line">public class Springboot01cacheApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot01cacheApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改到Redis了，先停一停，把Redis看一看</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot与缓存&quot;&gt;&lt;a href=&quot;#SpringBoot与缓存&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot与缓存&quot;&gt;&lt;/a&gt;SpringBoot与缓存&lt;/h1&gt;&lt;h2 id=&quot;JSR107简介&quot;&gt;&lt;a href=&quot;#J
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="cache" scheme="http://blog.letmefly.cc/tags/cache/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot启动原理</title>
    <link href="http://blog.letmefly.cc/2019/08/09/SpringBoot%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://blog.letmefly.cc/2019/08/09/SpringBoot启动原理/</id>
    <published>2019-08-09T12:31:25.000Z</published>
    <updated>2019-08-10T03:57:29.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoost启动原理"><a href="#SpringBoost启动原理" class="headerlink" title="SpringBoost启动原理"></a>SpringBoost启动原理</h1><h2 id="创建Application"><a href="#创建Application" class="headerlink" title="创建Application"></a>创建Application</h2><h3 id="启动配置原理"><a href="#启动配置原理" class="headerlink" title="启动配置原理"></a>启动配置原理</h3><p>几个重要的回调机制：</p><p>配置在META-INF/spring.factories中</p><ul><li><strong>ApplicationContextinitializer</strong></li><li><strong>SpringApplicationRunListener</strong></li></ul><p>只需要放在IOC容器中</p><ul><li>ApplicationRunner</li><li>CommandLineRunner</li></ul><h3 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h3><ul><li>1、创建SpringApplication对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">// 调用这个方法加载默认参数</span><br><span class="line">this((ResourceLoader)null, primarySources);</span><br><span class="line"></span><br><span class="line">   public SpringApplication(ResourceLoader resourceLoader, Class... primarySources) &#123;</span><br><span class="line">   // 主配置类</span><br><span class="line">       this.sources = new LinkedHashSet();</span><br><span class="line">       this.bannerMode = Mode.CONSOLE;</span><br><span class="line">       this.logStartupInfo = true;</span><br><span class="line">       this.addCommandLineProperties = true;</span><br><span class="line">       this.addConversionService = true;</span><br><span class="line">       this.headless = true;</span><br><span class="line">       this.registerShutdownHook = true;</span><br><span class="line">       this.additionalProfiles = new HashSet();</span><br><span class="line">       this.isCustomEnvironment = false;</span><br><span class="line">       this.resourceLoader = resourceLoader;</span><br><span class="line">       Assert.notNull(primarySources, &quot;PrimarySources must not be null&quot;);</span><br><span class="line">       this.primarySources = new LinkedHashSet(Arrays.asList(primarySources));</span><br><span class="line">       // 判断是否是web应用</span><br><span class="line">       this.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">       //从类路径下找到META/spring.factories配置的所有ApplicationContextInitializer；然后保存</span><br><span class="line">       this.setInitializers(this.getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">       // 从类路径下找到META-INF/spring.factories配置的所有ApplicationListener</span><br><span class="line">        this.setListeners(this.getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">        //从多个配置类中找到有main方法的主配置类</span><br><span class="line">       this.mainApplicationClass = this.deduceMainApplicationClass();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/09/SpringBoot启动原理/Initializer.jpg" alt="SpringBoot启动时加载的Initializer"><br><img src="/2019/08/09/SpringBoot启动原理/Listener.jpg" alt="SpringBoot启动时加载的Initializer"></p><h2 id="启动应用"><a href="#启动应用" class="headerlink" title="启动应用"></a>启动应用</h2><p>接上面</p><ul><li>2、运行run方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> public ConfigurableApplicationContext run(String... args) &#123;</span><br><span class="line">     StopWatch stopWatch = new StopWatch();</span><br><span class="line">     stopWatch.start();</span><br><span class="line">     ConfigurableApplicationContext context = null;</span><br><span class="line">     Collection&lt;SpringBootExceptionReporter&gt; exceptionReporters = new ArrayList();</span><br><span class="line">     this.configureHeadlessProperty();</span><br><span class="line">     // 获取SpringApplicationRunListeners，从类路径下META-INF/spring.factories中获取</span><br><span class="line">     SpringApplicationRunListeners listeners = this.getRunListeners(args);</span><br><span class="line">     // 回调所有的SpringApplicationRunListeners.starting()方法</span><br><span class="line">     listeners.starting();</span><br><span class="line"></span><br><span class="line">     Collection exceptionReporters;</span><br><span class="line">     try &#123;</span><br><span class="line">     //封装命令行参数</span><br><span class="line">         ApplicationArguments applicationArguments = new DefaultApplicationArguments(args);</span><br><span class="line">         // 准备环境</span><br><span class="line">         ConfigurableEnvironment environment = this.prepareEnvironment(listeners, applicationArguments);</span><br><span class="line">         this.configureIgnoreBeanInfo(environment);</span><br><span class="line">         // 创建环境完成后回调SpringApplicationRunListeners.environmentPrepared()的方法，表示环境准备完成</span><br><span class="line">         Banner printedBanner = this.printBanner(environment);</span><br><span class="line">         // 创建Context，决定创建web的IOC还是普通的IOC</span><br><span class="line">         context = this.createApplicationContext();</span><br><span class="line">         exceptionReporters = this.getSpringFactoriesInstances(SpringBootExceptionReporter.class, new Class[]&#123;ConfigurableApplicationContext.class&#125;, context);</span><br><span class="line">         // 准备上下文环境，将environment保存到IOC中，而且applyInitializers()</span><br><span class="line">         // applyInitializers():回调之前保存的所有的ApplicationContextInitializer的initialize方法</span><br><span class="line">         // 还要回调SpringApplicationListeners的ContextPrepared()</span><br><span class="line">         this.prepareContext(context, environment, listeners, applicationArguments, printedBanner);</span><br><span class="line">         // this.prepareContext完成之后，回调所有的SpringApplicationRunListener的contextLoaded();</span><br><span class="line">         // 刷新容器，IOC容器初始化，扫描配置类，扫描@Bean，如果是web应用，还会创建嵌入式的web</span><br><span class="line">         // 扫描、创建、加载所有所有组件的地方；（配置类，组件，自动配置)</span><br><span class="line">         this.refreshContext(context);</span><br><span class="line">         // 从IOC容器中获取所有的ApplicationRunner和CommandLineRunner进行回调</span><br><span class="line">         // ApplicationRunner先回调，CommandLineRunner再回调</span><br><span class="line">         this.afterRefresh(context, applicationArguments);</span><br><span class="line">         stopWatch.stop();</span><br><span class="line">         if (this.logStartupInfo) &#123;</span><br><span class="line">             (new StartupInfoLogger(this.mainApplicationClass)).logStarted(this.getApplicationLog(), stopWatch);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">// SpringBoot启动完成</span><br><span class="line">         listeners.started(context);</span><br><span class="line">         this.callRunners(context, applicationArguments);</span><br><span class="line">     &#125; catch (Throwable var10) &#123;</span><br><span class="line">         this.handleRunFailure(context, var10, exceptionReporters, listeners);</span><br><span class="line">         throw new IllegalStateException(var10);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     try &#123;</span><br><span class="line">         listeners.running(context);</span><br><span class="line">         return context;</span><br><span class="line">     &#125; catch (Throwable var9) &#123;</span><br><span class="line">         this.handleRunFailure(context, var9, exceptionReporters, (SpringApplicationRunListeners)null);</span><br><span class="line">         throw new IllegalStateException(var9);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="事件监听机制相关测试"><a href="#事件监听机制相关测试" class="headerlink" title="事件监听机制相关测试"></a>事件监听机制相关测试</h2><p>配置在META-INF/spring.factories中</p><ul><li><strong>ApplicationContextinitializer</strong></li><li><strong>SpringApplicationRunListener</strong></li></ul><p>只需要放在IOC容器中</p><ul><li>ApplicationRunner</li><li>CommandLineRunner</li></ul><p>编写相关测试类，验证从源码中看到的启动顺序</p><p>(1)编写HelloApplicationContextInitializer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.autostart.listener;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationContextInitializer;</span><br><span class="line">import org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line"></span><br><span class="line">public class HelloApplicationContextInitializer</span><br><span class="line">        implements ApplicationContextInitializer&lt;ConfigurableApplicationContext&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void initialize(ConfigurableApplicationContext configurableApplicationContext) &#123;</span><br><span class="line"></span><br><span class="line">        System.out.println(&quot;HelloApplicationContextInitializer...initialize...&quot; + configurableApplicationContext);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(2)编写HelloSpringApplicationRunListener</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.autostart.listener;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.SpringApplicationRunListener;</span><br><span class="line">import org.springframework.context.ApplicationContextInitializer;</span><br><span class="line">import org.springframework.context.ConfigurableApplicationContext;</span><br><span class="line">import org.springframework.core.env.ConfigurableEnvironment;</span><br><span class="line"></span><br><span class="line">public class HelloApplicationRunListener</span><br><span class="line">        implements SpringApplicationRunListener &#123;</span><br><span class="line"></span><br><span class="line">    public HelloApplicationRunListener(SpringApplication application, String[] args)&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void starting() &#123;</span><br><span class="line">        System.out.println(&quot;SpringApplicationRunListener...starting...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void environmentPrepared(ConfigurableEnvironment environment) &#123;</span><br><span class="line">        Object o = environment.getSystemProperties().get(&quot;os..name&quot;);</span><br><span class="line">        System.out.println(&quot;SpringApplicationRunListener...environmentPrepared...&quot; + o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextPrepared(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;SpringApplicationRunListener...contextPrepared...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void contextLoaded(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;SpringApplicationRunListener...contextLoaded...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void started(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;SpringApplicationRunListener...started...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void running(ConfigurableApplicationContext context) &#123;</span><br><span class="line">        System.out.println(&quot;SpringApplicationRunListener...running...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void failed(ConfigurableApplicationContext context, Throwable exception) &#123;</span><br><span class="line">        System.out.println(&quot;SpringApplicationRunListener...failed...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(3)编写HelloApplicationRunner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.autostart.listener;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.ApplicationArguments;</span><br><span class="line">import org.springframework.boot.ApplicationRunner;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class HelloApplicationRunner implements ApplicationRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(ApplicationArguments args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;ApplicationRunner... run....&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(4)编写HelloCommandLineRunner</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.autostart.listener;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.CommandLineRunner;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class HelloCommandLineRunner implements CommandLineRunner &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;HelloCommandLineRunner...run...&quot; + Arrays.asList(args));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在resource文件夹下闯将一个META-INF的文件夹，编写spring.factories文件，将需要在META-INF文件中读取的监听器配置进去</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.usst.autostart.listener.HelloApplicationContextInitializer</span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">com.usst.autostart.listener.HelloApplicationRunListener</span><br></pre></td></tr></table></figure><p>打印台输出的测试结果与预期相符</p><h2 id="自定义starter"><a href="#自定义starter" class="headerlink" title="自定义starter"></a>自定义starter</h2><p>starter：  </p><p>1、这个场景需要使用的依赖是什么？<br>2、如何编写自动配置？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Configuration   // 指定这个类是一个配置类</span><br><span class="line">@ConditionalOnxxx   // 指定条件成立的情况下自动配置类生效</span><br><span class="line">@AutoConfigureAter   // 指定自动配置类的顺序</span><br><span class="line">@Bean   // 给容器中添加组件</span><br><span class="line"></span><br><span class="line">@ConfigurationProperties   // 结合相关xxxProperties类绑定相关配置</span><br><span class="line">@EnableConfigurationProperties    // 让xxxProperties生效加入到容器中</span><br><span class="line"></span><br><span class="line">自动配置类</span><br><span class="line">将需要启动就加载的自动配置类，配置在META-INF/spring.factories下，例如：</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">com.usst.autostart.listener.HelloApplicationContextInitializer</span><br><span class="line"></span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">com.usst.autostart.listener.HelloApplicationRunListener</span><br></pre></td></tr></table></figure><p>3、模式：<br>启动器只用来做依赖导入</p><p>专门写一个自动配置模块；</p><p>启动器依赖自动配置，别人只需要引入启动器（starter）</p><p>命名：-mybatis-spring-boot-starter：自定义启动器名-spring-boot-starter</p><p>创建一个空工程，里面两个模块，starter和starter-autoconfigurer，start中包含了对starter-configurer的引用，别人只需要引用starter即可。</p><p>starter中只有一个pom文件,引入starter-configurer。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.usst.starter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;usst-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--启动器--&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--引入自动配置模块--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.usst.starter&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;usst-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>starter-configurer中来定义自己的starter。</p><p>pom文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.7.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.usst.starter&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;usst-spring-boot-starter-autoconfigurer&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;usst-spring-boot-starter-autoconfigurer&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;!--引入spring-boot-starter：所有starter的基本配置--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>HelloProperties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.starter.usstspringbootstarterautoconfigurer.starter;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line"></span><br><span class="line">@ConfigurationProperties(prefix = &quot;usst.hello&quot;)</span><br><span class="line">public class HelloProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String prefix;</span><br><span class="line"></span><br><span class="line">    private String suffix;</span><br><span class="line"></span><br><span class="line">    public String getPrefix() &#123;</span><br><span class="line">        return prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setPrefix(String prefix) &#123;</span><br><span class="line">        this.prefix = prefix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSuffix() &#123;</span><br><span class="line">        return suffix;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSuffix(String suffix) &#123;</span><br><span class="line">        this.suffix = suffix;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloService文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.starter.usstspringbootstarterautoconfigurer.starter;</span><br><span class="line"></span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    public HelloProperties getHelloProperties() &#123;</span><br><span class="line">        return helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setHelloProperties(HelloProperties helloProperties) &#123;</span><br><span class="line">        this.helloProperties = helloProperties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String sayHelloUsst(String name)&#123;</span><br><span class="line">        return helloProperties.getPrefix() + name + helloProperties.getSuffix();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HelloServiceAutoConfiguration文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.starter.usstspringbootstarterautoconfigurer.starter;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;</span><br><span class="line">import org.springframework.boot.context.properties.EnableConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnWebApplication //web应用才生效</span><br><span class="line">@EnableConfigurationProperties(HelloProperties.class)</span><br><span class="line">public class HelloServiceAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HelloProperties helloProperties;</span><br><span class="line"></span><br><span class="line">    public HelloService helloService()&#123;</span><br><span class="line">        HelloService helloService = new HelloService();</span><br><span class="line">        helloService.setHelloProperties(helloProperties);</span><br><span class="line">        return helloService;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoost启动原理&quot;&gt;&lt;a href=&quot;#SpringBoost启动原理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoost启动原理&quot;&gt;&lt;/a&gt;SpringBoost启动原理&lt;/h1&gt;&lt;h2 id=&quot;创建Application
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="spring boot" scheme="http://blog.letmefly.cc/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot数据访问</title>
    <link href="http://blog.letmefly.cc/2019/08/04/SpringBoot%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/"/>
    <id>http://blog.letmefly.cc/2019/08/04/SpringBoot数据访问/</id>
    <published>2019-08-04T02:15:50.000Z</published>
    <updated>2019-08-08T13:33:59.536Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-数据访问"><a href="#SpringBoot-数据访问" class="headerlink" title="SpringBoot-数据访问"></a>SpringBoot-数据访问</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JDBC、MyBatis、Spring Data JPA</p><p>对于数据访问层，无论是SQL还是NOSQL，SpringBoot默认采用整合Spring Data的方式进行统一处理，添加大量自动配置，屏蔽了很多设置。引入各种XXXTemplate，XXXRepository来简化我们对数据访问层的操作。对我们而言，只需要进行简单的设置即可。</p><ul><li>JDBC</li><li>MyBatis</li><li>JPA</li></ul><h2 id="JDBC-amp-自动配置原理"><a href="#JDBC-amp-自动配置原理" class="headerlink" title="JDBC&amp;自动配置原理"></a>JDBC&amp;自动配置原理</h2><h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://10.211.55.7:3307/jdbc</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure><p>效果：<br>默认使用org.apache.tomcat.jdbc.pool.DataSource作为数据源<br>数据源的相关配置在DataSourceProperties里面</p><p>自动配置原理：<br><code>org/springframework/boot/spring-boot-autoconfigure/2.1.6.RELEASE/spring-boot-autoconfigure-2.1.6.RELEASE.jar!/org/springframework/boot/autoconfigure/jdbc</code></p><ul><li>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</li><li><p>2、SpringBoot默认可以支持<code>spring.datasource.tomcat</code>,<code>spring.datasource.hikari</code>,<br><code>org.apache.commons.dbcp2.BasicDataSource</code></p></li><li><p>3、自定义数据源类型 <code>spring.datasource.type</code></p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Generic DataSource configuration.</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnMissingBean(DataSource.class)</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)</span><br><span class="line">static class Generic &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DataSource dataSource(DataSourceProperties properties) &#123;</span><br><span class="line">// 使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性</span><br><span class="line">return properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>4、DataSourceInitializer：ApplicationListener<br>作用：  <ul><li>runSchemaScripts();运行建表语句；</li><li>runDataScripts();运行插入数据的sql语句  </li></ul></li></ul><p>默认只需要将文件命名为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">schema-\*.sql、data-\*.sql</span><br><span class="line">默认规则：schema-\*.sql、data-\*.sql</span><br><span class="line">可以使用：</span><br><span class="line">    schema: classpath:department.sql</span><br><span class="line">      指定位置</span><br></pre></td></tr></table></figure><p>可以读取sql的配置文件，SpringBoot1.x和2.x还是有些差距的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://10.211.55.7:3307/jdbc</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    schema: classpath:department.sql</span><br><span class="line">    initialization-mode: always</span><br></pre></td></tr></table></figure><h2 id="整合Druid配置数据源监控"><a href="#整合Druid配置数据源监控" class="headerlink" title="整合Druid配置数据源监控"></a>整合Druid配置数据源监控</h2><p>引入Druid</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入Druid--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.1.12&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>修改yml文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://10.211.55.7:3307/jdbc</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    initialization-mode: always</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br></pre></td></tr></table></figure><p>Druid的yml配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://10.211.55.7:3307/jdbc</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    # schema: classpath:department.sql</span><br><span class="line">    # initialization-mode: always</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 数据源配置</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line"> # filters: stat,wall,log4j # log4j没有引入，会引起报错，这里先注掉</span><br><span class="line">    filters: stat,wall</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">    useGlobalDataSourceStat: true</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure><p>Druid的配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot06.config;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line">import com.alibaba.druid.support.http.StatViewServlet;</span><br><span class="line">import com.alibaba.druid.support.http.WebStatFilter;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span><br><span class="line">import org.springframework.boot.web.servlet.ServletRegistrationBean;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">import javax.servlet.Filter;</span><br><span class="line">import javax.sql.DataSource;</span><br><span class="line">import java.util.Arrays;</span><br><span class="line">import java.util.HashMap;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class DruidConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="line">    public DataSource druid()&#123;</span><br><span class="line">        return new DruidDataSource();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 配置Druid监控</span><br><span class="line">    // 1、配置一个管理后台的Servlet</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ServletRegistrationBean statViewServlet() &#123;</span><br><span class="line">        // 这里一开始报错的原因是缺少javax.servlet.http.HttpServlet的类文件，引入servlet-api的jar包即可解决问题</span><br><span class="line">        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">        // 初始化参数</span><br><span class="line">        initParams.put(&quot;loginUsername&quot;, &quot;admin&quot;);</span><br><span class="line">        initParams.put(&quot;loginPassword&quot;, &quot;123456&quot;);</span><br><span class="line">        initParams.put(&quot;allow&quot;, &quot;&quot;); // 默认是允许所有访问</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">    // 2、配置一个监控的filter</span><br><span class="line">    @Bean</span><br><span class="line">    public FilterRegistrationBean webStatFilter()&#123;</span><br><span class="line">        FilterRegistrationBean&lt;Filter&gt; bean = new FilterRegistrationBean&lt;&gt;();</span><br><span class="line">        bean.setFilter(new WebStatFilter());</span><br><span class="line"></span><br><span class="line">        Map&lt;String, String&gt; initParams = new HashMap&lt;&gt;();</span><br><span class="line">        initParams.put(&quot;exclusions&quot;, &quot;*.js, *.css, /druid/*&quot;);</span><br><span class="line"></span><br><span class="line">        bean.setInitParameters(initParams);</span><br><span class="line"></span><br><span class="line">        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));</span><br><span class="line"></span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可惜这个Druid监控页面无法访问。</p><p>以后有机会要再搞搞</p><p>修改之后可以访问Druid监控了</p><p>更改了jar包，增加了一个web的依赖，不知道和webflux会不会有依赖，目前运行正常，如果有错误再进行更改，修改后的pom文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line">    &lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;2.1.4.RELEASE&lt;/version&gt;</span><br><span class="line">        &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br><span class="line">    &lt;groupId&gt;com.usst&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springboot06&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;name&gt;springboot06&lt;/name&gt;</span><br><span class="line">    &lt;description&gt;Demo project for Spring Boot&lt;/description&gt;</span><br><span class="line"></span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;java.version&gt;1.8&lt;/java.version&gt;</span><br><span class="line">    &lt;/properties&gt;</span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;javax.servlet&lt;/groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;scope&gt;provided&lt;/scope&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;/dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--引入Druid--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.1.8&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;/dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-webflux&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;/dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;!--&lt;version&gt;5.1.34&lt;/version&gt;--&gt;</span><br><span class="line">            &lt;scope&gt;runtime&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;</span><br><span class="line">            &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;io.projectreactor&lt;/groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;reactor-test&lt;/artifactId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;scope&gt;test&lt;/scope&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;/dependency&gt;--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot&lt;/artifactId&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;!--&lt;dependency&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;groupId&gt;org.mybatis&lt;/groupId&gt;--&gt;</span><br><span class="line">            &lt;!--&lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;--&gt;</span><br><span class="line">        &lt;!--&lt;/dependency&gt;--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">    &lt;build&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/build&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure><p>对比web的依赖和webflux的依赖发现，他们引入的依赖有些重合，有些地方又不一样，但是web引入了mvc的依赖而webflux没有，感觉应该是druid依赖mvc才能够正常使用。</p><h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>引入MyBatis的依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p><img src="/2019/08/04/SpringBoot数据访问/MyBatis引入的依赖.jpg" alt="MyBatis引入的依赖"></p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>1、配置数据源相关属性，这里我们选择的是Druid</li><li>2、数据库建表<br>yml配置文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line">    url: jdbc:mysql://10.211.55.7:3307/jdbc</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    schema: classpath:sql/department.sql,classpath:sql/employee.sql</span><br><span class="line">    initialization-mode: always</span><br><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 数据源配置</span><br><span class="line">    initialSize: 5</span><br><span class="line">    minIdle: 5</span><br><span class="line">    maxActive: 20</span><br><span class="line">    maxWait: 60000</span><br><span class="line">    timeBetweenEvictionRunsMillis: 60000</span><br><span class="line">    minEvictableIdleTimeMillis: 300000</span><br><span class="line">    validationQuery: SELECT 1 FROM DUAL</span><br><span class="line">    testWhileIdle: true</span><br><span class="line">    testOnBorrow: false</span><br><span class="line">    testOnReturn: false</span><br><span class="line">    poolPreparedStatements: true</span><br><span class="line">#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&apos;wall&apos;用于防火墙</span><br><span class="line">    filters: stat,wall</span><br><span class="line">    maxPoolPreparedStatementPerConnectionSize: 20</span><br><span class="line">    useGlobalDataSourceStat: true</span><br><span class="line">    connectionProperties: druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br></pre></td></tr></table></figure><ul><li>3、创建JavaBean</li></ul><h3 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h3><p>只需要一个接口即可完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot06.mapper;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot06.bean.Department;</span><br><span class="line">import org.apache.ibatis.annotations.*;</span><br><span class="line"></span><br><span class="line">// 指定这是一个操作数据库的Mapper</span><br><span class="line">@Mapper</span><br><span class="line">public interface DepartmentMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select * from department where id=#&#123;id&#125;&quot;)</span><br><span class="line">    public Department getDeptById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from department where id=#&#123;id&#125;&quot;)</span><br><span class="line">    public int deleteDeptById(Integer id);</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;)</span><br><span class="line">    @Options(useGeneratedKeys = true, keyProperty = &quot;id&quot;, keyColumn = &quot;id&quot;)</span><br><span class="line">    public int insertDept(Department department);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update department set departmentName=#&#123;department&#125; where id=#&#123;id&#125;&quot;)</span><br><span class="line">    public int updateDept(Department department);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题：当数据表中的字段和JavaBean的字段不同的时候，无法完成映射</p><p>需要：自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot06.config;</span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.session.Configuration;</span><br><span class="line">import org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line">// 开启驼峰命名的方式，自定义MyBatis的配置规则</span><br><span class="line">@org.springframework.context.annotation.Configuration</span><br><span class="line">public class MyBatisConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public ConfigurationCustomizer configurationCustomizer()&#123;</span><br><span class="line">        return new ConfigurationCustomizer()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void customize(Configuration configuration) &#123;</span><br><span class="line">                configuration.setMapUnderscoreToCamelCase(true);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用MapperScan批量扫描所有的Mapper接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot06;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import org.apache.ibatis.annotations.Mapper;</span><br><span class="line">import org.mybatis.spring.annotation.MapperScan;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@MapperScan(value = &quot;com.usst.springboot06.mapper&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Springboot06Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Springboot06Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置版"><a href="#配置版" class="headerlink" title="配置版"></a>配置版</h3><p>修改yml文件，增加mybatis配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mybatis:</span><br><span class="line">  config-location: classpath:mybatis/mybatis-config.xml</span><br><span class="line">  mapper-locations: classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure><p><strong>注意：文件的名称必须以.xml结尾</strong><br>增加两个配置文件分别是mybatis-config.xml和EmployeeMapper.xml。<br>mybatis-config.xml文件中的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置驼峰命名法,解决bean和数据表字段不匹配的问题--&gt;</span><br><span class="line">    &lt;settings&gt;</span><br><span class="line">        &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;</span><br><span class="line">    &lt;/settings&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>EmployeeMapper.xml文件的配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.usst.springboot06.mapper.EmployeeMapper&quot;&gt;</span><br><span class="line">   &lt;!--    public Employee getEmpById(Integer id);</span><br><span class="line"></span><br><span class="line">    public void insertEmp(Employee employee);--&gt;</span><br><span class="line">    &lt;select id=&quot;getEmpById&quot; resultType=&quot;com.usst.springboot06.bean.Employee&quot;&gt;</span><br><span class="line">        SELECT * FROM employee WHERE id=#&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;insertEmp&quot;&gt;</span><br><span class="line">        INSERT INTO employee(lastName,email,gender,d_id) VALUES (#&#123;lastName&#125;,#&#123;email&#125;,#&#123;gender&#125;,#&#123;dId&#125;)</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure><p>编写Controller和Mapper</p><h2 id="SpringData-JPA简介"><a href="#SpringData-JPA简介" class="headerlink" title="SpringData JPA简介"></a>SpringData JPA简介</h2><h3 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h3><p>Java Persistence API（JPA）</p><p>Spring Data 项目的目的是为了简化构建基于 Spring 框架应用的数据访问技术，包括非关系数据库、 Map-Reduce 框架、云数据服务等等;另外也包含对关系数据库的访问支持。</p><p>Spring Data 包含多个子项目:  </p><ul><li>Spring Data Commons</li><li>Spring Data JPA</li><li>Spring Data KeyValue</li><li>Spring Data LDAP</li><li>Spring Data MongoDB</li><li>Spring Data Gemfire</li><li>Spring Data REST</li><li>Spring Data Redis</li><li>Spring Data for Apache Cassandra</li><li>Spring Data for Apache Solr</li><li>Spring Data Couchbase (community module)</li><li>Spring Data Elasticsearch (community module)</li><li>Spring Data Neo4j (community module)</li></ul><p><img src="/2019/08/04/SpringBoot数据访问/SpringDataJPA.jpg" alt="SpringDataJPA"></p><h4 id="SpringData特点"><a href="#SpringData特点" class="headerlink" title="SpringData特点"></a>SpringData特点</h4><p>SpringData为我们提供使用统一的API来对数据访问层进行操作;这主要是Spring Data Commons项目来实现的。Spring Data Commons让我们在使用关系型或者非关系型数据访问 技术时都基于Spring提供的统一标准，标准包含了CRUD(创建、获取、更新、删除)、查询、 排序和分页的相关操作。</p><h4 id="统一的Repository接口"><a href="#统一的Repository接口" class="headerlink" title="统一的Repository接口"></a>统一的Repository接口</h4><p>Repository&lt;T, ID extends Serializable&gt;:统一接口<br>RevisionRepository&lt;T, ID extends Serializable, N extends Number &amp; Comparable<n>&gt;:基于乐观 锁机制<br>CrudRepository&lt;T, ID extends Serializable&gt;:基本CRUD操作 PagingAndSortingRepository&lt;T, ID extends Serializable&gt;:基本CRUD及分页</n></p><h3 id="整合SpringData-JPA"><a href="#整合SpringData-JPA" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h3><p>JPA：ORM（Object Relational Mapping）：<br>（1）编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot06.entity;</span><br><span class="line"></span><br><span class="line">import javax.persistence.*;</span><br><span class="line"></span><br><span class="line">// 使用JPA注解配置映射关系</span><br><span class="line">@Entity //告诉JPA这是一个实体类，和数据表映射的类</span><br><span class="line">@Table(name = &quot;tbl_user&quot;) // @Table指定和哪个表对应，如果省略，默认表名就是user；</span><br><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    @Id //这是一个主键</span><br><span class="line">    @GeneratedValue(strategy = GenerationType.IDENTITY)</span><br><span class="line">    private Integer id;</span><br><span class="line">    </span><br><span class="line">    @Column(name = &quot;last_name&quot;,length = 50) // 这是和数据表对应的一个列</span><br><span class="line">    private String lastName;</span><br><span class="line">    </span><br><span class="line">    @Column //省略默认列名就是属性名</span><br><span class="line">    private String email;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getEmail() &#123;</span><br><span class="line">        return email;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setEmail(String email) &#123;</span><br><span class="line">        this.email = email;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）编写一个Dao接口来操作实体类对应的数据表（Repository）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot06.repository;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot06.entity.User;</span><br><span class="line">import org.springframework.data.jpa.repository.JpaRepository;</span><br><span class="line"></span><br><span class="line">// 两个泛型，第一个表示传递的实体类，第二个表示实体类的主键类型</span><br><span class="line">// 继承JpaRepository来完成对数据库的操作</span><br><span class="line">public interface UserRepository extends JpaRepository&lt;User, Integer&gt; &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（3）基本的配置jpaProperties, yml文件中与jpa相关的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">#    更新或者创建数据表结构</span><br><span class="line">      ddl-auto: update</span><br><span class="line">#    在控制台显示sql</span><br><span class="line">    show-sql: true</span><br></pre></td></tr></table></figure><p>（4）编写Controller</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot06.controller;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot06.entity.User;</span><br><span class="line">import com.usst.springboot06.repository.UserRepository;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.PathVariable;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">import java.util.Optional;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class UserController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    UserRepository userRepository;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/user/&#123;id&#125;&quot;)</span><br><span class="line">    public Optional&lt;User&gt; getUser(@PathVariable(&quot;id&quot;) Integer id)&#123;</span><br><span class="line">        Optional&lt;User&gt; user = userRepository.findById(id);</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/user&quot;)</span><br><span class="line">    public User inserUser(User user)&#123;</span><br><span class="line">        User save = userRepository.save(user);</span><br><span class="line">        return save;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot-数据访问&quot;&gt;&lt;a href=&quot;#SpringBoot-数据访问&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot-数据访问&quot;&gt;&lt;/a&gt;SpringBoot-数据访问&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="database" scheme="http://blog.letmefly.cc/tags/database/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot-Docker</title>
    <link href="http://blog.letmefly.cc/2019/08/02/SpringBoot-Docker/"/>
    <id>http://blog.letmefly.cc/2019/08/02/SpringBoot-Docker/</id>
    <published>2019-08-02T12:23:49.000Z</published>
    <updated>2019-08-04T02:10:10.303Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-Docker"><a href="#SpringBoot-Docker" class="headerlink" title="SpringBoot-Docker"></a>SpringBoot-Docker</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker是一个开源的应用容器引擎；（轻量级容器技术，实现了虚拟机技术中的资源隔离，性能高于虚拟机）</p><p>Docker支持将软件编译成一个镜像；然后在镜像中各种软件做好配置，将镜像发布出去，其他使用者可以直接使用这个镜像；</p><p>运行中的这个镜像就被称为容器，容器的启动是非常快速的。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>docker主机（Host）：安装了Docker程序的机器（Docker直接安装在操作系统之上）；  </li><li>docker客户端（Client）：连接docker主机进行操作；客户端通过命令行或者其他工具使用Docker</li><li>docker仓库（Registry）：用来保存各种打包好的软件镜像；公共仓库：Docker Hub（<a href="https://hub.docker.com）提供了庞大的镜像集合供使用；也可以搭建自己的私有仓库；" target="_blank" rel="noopener">https://hub.docker.com）提供了庞大的镜像集合供使用；也可以搭建自己的私有仓库；</a></li><li>docker镜像（Images）：软件打包好的镜像，放在docker仓库中；用于创建Docker容器的模板</li><li>docker容器（Container）:镜像启动之后的实例称为一个容器；容器是独立运行的一个或一组应用</li></ul><h3 id="使用Docker的步骤"><a href="#使用Docker的步骤" class="headerlink" title="使用Docker的步骤"></a>使用Docker的步骤</h3><ul><li>1、安装Docker</li><li>2、去Docker仓库找个这个软件对应的镜像</li><li>3、使用Docker运行这个镜像，这个镜像会生成一个Docker容器；</li><li>4、对容器的启动、停止就是对软件的启动停止</li></ul><h2 id="linux环境准备"><a href="#linux环境准备" class="headerlink" title="linux环境准备"></a>linux环境准备</h2><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><h4 id="1、安装linux虚拟机"><a href="#1、安装linux虚拟机" class="headerlink" title="1、安装linux虚拟机"></a>1、安装linux虚拟机</h4><ul><li>（1）VMWare、Virtualbox、Parallels Desktop，任选一个安装</li><li>（2）导入虚拟机文件</li><li>（3）启动linux虚拟机；使用账号密码登录</li><li>（4）使用linux客户端连接linux服务器进行命令操作</li><li><p>（5）设置虚拟机网络<br>桥接网络===选好网卡===连入网线  </p></li><li><p>（6）设置好网络以后，使用命令重启虚拟机网络<code>service network restart</code>(CentOS7重启的命令)</p></li><li>（7）查看linux的IP地址<code>ip addr</code></li><li>（8）使用客户端连接</li></ul><h2 id="docker启动-amp-安装-amp-停止"><a href="#docker启动-amp-安装-amp-停止" class="headerlink" title="docker启动&amp;安装&amp;停止"></a>docker启动&amp;安装&amp;停止</h2><h3 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h3><h4 id="1、查看centOS版本"><a href="#1、查看centOS版本" class="headerlink" title="1、查看centOS版本"></a>1、查看centOS版本</h4><p><code>uname -r</code><br>Docker要求CentOS系统的内核版本高于3.10</p><h4 id="2、升级软件包及内核（选做）"><a href="#2、升级软件包及内核（选做）" class="headerlink" title="2、升级软件包及内核（选做）"></a>2、升级软件包及内核（选做）</h4><p><code>yum update</code><br>如果CentOS内核的版本低于3.10，执行上述指令</p><h4 id="3、安装docker"><a href="#3、安装docker" class="headerlink" title="3、安装docker"></a>3、安装docker</h4><p><code>yum install docker</code>  </p><h4 id="4、启动docker"><a href="#4、启动docker" class="headerlink" title="4、启动docker"></a>4、启动docker</h4><p><code>systemctl start docker</code>  </p><h4 id="5、将docker服务设为开机启动"><a href="#5、将docker服务设为开机启动" class="headerlink" title="5、将docker服务设为开机启动"></a>5、将docker服务设为开机启动</h4><p><code>systemctl enable docker</code></p><h4 id="6、停止docker"><a href="#6、停止docker" class="headerlink" title="6、停止docker"></a>6、停止docker</h4><p><code>systemctl stop docker</code></p><p>这里只是说了下主要步骤，我有一篇博客专门讲了CentOS7下搭建docker，详细可参看该博客：<a href="https://lingluochengfeng.github.io/2019/06/22/centos%E6%90%AD%E5%BB%BAdocker/#more" target="_blank" rel="noopener">centos搭建docker</a></p><h2 id="docker镜像操作常用命令"><a href="#docker镜像操作常用命令" class="headerlink" title="docker镜像操作常用命令"></a>docker镜像操作常用命令</h2><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><h4 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h4><p><code>docker search mysql</code></p><h4 id="拉取"><a href="#拉取" class="headerlink" title="拉取"></a>拉取</h4><p><code>docker pull 镜像名:tag</code>,tag是指定镜像的版本，可以去Docker Hub上看</p><h4 id="查看所有镜像"><a href="#查看所有镜像" class="headerlink" title="查看所有镜像"></a>查看所有镜像</h4><p><code>docker images</code></p><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><code>docker rmi IMAGE ID</code></p><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><p>软件镜像 — 运行镜像 — 产生一个容器(正在运行的软件)；</p><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">1、搜索镜像</span><br><span class="line">[gaojie@centos-linux ~]$ sudo docker search tomcat</span><br><span class="line">2、拉取镜像</span><br><span class="line">[gaojie@centos-linux ~]$ sudo docker pull tomcat</span><br><span class="line">3、根据镜像启动容器</span><br><span class="line">[gaojie@centos-linux ~]$ sudo docker run --name mytomcat -d tomcat:latest</span><br><span class="line"></span><br><span class="line">命令：docker run --name 自己起的容器名 -d image-name(容器名字)  </span><br><span class="line">     说明：--name：自定义容器名 </span><br><span class="line">          -d：后台运行</span><br><span class="line">          image-name：指定镜像模板</span><br><span class="line">          </span><br><span class="line">4、使用docker ps 查看运行中的容器</span><br><span class="line">5、停止运行中的容器</span><br><span class="line">[gaojie@centos-linux ~]$ sudo docker stop 7a7bd6b5c9bd(容器ID)</span><br><span class="line">6、查看所有容器</span><br><span class="line">docker ps -a</span><br><span class="line">7、启动容器</span><br><span class="line">docker start 容器ID</span><br><span class="line">8、删除一个容器（必须是停止状态）</span><br><span class="line">docker rm 容器ID</span><br><span class="line">9、启动一个做了端口映射的tomcat</span><br><span class="line"> docker run --name mytomcat -d -p 8888:8080 tomcat:latest</span><br><span class="line"> 注：-p：将主机的端口映射到容器的一个端口  主机端口：容器内部端口</span><br><span class="line">10、使用http://10.211.55.7:8888/ 即可访问</span><br><span class="line">11、有时可能需要关闭防火墙</span><br><span class="line">service firewalld status:查看防火墙状态</span><br><span class="line">service firewalld stop:关闭防火墙</span><br><span class="line">12、查看容器的日志</span><br><span class="line">docker logs 容器ID</span><br><span class="line"></span><br><span class="line">更多命令：https://docs.docker.com/engine/reference/commandline/docker/</span><br><span class="line"></span><br><span class="line">每个镜像可以启动多个容器，而且每个容器都是独立的，互不干扰</span><br></pre></td></tr></table></figure><p>可以参考每个镜像的文档</p><p>注意：<br>centos 7 docker 启动映射端口的tomcat服务时报</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WARNING: IPv4 forwarding is disabled. Networking will not work.</span><br></pre></td></tr></table></figure><p>网上查询了下 需要做如下配置</p><p><strong>解决办法</strong>：  </p><p>修改sysctl.conf文件</p><p><code>vi /etc/sysctl.conf</code></p><p>添加如下代码：</p><p><code>net.ipv4.ip_forward=1</code></p><p>重启network服务</p><p><code>systemctl restart network</code></p><p>查看是否修改成功</p><p><code>sysctl net.ipv4.ip_forward</code></p><p>如果返回为“net.ipv4.ip_forward = 1”则表示成功了</p><h2 id="docker安装MySQL"><a href="#docker安装MySQL" class="headerlink" title="docker安装MySQL"></a>docker安装MySQL</h2><p>1：mac的terminal下运行命令<br><code>docker pull mysql</code> 默认拉取的是最新版本的mysql<br><code>docke pull mysql:5.6</code> 拉取mysql 5.6的版本</p><p>查看镜像 <code>docker images</code>,<code>docker images | grep mysql</code></p><p>2：启动<br>2.1: 基本启动（缺点，容器关闭后，数据消失）,<font color="red">自己试了下，似乎关闭容器后，数据也不会消失</font><br><code>docker run --name=mysql -it -p 3306:3306 -e MYSQL_ROOT_PASSWORD=emc123123 -d mysql</code> </p><ul><li>–name： 给容器取名字为mysql</li><li>-it： 一个在后台执行的容器，同时，还能用控制台管理</li><li>-p：端口1:端口2，端口1是对外暴露的端口（即你用sqlYog连接的端口），端口2 使我们的mysql端口</li><li>-e：表示配置环境<ul><li>MYSQL_ROOT_PASSWORD=密码   即root用户的密码</li></ul></li><li>-d:表示在后台执行容器</li></ul><font color="blue">2.2：高级启动（容器关闭再启动我们的数据不会消失），一般我们选择用这个启动<br><code>docker run --name=mysql -it -p 3306:3306 -v /mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql</code><br><br>-  -v /mysql/data:/var/lib/mysql   代表将宿主机/mysql/data  挂载到 mysql容器的/var/lib/mysql<br>-  /mysql/data 这个目录是我们虚拟机的地址，不用建，启动成功自动生成<br>-  为什么是/var/lib/mysql是这个地址呢？   我只能官网文档中是这样写的，有兴趣可以看看docker hub官网<br><br>暂时保留</font><font color="green">官方指定的启动方式：<code>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code><br>-e:表示携带的参数  这个也不能正常使用。。<br>用这个：<code>docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql</code><br>上面两种也可以正常使用<br><br>可以使用客户端进行远程连接<br><br>高级操作：<code>docker run --name mysql03 -v /my/custom:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</code> 把主机的/my/custom文件夹挂在到mysqldocker容器的/etc/mysql/conf.d文件夹里面，改mysql的配置文件就只需要把mysql配置文件放在主机文件夹下即可<br><code>docker run -p 3306:3306 --name mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci</code><br></font><p>3:使用<code>docker ps -a</code>,<code>docker ps -s</code>查看是否成功启动mysql</p><p>4：之后输入<code>docker exec -it mysql bash</code>进入容器bash，bash的作用是进入容器的终端，可以敲一些shell命令</p><p>5:接着输入mysql -uroot -p进入mysql，之后输入<code>show databases;</code>查看数据库(进入mysql之后所有指令结尾都需要)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot-Docker&quot;&gt;&lt;a href=&quot;#SpringBoot-Docker&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot-Docker&quot;&gt;&lt;/a&gt;SpringBoot-Docker&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="docker" scheme="http://blog.letmefly.cc/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式</title>
    <link href="http://blog.letmefly.cc/2019/07/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://blog.letmefly.cc/2019/07/21/设计模式-单例模式/</id>
    <published>2019-07-21T14:36:36.000Z</published>
    <updated>2019-07-21T14:53:43.961Z</updated>
    
    <content type="html"><![CDATA[<h1 id="单例模式简介"><a href="#单例模式简介" class="headerlink" title="单例模式简介"></a>单例模式简介</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>单例模式是确保一个类，并且该实例必须自动创建，并向整个系统提供该实例。  </p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>单例模式可以分为饿汉单例模式和懒汉单例模式，饿汉单例模式在类初始化时就已经创建了自身的对象，而懒汉单例模式则是在需要使用的时候才创建自身的对象。</p><h3 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">private static final Singleton instance = new Singleton();</span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h3><p>代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Singleton&#123;</span><br><span class="line">private static Singleton instance = null;</span><br><span class="line"></span><br><span class="line">private Singleton()&#123;&#125;</span><br><span class="line"></span><br><span class="line">public static Singleton getInstance()&#123;</span><br><span class="line">if(instance == null)&#123;</span><br><span class="line">instance = new Singleton();</span><br><span class="line">&#125;</span><br><span class="line">return instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当系统要求一个类只有一个实例时，可以使用单例模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;单例模式简介&quot;&gt;&lt;a href=&quot;#单例模式简介&quot; class=&quot;headerlink&quot; title=&quot;单例模式简介&quot;&gt;&lt;/a&gt;单例模式简介&lt;/h1&gt;&lt;h2 id=&quot;定义&quot;&gt;&lt;a href=&quot;#定义&quot; class=&quot;headerlink&quot; title=&quot;定义&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="单例模式" scheme="http://blog.letmefly.cc/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot与Web开发</title>
    <link href="http://blog.letmefly.cc/2019/07/15/Spring-Boot%E4%B8%8EWeb%E5%BC%80%E5%8F%91/"/>
    <id>http://blog.letmefly.cc/2019/07/15/Spring-Boot与Web开发/</id>
    <published>2019-07-15T14:35:02.000Z</published>
    <updated>2019-08-10T12:16:35.521Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-web开发"><a href="#SpringBoot-web开发" class="headerlink" title="SpringBoot-web开发"></a>SpringBoot-web开发</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="使用Spring-Boot"><a href="#使用Spring-Boot" class="headerlink" title="使用Spring Boot"></a>使用Spring Boot</h3><ul><li>1：创建SpringBoot应用，选择我们需要的模块</li><li>2：SpringBoot已经默认将这些场景配置好了，只需要在配置文件中指定就可以运行起来</li><li>3：自己编写业务代码</li></ul><p><strong>自动配置原理？</strong><br>这个场景SpringBoot帮我们配置了什么？能不能修改？能修改哪些配置？如何扩展？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xxxAutoConfiguration // 帮我们给容器中自动配置组件</span><br><span class="line"></span><br><span class="line">xxxProperties // 配置类中来封装配置文件的内容</span><br></pre></td></tr></table></figure><h2 id="Spring-Boot对静态资源的映射规则"><a href="#Spring-Boot对静态资源的映射规则" class="headerlink" title="Spring Boot对静态资源的映射规则"></a>Spring Boot对静态资源的映射规则</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--可以设置跟资源有关的参数，缓存时间等--&gt;</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.resources&quot;, ignoreUnknownFields = false)</span><br><span class="line">public class ResourceProperties &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">if (!this.resourceProperties.isAddMappings()) &#123;</span><br><span class="line">logger.debug(&quot;Default resource handling disabled&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">Duration cachePeriod = this.resourceProperties.getCache().getPeriod();</span><br><span class="line">CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl();</span><br><span class="line">if (!registry.hasMappingForPattern(&quot;/webjars/**&quot;)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">.addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;)</span><br><span class="line">.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br><span class="line">String staticPathPattern = this.mvcProperties.getStaticPathPattern();</span><br><span class="line">if (!registry.hasMappingForPattern(staticPathPattern)) &#123;</span><br><span class="line">customizeResourceHandlerRegistration(registry.addResourceHandler(staticPathPattern)</span><br><span class="line">.addResourceLocations(getResourceLocations(this.resourceProperties.getStaticLocations()))</span><br><span class="line">.setCachePeriod(getSeconds(cachePeriod)).setCacheControl(cacheControl));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--配置欢迎页映射--&gt;</span><br><span class="line">@Bean</span><br><span class="line">public WelcomePageHandlerMapping welcomePageHandlerMapping(ApplicationContext applicationContext) &#123;</span><br><span class="line">return new WelcomePageHandlerMapping(new TemplateAvailabilityProviders(applicationContext),</span><br><span class="line">applicationContext, getWelcomePage(), this.mvcProperties.getStaticPathPattern());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--映射自己的图片--&gt;</span><br><span class="line">@Bean</span><br><span class="line">public SimpleUrlHandlerMapping faviconHandlerMapping() &#123;</span><br><span class="line">SimpleUrlHandlerMapping mapping = new SimpleUrlHandlerMapping();</span><br><span class="line">mapping.setOrder(Ordered.HIGHEST_PRECEDENCE + 1);</span><br><span class="line">mapping.setUrlMap(Collections.singletonMap(&quot;**/favicon.ico&quot;, faviconRequestHandler()));</span><br><span class="line">return mapping;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>1、所有/webjars/**:都去classpath:/META-INF/resources/webjars/找资源，以jar包的方式引入静态资源<br><img src="/2019/07/15/Spring-Boot与Web开发/引入webjars的目录.jpg" alt="引入webjars的目录"><br>访问路径为：localhost:8080/webjars/jquery/3.3.1/jquery.js</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入jquery的webjar--&gt;</span><br><span class="line">&lt;!--在访问的时候只需要写webjars下面资源的名称即可--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.webjars&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jquery&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><ul><li>2、“/**”表示访问当前项目的任何资源</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--classpath:指的是resource路径下的内容：--&gt;</span><br><span class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;,</span><br><span class="line">&quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Locations of static resources. Defaults to classpath:[/META-INF/resources/,</span><br><span class="line"> * /resources/, /static/, /public/].</span><br><span class="line"> */</span><br><span class="line">private String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;</span><br></pre></td></tr></table></figure><p>访问路径:localhost:8080/abc ====&gt;去静态资源资源文件夹里面找abc</p><ul><li><p>3、静态资源文件夹下的所有index.html页面；被/**映射<br>localhost:8080 即可访问</p></li><li><p>4、所有的**/favicon.ico都是在静态资源文件下找；</p></li></ul><h2 id="引入Thymeleaf"><a href="#引入Thymeleaf" class="headerlink" title="引入Thymeleaf"></a>引入Thymeleaf</h2><h3 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h3><p>JSP、Velocity、FreeMarker、Thymeleaf</p><h4 id="1、引入Thymeleaf"><a href="#1、引入Thymeleaf" class="headerlink" title="1、引入Thymeleaf"></a>1、引入Thymeleaf</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--引入Thymeleaf--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--更改SpringBoot提供的depency的默认依赖--&gt;</span><br><span class="line">&lt;properties&gt;</span><br><span class="line">&lt;!--布局功能的支持程序，thymeleaf3主程序，layout2以上版本--&gt;</span><br><span class="line">&lt;thymeleaf.version&gt;3.0.9.RELEASE&lt;/thymeleaf.version&gt;</span><br><span class="line">&lt;thymeleaf-layout-dialect.version&gt;2.2.2&lt;/thymeleaf-layout-dialect.version&gt;</span><br><span class="line">&lt;/properties&gt;</span><br></pre></td></tr></table></figure><p>Thymeleaf语法</p><h3 id="2、Thymeleaf使用-amp-语法"><a href="#2、Thymeleaf使用-amp-语法" class="headerlink" title="2、Thymeleaf使用&amp;语法"></a>2、Thymeleaf使用&amp;语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.thymeleaf&quot;)</span><br><span class="line">public class ThymeleafProperties &#123;</span><br><span class="line"></span><br><span class="line">private static final Charset DEFAULT_ENCODING = StandardCharsets.UTF_8;</span><br><span class="line"></span><br><span class="line">public static final String DEFAULT_PREFIX = &quot;classpath:/templates/&quot;;</span><br><span class="line"></span><br><span class="line">public static final String DEFAULT_SUFFIX = &quot;.html&quot;;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要我们把HTML页面放在classpath:/templates/, thymeleaf就能自动渲染；</p><p>使用：  </p><ul><li><p>1：导入thymeleaf的名称空间<br><code>&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</code></p></li><li><p>2：使用thymeleaf语法  </p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;请求发送成功&lt;/h1&gt;</span><br><span class="line">    &lt;!--th:text, 将div里面的文本内容设置为--&gt;</span><br><span class="line">    &lt;div th:text=&quot;$&#123;hello&#125;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="3、语法规则"><a href="#3、语法规则" class="headerlink" title="3、语法规则"></a>3、语法规则</h3><p>（1）、th:text：改变当前元素里面的文本内容<br>    th:任意hetml属性，替换原生属性的值<br>    <img src="/2019/07/15/Spring-Boot与Web开发/thymeleaf语法1.png" alt="thymeleaf语法"><br>（2）、表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">Simple expressions:(表达式语法)</span><br><span class="line">VariableExpressions: $&#123;...&#125; ;获取变量值：OGNL</span><br><span class="line">1）、获取对象属性，调用方法</span><br><span class="line">2）、使用内置的基本对象</span><br><span class="line">#ctx : the context object.  </span><br><span class="line">#vars: the context variables.</span><br><span class="line">#locale : the context locale.</span><br><span class="line">#request : (only in Web Contexts) the HttpServletRequest object. </span><br><span class="line">#response : (only in Web Contexts) the HttpServletResponse object. </span><br><span class="line">#session : (only in Web Contexts) the HttpSession object. </span><br><span class="line">#servletContext : (only in Web Contexts) the ServletContext object.  </span><br><span class="line">3)、内置的工具对象</span><br><span class="line">#execInfo : information about the template being processed.</span><br><span class="line">#messages : methods for obtaining externalized messages inside variables expressions, in the same way as they would be obtained using #&#123;...&#125; syntax.</span><br><span class="line">#uris : methods for escaping parts of URLs/URIs</span><br><span class="line">#conversions : methods for executing the configured conversion service (if any).</span><br><span class="line">#dates : methods for java.util.Date objects: formatting, component extraction, etc.</span><br><span class="line">#calendars : analogous to #dates , but for java.util.Calendar objects.</span><br><span class="line">#numbers : methods for formatting numeric objects.</span><br><span class="line">#strings : methods for String objects: contains, startsWith, prepending/appending, etc.</span><br><span class="line">#objects : methods for objects in general.</span><br><span class="line">#bools : methods for boolean evaluation.</span><br><span class="line">#arrays : methods for arrays.</span><br><span class="line">#lists : methods for lists.</span><br><span class="line">#sets : methods for sets.</span><br><span class="line">#maps : methods for maps.</span><br><span class="line">#aggregates : methods for creating aggregates on arrays or collections.</span><br><span class="line">#ids : methods for dealing with id attributes that might be repeated (for example, as a result of an iteration).</span><br><span class="line"></span><br><span class="line">SelectionVariableExpressions: *&#123;...&#125; ;变量的选择表达式：和$()功能上是一样的  </span><br><span class="line">MessageExpressions: #&#123;...&#125; ；获取国际化内容</span><br><span class="line">LinkURLExpressions: @&#123;...&#125;；定义URL   </span><br><span class="line">Fragment Expressions: ~&#123;...&#125;;</span><br><span class="line"></span><br><span class="line">Literals（字面量）</span><br><span class="line">Text literals: &apos;one text&apos; , &apos;Another one!&apos; ,... </span><br><span class="line">Number literals: 0 , 34 , 3.0 , 12.3 ,... Boolean literals: true , false</span><br><span class="line">Nulll iteral: null</span><br><span class="line">Literal tokens: one , sometext , main ,... </span><br><span class="line">Text operations:</span><br><span class="line">String concatenation: +</span><br><span class="line">Literal substitutions: |The name is $&#123;name&#125;|</span><br><span class="line">Arithmetic operations: </span><br><span class="line">Binaryoperators: +, -, *, /, %</span><br><span class="line">Minussign(unaryoperator): - Boolean operations:</span><br><span class="line">Binary operators: and , or</span><br><span class="line">Boolean negation (unary operator): ! , not</span><br><span class="line">Comparisons and equality:</span><br><span class="line">Comparators: &gt;, &lt;, &gt;=, &lt;= (gt, lt, ge, le)</span><br><span class="line">Equality operators: == , != ( eq , ne ) Conditional operators:</span><br><span class="line">If-then: (if) ? (then)</span><br><span class="line">If-then-else: (if) ? (then) : (else) Default: (value) ?: (defaultvalue)&lt;p th:utext=&quot;#&#123;home.welcome&#125;&quot;&gt;Welcome to our grocery store!&lt;/p&gt; &lt;p&gt;Today is: &lt;span th:text=&quot;$&#123;today&#125;&quot;&gt;13 february 2011&lt;/span&gt;&lt;/p&gt;</span><br><span class="line">                            Special tokens:</span><br><span class="line"> Page 17 of 104</span><br><span class="line"> &apos;User is of type &apos; + ($&#123;user.isAdmin()&#125; ? &apos;Administrator&apos; : ($&#123;user.type&#125; ?: &apos;Unknown&apos;))4.1 Messages</span><br><span class="line"> &lt;p th:utext=&quot;#&#123;home.welcome&#125;&quot;&gt;Welcome to our grocery store!&lt;/p&gt;</span><br><span class="line"> home.welcome=¡Bienvenido a nuestra tienda de comestibles!</span><br><span class="line"> &lt;p&gt;¡Bienvenido a nuestra tienda de comestibles, John Apricot!&lt;/p&gt;</span><br><span class="line"> home.welcome=¡Bienvenido a nuestra tienda de comestibles, &#123;0&#125;!&lt;p th:utext=&quot;#&#123;home.welcome($&#123;session.user.name&#125;)&#125;&quot;&gt; Welcome to our grocery store, Sebastian Pepper!</span><br><span class="line">&lt;/p&gt;&lt;p th:utext=&quot;#&#123;$&#123;welcomeMsgKey&#125;($&#123;session.user.name&#125;)&#125;&quot;&gt; Welcome to our grocery store, Sebastian Pepper!</span><br><span class="line">&lt;/p&gt;4.2 Variables</span><br><span class="line">sNo-Operation: _</span><br></pre></td></tr></table></figure><h2 id="SpringMVC自动配置原理"><a href="#SpringMVC自动配置原理" class="headerlink" title="SpringMVC自动配置原理"></a>SpringMVC自动配置原理</h2><h3 id="Spring-MVC-auto-configuration"><a href="#Spring-MVC-auto-configuration" class="headerlink" title="Spring MVC auto-configuration"></a>Spring MVC auto-configuration</h3><p>Spring Boot自动配置好了SpringMVC，以下是Spring Boot对SpringMVC的默认配置：  </p><ul><li>包括：ContentNegotiatingViewResolver和BeanNameViewResolver<ul><li>自动配置了ViewResolver(视图解析器：根据方法的返回值得到视图对象(View),视图对象决定如何渲染（转发？重定向？）)</li><li>ContentNegotiatingViewResolver:组合所有的视图解析器</li><li>如何定制？我们可以自己给容器添加一个视图解析器；自动会将其解析进来</li></ul></li><li>静态资源文件夹路径webjars</li><li>支持静态资源</li><li>静态资源首页访问</li><li>自动注册了：Converter，GenericConverter，Formatter（Bean）<ul><li>Converter：转换器，public String hello(User user):类型转换使用Converter</li><li>Formatter 格式转换器：2017/12/17 —&gt; Date</li><li>需要在文件中配置日期格式化的规则，然后才能正常使用</li><li>自己添加格式转换器，只需要放在容器中即可</li></ul></li><li>HttpMessageConverters(see below)<ul><li>HttpMessageConverter：SpringMVC用来转换Http请求和响应的；User–json;</li><li>MessageConvert:从容器中确定；获取所有的HttpMessageConverter；<br>自己给容器中添加HttpMessageConverter，只需要将自己的组件注册容器中(@Bean, Component)</li></ul></li><li>MessageCodeResolver 定义错误代码生成规则</li><li>ConfigurableWebBindingInitializer<ul><li>可以配置一个ConfigurableWebBindingInitializer来替换默认的，添加到容器</li><li>初始化WebDataBinder；请求数据===》JavaBean</li></ul></li></ul><p>org.springframework.boot.autocinfigure.web配置包的路径</p><h3 id="如何修改Spring-Boot的默认配置"><a href="#如何修改Spring-Boot的默认配置" class="headerlink" title="如何修改Spring Boot的默认配置"></a>如何修改Spring Boot的默认配置</h3><p>模式：  </p><ul><li>1、Spring Boot在自动配置很多组件时，先看容器中有没有用户自己配置的(@Bean，@Component)如果有就就用用户配置的；如果没有，才自动配置；如果有些组件可以有多个(ViewResolver)将用户配置的和自己默认的组合起来；</li></ul><h2 id="扩展与全面接管SpringMVC"><a href="#扩展与全面接管SpringMVC" class="headerlink" title="扩展与全面接管SpringMVC"></a>扩展与全面接管SpringMVC</h2><ul><li>2、扩展SpringMVC，在Spring Boot中有非常多的xxxConfigurer帮助我们进行扩展配置</li></ul><p>编写一个配置类(@Configuration),是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc</p><p>既保留了所有的自动配置，也能用扩展的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot04web.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line">import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"></span><br><span class="line">// 使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能</span><br><span class="line">@Configuration</span><br><span class="line">public class MyMvcConfig implements WebMvcConfigurer &#123;</span><br><span class="line"></span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry)&#123;</span><br><span class="line">        // 浏览器发送/usst请求来到success</span><br><span class="line">        registry.addViewController(&quot;/usst&quot;).setViewName(&quot;success&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理：</p><ul><li>1、WebMvcAutoConfiguration是SpringMVC的自动配置类</li><li>2、在做其他自动配置时会导入@import(<strong>EnableWebMvcConfiguration</strong>.class)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123;</span><br><span class="line"></span><br><span class="line">private final WebMvcProperties mvcProperties;</span><br><span class="line"></span><br><span class="line">private final ListableBeanFactory beanFactory;</span><br><span class="line"></span><br><span class="line">private final WebMvcRegistrations mvcRegistrations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 在DelegatingWebMvcConfiguration中</span><br><span class="line">// 从容器中获取所有的WebMvcConfigurer</span><br><span class="line">@Autowired(required = false)</span><br><span class="line">public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;</span><br><span class="line">if (!CollectionUtils.isEmpty(configurers)) &#123;</span><br><span class="line">// 将所有的WebMvcConfigurer相关配置一起调用</span><br><span class="line">this.configurers.addWebMvcConfigurers(configurers);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3、容器中所有的WebMvcConfigurer都会一起起作用</li><li>4、我们的配置类也会被调用<br>效果：SpringMVC的自动配置和我们的扩展配置都会起作用</li></ul><h3 id="全面接管SpringMVC"><a href="#全面接管SpringMVC" class="headerlink" title="全面接管SpringMVC"></a>全面接管SpringMVC</h3><p>SpringBoot对SpringMVC的自动配置都不要了，所有的都是我们自己设；<br><strong>我们需要在配置类在添加@EnableWebMvc即可</strong><br>不推荐全面接管</p><p>原理：<br>（1）@EnableWebMvc的核心</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="line">public @interface EnableWebMvc&#123;&#125;</span><br><span class="line">```  </span><br><span class="line">（2）</span><br></pre></td></tr></table></figure><p>@Configuration<br>public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport{}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（3）</span><br></pre></td></tr></table></figure></p><p>@Configuration<br>@ConditionalOnWebApplication(type = Type.SERVLET)<br>@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })</p><p>// 容器中没有这个组件的时候，自动配置类才生效<br>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</p><p>@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)<br>@AutoConfigureAfter({ DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,<br>        ValidationAutoConfiguration.class })<br>public class WebMvcAutoConfiguration {</p><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">（4）@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；  </span><br><span class="line">（5）导入的WebMvcConfigurationSupport只是SpringMVC的基本功能</span><br><span class="line"></span><br><span class="line">## 引入资源</span><br><span class="line">### RestfulCRUD</span><br><span class="line">（1）默认访问首页</span><br></pre></td></tr></table></figure></p><p>//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能<br>//@EnableWebMvc 不要接管SpringMVC<br>@Configuration<br>publicclassMyMvcConfigextendsWebMvcConfigurerAdapter{<br>    @Override<br>    public void addViewControllers(ViewControllerRegistry registry) {<br>       // super.addViewControllers(registry);<br>        //浏览器发送 /atguigu 请求来到 success<br>       registry.addViewController(“/atguigu”).setViewName(“success”);<br>    }</p><pre><code>//所有的WebMvcConfigurerAdapter组件都会一起起作用@Bean //将组件注册在容器public WebMvcConfigurerAdapter webMvcConfigurerAdapter(){        WebMvcConfigurerAdapter adapter = new WebMvcConfigurerAdapter() {            @Override            public void addViewControllers(ViewControllerRegistry registry) {                registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);                registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);            } };        return adapter;  }</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 国际化</span><br><span class="line">### 使用SpringMVC来开发国际化</span><br><span class="line">**（1）编写国际化配置文件；**  </span><br><span class="line">（2）使用ResourceBundleMessageSource管理国际化资源文件  </span><br><span class="line">（3）jsp页面可以使用fmt:message取出国际化内容</span><br><span class="line"></span><br><span class="line">### 使用SpringBoot步骤</span><br><span class="line">（1）编写国际化配置文件，抽取页面需要显示的国际化消息  </span><br><span class="line">![国际化](Spring-Boot与web开发/国际化.png)  </span><br><span class="line">（2）SpringBoot自动配置好了管理国际化资源文件的组件；</span><br></pre></td></tr></table></figure></p><pre><code>@Bean@ConfigurationProperties(prefix = &quot;spring.messages&quot;)public MessageSourceProperties messageSourceProperties() {    return new MessageSourceProperties();}@Beanpublic MessageSource messageSource(MessageSourceProperties properties) {    ResourceBundleMessageSource messageSource = new ResourceBundleMessageSource();    if (StringUtils.hasText(properties.getBasename())) {        &lt;!--设置国际化文件的基础名(去掉语言，国家代码)--&gt;        messageSource.setBasenames(StringUtils                .commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(properties.getBasename())));    }    if (properties.getEncoding() != null) {        messageSource.setDefaultEncoding(properties.getEncoding().name());    }    messageSource.setFallbackToSystemLocale(properties.isFallbackToSystemLocale());    Duration cacheDuration = properties.getCacheDuration();    if (cacheDuration != null) {        messageSource.setCacheMillis(cacheDuration.toMillis());    }    messageSource.setAlwaysUseMessageFormat(properties.isAlwaysUseMessageFormat());    messageSource.setUseCodeAsDefaultMessage(properties.isUseCodeAsDefaultMessage());    return messageSource;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(3)页面获取国际化的值</span><br></pre></td></tr></table></figure><p>&lt;!DOCTYPE html&gt;</p><html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"><br>    <head><br>        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br>        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><br>        <meta name="description" content=""><br>        <meta name="author" content=""><br>        <title>Signin Template for Bootstrap</title><br>        <!-- Bootstrap core CSS --><br>        <link href="asserts/css/bootstrap.min.css" rel="stylesheet"><br>        <!-- Custom styles for this template --><br>        <link href="asserts/css/signin.css" rel="stylesheet"><br>    </head><br><br>    <body class="text-center"><br>        <form class="form-signin" action="dashboard.html"><br>            <img class="mb-4" src="/2019/07/15/Spring-Boot与Web开发/img/bootstrap-solid.svg" alt="" width="72" height="72"><br>            <h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1><br>            <label class="sr-only" th:text="#{login.username}">Username</label><br>            <input type="text" class="form-control" th:placeholder="#{login.username}" placeholder="Username" required autofocus><br>            <label class="sr-only" th:text="#{login.password}">Password</label><br>            <input type="password" class="form-control" placeholder="Password" th:placeholder="#{login.password}" required><br>            <div class="checkbox mb-3"><br>                <label><br>          <input type="checkbox" value="remember-me"> [[#{login.remember}]]<br>        </label><br>            </div><br>            <button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#{login.btn}">Sign in</button><br>            <p class="mt-5 mb-3 text-muted">© 2017-2018</p><br>            <a class="btn btn-sm">中文</a><br>            <a class="btn btn-sm">English</a><br>        </form><br><br>    </body><br><br></html><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">根据浏览器语言设置信息切换中英文效果。</span><br><span class="line"></span><br><span class="line">原理：  </span><br><span class="line">国际化的重要对象Locale(区域信息对象)：LocaleResolver（获取区域信息对象）</span><br></pre></td></tr></table></figure><br><br>//默认的区域信息是根据请求头带来的区域信息获取Locale进行国际化<br>    @Bean<br>    @ConditionalOnMissingBean<br>    @ConditionalOnProperty(prefix = “spring.mvc”, name = “locale”)<br>    public LocaleResolver localeResolver() {<br>        if (this.mvcProperties.getLocaleResolver() == WebMvcProperties.LocaleResolver.FIXED) {<br>            return new FixedLocaleResolver(this.mvcProperties.getLocale());<br>        }<br>        AcceptHeaderLocaleResolver localeResolver = new AcceptHeaderLocaleResolver();<br>        localeResolver.setDefaultLocale(this.mvcProperties.getLocale());<br>        return localeResolver;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（4）点击链接切换国际化</span><br><span class="line"></span><br><span class="line">html页面</span><br></pre></td></tr></table></figure><br><br>&lt;!DOCTYPE html&gt;<br><html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"><br>    <head><br>        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br>        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><br>        <meta name="description" content=""><br>        <meta name="author" content=""><br>        <title>Signin Template for Bootstrap</title><br>        <!-- Bootstrap core CSS --><br>        <link href="asserts/css/bootstrap.min.css" rel="stylesheet"><br>        <!-- Custom styles for this template --><br>        <link href="asserts/css/signin.css" rel="stylesheet"><br>    </head><br><br>    <body class="text-center"><br>        <form class="form-signin" action="dashboard.html"><br>            <img class="mb-4" src="/2019/07/15/Spring-Boot与Web开发/img/bootstrap-solid.svg" alt="" width="72" height="72"><br>            <h1 class="h3 mb-3 font-weight-normal" th:text="#{login.tip}">Please sign in</h1><br>            <label class="sr-only" th:text="#{login.username}">Username</label><br>            <input type="text" class="form-control" th:placeholder="#{login.username}" placeholder="Username" required autofocus><br>            <label class="sr-only" th:text="#{login.password}">Password</label><br>            <input type="password" class="form-control" placeholder="Password" th:placeholder="#{login.password}" required><br>            <div class="checkbox mb-3"><br>                <label><br>          <input type="checkbox" value="remember-me"> [[#{login.remember}]]<br>        </label><br>            </div><br>            <button class="btn btn-lg btn-primary btn-block" type="submit" th:text="#{login.btn}">Sign in</button><br>            <p class="mt-5 mb-3 text-muted">© 2017-2018</p><br>            <a class="btn btn-sm" th:href="@{/(l='zh_CN')}">中文</a><br>            <a class="btn btn-sm" th:href="@{/(l='en_US')}">English</a><br>        </form><br><br>    </body><br><br></html><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MyLocaleResolver</span><br></pre></td></tr></table></figure><p>package com.usst.springboot04web.commponent;</p><p>import org.apache.tomcat.jni.Local;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.web.servlet.LocaleResolver;<br>import org.thymeleaf.util.StringUtils;</p><p>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.util.Locale;<br>import java.util.Set;</p><p>/**</p><ul><li>可以在链接上携带区域信息<br>*/<br>public class MyLocalResolver implements LocaleResolver {</li></ul><pre><code>@Overridepublic Locale resolveLocale(HttpServletRequest request) {    String l = request.getParameter(&quot;l&quot;);    Locale locale = Locale.getDefault();    if (!StringUtils.isEmpty(l)){        String[] split = l.split(&quot;_&quot;);        locale = new Locale(split[0], split[1]);    }    return locale;}@Overridepublic void setLocale(HttpServletRequest request, HttpServletResponse response, Locale locale) {}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">MyMvcConfig</span><br></pre></td></tr></table></figure><p>package com.usst.springboot04web.config;</p><p>import com.usst.springboot04web.commponent.MyLocalResolver;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.web.servlet.LocaleResolver;<br>import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;<br>import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br>import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;<br>import org.springframework.web.servlet.i18n.CookieLocaleResolver;</p><p>// 使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能<br>@Configuration<br>public class MyMvcConfig implements WebMvcConfigurer {</p><pre><code>public void addViewControllers(ViewControllerRegistry registry){    // 浏览器发送/usst请求来到success    registry.addViewController(&quot;/usst&quot;).setViewName(&quot;success&quot;);} // 注意：这里的名字必须是这个名字，否则会报错@Beanpublic LocaleResolver localeResolver() {    return new MyLocalResolver();}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 登陆&amp;拦截器</span><br><span class="line">### 登陆</span><br><span class="line">开发期间修改模板引擎页面之后，要实时生效  </span><br><span class="line">（1）禁用模板引擎的存储</span><br></pre></td></tr></table></figure><p>spring.messages.basename=i18n.login</p><h1 id="禁用模板引擎的缓存"><a href="#禁用模板引擎的缓存" class="headerlink" title="禁用模板引擎的缓存"></a>禁用模板引擎的缓存</h1><p>spring.thymeleaf.cache=false<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）页面修改完成之后，command+F9，重新编译；</span><br><span class="line"></span><br><span class="line">登陆错误消息的显示</span><br></pre></td></tr></table></figure></p><p></p><p style="color: red" th:text="${msg}" th:if="${not #strings.isEmpty(msg)}"></p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">login登陆页面</span><br></pre></td></tr></table></figure><p></p><p>&lt;!DOCTYPE html&gt;</p><p><html lang="en" xmlns:th="http://www.w3.org/1999/xhtml"><br>    <head><br>        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br>        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><br>        <meta name="description" content=""><br>        <meta name="author" content=""><br>        <title>Signin Template for Bootstrap</title><br>        <!-- Bootstrap core CSS --><br>        <link href="asserts/css/bootstrap.min.css" th:href="@{/asserts/css/bootstrap.min.css}" rel="stylesheet"><br>        <!-- Custom styles for this template --><br>        <link href="asserts/css/signin.css" th:href="@{/asserts/css/signin.css}" rel="stylesheet"><br>    </head></html></p><pre><code>&lt;body class=&quot;text-center&quot;&gt;    &lt;form class=&quot;form-signin&quot; action=&quot;dashboard.html&quot; th:action=&quot;@{/user/login}&quot; method=&quot;post&quot;&gt;        &lt;img class=&quot;mb-4&quot; src=&quot;asserts/img/bootstrap-solid.svg&quot; th:src=&quot;@{/asserts/img/bootstrap-solid.svg}&quot; alt=&quot;&quot; width=&quot;72&quot; height=&quot;72&quot;&gt;        &lt;h1 class=&quot;h3 mb-3 font-weight-normal&quot; th:text=&quot;#{login.tip}&quot;&gt;Please sign in&lt;/h1&gt;        &lt;!--做判断，--&gt;        &lt;p style=&quot;color: red&quot; th:text=&quot;${msg}&quot; th:if=&quot;${not #strings.isEmpty(msg)}&quot;&gt;&lt;/p&gt;        &lt;label class=&quot;sr-only&quot; th:text=&quot;#{login.username}&quot;&gt;Username&lt;/label&gt;        &lt;input type=&quot;text&quot; name=&quot;username&quot; class=&quot;form-control&quot; th:placeholder=&quot;#{login.username}&quot; placeholder=&quot;Username&quot; required=&quot;&quot; autofocus=&quot;&quot;&gt;        &lt;label class=&quot;sr-only&quot; th:text=&quot;#{login.password}&quot;&gt;Password&lt;/label&gt;        &lt;input type=&quot;password&quot; name=&quot;password&quot; class=&quot;form-control&quot; placeholder=&quot;Password&quot; th:placeholder=&quot;#{login.password}&quot; required=&quot;&quot;&gt;        &lt;div class=&quot;checkbox mb-3&quot;&gt;            &lt;label&gt;      &lt;input type=&quot;checkbox&quot; value=&quot;remember-me&quot; /&gt; [[#{login.remember}]]    &lt;/label&gt;        &lt;/div&gt;        &lt;button class=&quot;btn btn-lg btn-primary btn-block&quot; type=&quot;submit&quot; th:text=&quot;#{login.btn}&quot;&gt;Sign in&lt;/button&gt;        &lt;p class=&quot;mt-5 mb-3 text-muted&quot;&gt;© 2017-2018&lt;/p&gt;        &lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/(l=&apos;zh_CN&apos;)}&quot;&gt;中文&lt;/a&gt;        &lt;a class=&quot;btn btn-sm&quot; th:href=&quot;@{/(l=&apos;en_US&apos;)}&quot;&gt;English&lt;/a&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">loginController</span><br></pre></td></tr></table></figure></p><p>package com.usst.springboot04web.controller;</p><p>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.PostMapping;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RequestMethod;<br>import org.springframework.web.bind.annotation.RequestParam;<br>import org.thymeleaf.util.StringUtils;</p><p>import javax.servlet.http.HttpSession;<br>import java.util.Map;</p><p>@Controller<br>public class LoginController {</p><p>//    @RequestMapping(value = “/user/login”, method = RequestMethod.POST)<br>    @PostMapping(value = “/user/login”)<br>    public String login(@RequestParam(“username”) String username,<br>                        @RequestParam(“password”) String password,<br>                        Map&lt;String, Object&gt; map, HttpSession session){<br>        if (!StringUtils.isEmpty(username) &amp;&amp; “123456”.equals(password)){<br>            session.setAttribute(“loginUser”, username);<br>            // 登陆成功，防止表单重复提交，可以重定向到主页<br>            return “redirect:/main.html”;</p><pre><code>    }else {        map.put(&quot;msg&quot;, &quot;用户名密码错误&quot;);        return &quot;login&quot;;    }}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">(3)拦截器进行登陆检查</span><br></pre></td></tr></table></figure><p>package com.usst.springboot04web.commponent;</p><p>import org.springframework.web.servlet.HandlerInterceptor;</p><p>import javax.servlet.ServletException;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>import java.io.IOException;</p><p>/**</p><ul><li><p>登陆检查<br>*/<br>public class LoginHandlerInterceptor implements HandlerInterceptor {</p><p> @Override<br> public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws ServletException, IOException {</p><pre><code>Object user = request.getSession().getAttribute(&quot;loginUser&quot;);if (user == null){    request.setAttribute(&quot;msg&quot;, &quot;没有权限，请先登录&quot;);    //未登录，返回登陆页面    request.getRequestDispatcher(&quot;/index.html&quot;).forward(request, response);}else {    //已登录，放行    return true;}return false;</code></pre><p> }<br>}</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注册进拦截器,MyMvcConfig</span><br></pre></td></tr></table></figure><p>package com.usst.springboot04web.config;</p><p>import com.usst.springboot04web.commponent.LoginHandlerInterceptor;<br>import com.usst.springboot04web.commponent.MyLocalResolver;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import org.springframework.web.servlet.LocaleResolver;<br>import org.springframework.web.servlet.config.annotation.InterceptorRegistry;<br>import org.springframework.web.servlet.config.annotation.ViewControllerRegistry;<br>import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;<br>import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;<br>import org.springframework.web.servlet.i18n.CookieLocaleResolver;</p><p>// 使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能<br>@Configuration<br>public class MyMvcConfig implements WebMvcConfigurer {</p><pre><code>public void addViewControllers(ViewControllerRegistry registry){    // 浏览器发送/usst请求来到success    registry.addViewController(&quot;/usst&quot;).setViewName(&quot;success&quot;);    registry.addViewController(&quot;/&quot;).setViewName(&quot;login&quot;);    registry.addViewController(&quot;/index.html&quot;).setViewName(&quot;login&quot;);    registry.addViewController(&quot;/main.html&quot;).setViewName(&quot;dashboard&quot;);}// 注册拦截器public void addInterceptors(InterceptorRegistry registry) {    // 拦截任意多层下的任何请求    // 静态资源：*.css, *.js    // SpringBoot已经做好了静态资源映射    registry.addInterceptor(new LoginHandlerInterceptor()).addPathPatterns(&quot;/**&quot;)        .excludePathPatterns(&quot;/index.html&quot;,&quot;/&quot;,&quot;/user/login&quot;);}@Beanpublic LocaleResolver localeResolver() {    return new MyLocalResolver();}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## RESTful实验要求</span><br><span class="line">### CRUD-员工列表</span><br><span class="line">实验要求：  </span><br><span class="line">（1）RESTfulCRUD：CRUD满足Rest风格  </span><br><span class="line">URI：/资源名称/资源标识  HTTP请求方式区分对资源CRUD操作  </span><br><span class="line"></span><br><span class="line">| | 普通CRUD(uri来区分操作) | RestfulCRUD |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| 查询 | getEmp | emp---GET |</span><br><span class="line">| 添加 | addEmp?xxx | emp---POST |</span><br><span class="line">| 修改 | updateEmp?id=xx&amp;xx=xxx | emp/&#123;id&#125;---PUT |</span><br><span class="line">| 删除 | deleteEmp?id=xx | emp/&#123;id&#125;---DELETE |</span><br><span class="line"></span><br><span class="line">(2)实验请求架构</span><br><span class="line"></span><br><span class="line">| | 请求URI | 请求方式 |</span><br><span class="line">| ---- | ---- | ---- |</span><br><span class="line">| 查询所有员工 | emps | GET |</span><br><span class="line">| 查询某个员工 | emp/&#123;id&#125; | GET |</span><br><span class="line">| 来到添加页面 | emp | GET |</span><br><span class="line">| 添加员工 | emp | POST |</span><br><span class="line">| 来到修改页面(查出员工进行信息回写) | emp/&#123;id&#125; | GET |</span><br><span class="line">| 修改员工 | emp | PUT |</span><br><span class="line">| 删除员工 | emp/1 | DELETE |</span><br><span class="line"></span><br><span class="line">## 员工列表-公共页抽取</span><br><span class="line">员工列表：</span><br><span class="line"></span><br><span class="line">### thymeleaf公共页面元素抽取</span><br></pre></td></tr></table></figure><p>1、抽取公共片断</p><div th:fragment="copy"><br>&copy;2011 The Good Thymes Virtual Grocery<br></div><p>2、引入公共片断</p><div th:insert="~{footer :: copy}"></div><br>~{templatename :: selector}:模板名 :: 选择器<br>~{templatename :: selector}:模板名 :: 片段名<br><br>3、默认效果：<br>insert的功能片断在div标签中<br>如果使用th:insert等属性进行引入，可以不用写~{}<br>行内写法可以加上,例如：[[~{}]];[(~{})]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">三种引入公共片断的th属性：  </span><br><span class="line">th:insert:将公共片断整个插入到声明引入的元素中  </span><br><span class="line">th:replace:将声明引入的元素替换为公共片断  </span><br><span class="line">th:include:包含，将被引入的片断的内容包含进标签中</span><br></pre></td></tr></table></figure><br><br><footer th:fragment="copy"><br>&copy;2011 The Good Thymes Virtual Grocery<br></footer><br><br>引入方式<br><div th:insert="footer :: copy"></div><br><div th:replace="footer :: copy"></div><br><div th:include="footer :: copy"></div><p>效果</p><div><br>    <footer><br>        &copy;2011 The Good Thymes Virtual Grocery<br>    </footer><br></div><footer><br>    &copy;2011 The Good Thymes Virtual Grocery<br></footer><div><br>    &copy;2011 The Good Thymes Virtual Grocery<br></div><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 链接高亮&amp;列表完成</span><br><span class="line"></span><br><span class="line">### 添加单机时高亮</span><br><span class="line">引入片断的时候，传入参数：  </span><br><span class="line">dashboard.html</span><br><span class="line"></span><br><span class="line">主要在引入sidebar的下一行，添加了(activeUri=&apos;main.html&apos;)</span><br><span class="line"></span><br><span class="line">`&lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&apos;main.html&apos;)&quot;&gt;&lt;/div&gt;`</span><br></pre></td></tr></table></figure><p>&lt;!DOCTYPE html&gt;<br><!-- saved from url=(0052)http://getbootstrap.com/docs/4.0/examples/dashboard/ --></p><p><html lang="en" xmlns:th="http://www.thymeleaf.org"><br>    <head><br>        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br>        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><br>        <meta name="description" content=""><br>        <meta name="author" content=""></head></html></p><pre><code>    &lt;title&gt;Dashboard Template for Bootstrap&lt;/title&gt;    &lt;!-- Bootstrap core CSS --&gt;    &lt;link href=&quot;asserts/css/bootstrap.min.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;!-- Custom styles for this template --&gt;    &lt;link href=&quot;asserts/css/dashboard.css&quot; rel=&quot;stylesheet&quot;&gt;    &lt;style type=&quot;text/css&quot;&gt;        /* Chart.js */        @-webkit-keyframes chartjs-render-animation {            from {                opacity: 0.99            }            to {                opacity: 1            }        }        @keyframes chartjs-render-animation {            from {                opacity: 0.99            }            to {                opacity: 1            }        }        .chartjs-render-monitor {            -webkit-animation: chartjs-render-animation 0.001s;            animation: chartjs-render-animation 0.001s;        }    &lt;/style&gt;&lt;/head&gt;&lt;body&gt;    &lt;!--引入topbar--&gt;    &lt;div th:replace=&quot;commons/bar::topbar&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;container-fluid&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;!--引入sidebar--&gt;            &lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&apos;main.html&apos;)&quot;&gt;&lt;/div&gt;            &lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt;                &lt;div class=&quot;chartjs-size-monitor&quot; style=&quot;position: absolute; left: 0px; top: 0px; right: 0px; bottom: 0px; overflow: hidden; pointer-events: none; visibility: hidden; z-index: -1;&quot;&gt;                    &lt;div class=&quot;chartjs-size-monitor-expand&quot; style=&quot;position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;&quot;&gt;                        &lt;div style=&quot;position:absolute;width:1000000px;height:1000000px;left:0;top:0&quot;&gt;&lt;/div&gt;                    &lt;/div&gt;                    &lt;div class=&quot;chartjs-size-monitor-shrink&quot; style=&quot;position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;pointer-events:none;visibility:hidden;z-index:-1;&quot;&gt;                        &lt;div style=&quot;position:absolute;width:200%;height:200%;left:0; top:0&quot;&gt;&lt;/div&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;div class=&quot;d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pb-2 mb-3 border-bottom&quot;&gt;                    &lt;h1 class=&quot;h2&quot;&gt;Dashboard&lt;/h1&gt;                    &lt;div class=&quot;btn-toolbar mb-2 mb-md-0&quot;&gt;                        &lt;div class=&quot;btn-group mr-2&quot;&gt;                            &lt;button class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Share&lt;/button&gt;                            &lt;button class=&quot;btn btn-sm btn-outline-secondary&quot;&gt;Export&lt;/button&gt;                        &lt;/div&gt;                        &lt;button class=&quot;btn btn-sm btn-outline-secondary dropdown-toggle&quot;&gt;            &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;none&quot; stroke=&quot;currentColor&quot; stroke-width=&quot;2&quot; stroke-linecap=&quot;round&quot; stroke-linejoin=&quot;round&quot; class=&quot;feather feather-calendar&quot;&gt;&lt;rect x=&quot;3&quot; y=&quot;4&quot; width=&quot;18&quot; height=&quot;18&quot; rx=&quot;2&quot; ry=&quot;2&quot;&gt;&lt;/rect&gt;&lt;line x1=&quot;16&quot; y1=&quot;2&quot; x2=&quot;16&quot; y2=&quot;6&quot;&gt;&lt;/line&gt;&lt;line x1=&quot;8&quot; y1=&quot;2&quot; x2=&quot;8&quot; y2=&quot;6&quot;&gt;&lt;/line&gt;&lt;line x1=&quot;3&quot; y1=&quot;10&quot; x2=&quot;21&quot; y2=&quot;10&quot;&gt;&lt;/line&gt;&lt;/svg&gt;            This week          &lt;/button&gt;                    &lt;/div&gt;                &lt;/div&gt;                &lt;canvas class=&quot;my-4 chartjs-render-monitor&quot; id=&quot;myChart&quot; width=&quot;1076&quot; height=&quot;454&quot; style=&quot;display: block; width: 1076px; height: 454px;&quot;&gt;&lt;/canvas&gt;            &lt;/main&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;!-- Bootstrap core JavaScript================================================== --&gt;    &lt;!-- Placed at the end of the document so the pages load faster --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/jquery-3.2.1.slim.min.js&quot; &gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/popper.min.js&quot; &gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/bootstrap.min.js&quot; &gt;&lt;/script&gt;    &lt;!-- Icons --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/feather.min.js&quot; &gt;&lt;/script&gt;    &lt;script&gt;        feather.replace()    &lt;/script&gt;    &lt;!-- Graphs --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/Chart.min.js&quot; &gt;&lt;/script&gt;    &lt;script&gt;        var ctx = document.getElementById(&quot;myChart&quot;);        var myChart = new Chart(ctx, {            type: &apos;line&apos;,            data: {                labels: [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;],                datasets: [{                    data: [15339, 21345, 18483, 24003, 23489, 24092, 12034],                    lineTension: 0,                    backgroundColor: &apos;transparent&apos;,                    borderColor: &apos;#007bff&apos;,                    borderWidth: 4,                    pointBackgroundColor: &apos;#007bff&apos;                }]            },            options: {                scales: {                    yAxes: [{                        ticks: {                            beginAtZero: false                        }                    }]                },                legend: {                    display: false,                }            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">list.html的页面也是类似</span><br><span class="line"></span><br><span class="line">bar.html页面做判断,主要是增加了这句话，员工管理添加的内容与list.html中添加的内容需要匹配上</span><br><span class="line"></span><br><span class="line">`th:class=&quot;$&#123;activeUri == &apos;main.html&apos; ? &apos;nav-link active&apos; : &apos;nav-link&apos;&#125;&quot;`</span><br></pre></td></tr></table></figure></p><p>&lt;!DOCTYPE html&gt;</p><p><html lang="en" xmlns:th="http://www.thymeleaf.org"></html></p><head><br>    <meta charset="UTF-8"><br>    <title>Title</title><br></head><br><body><br><br><!--topbar--><br><nav class="navbar navbar-dark sticky-top bg-dark flex-md-nowrap p-0" th:fragment="topbar"><br>    <a class="navbar-brand col-sm-3 col-md-2 mr-0" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener">[[${session.loginUser}]]</a><br>    <input class="form-control form-control-dark w-100" type="text" placeholder="Search" aria-label="Search"><br>    <ul class="navbar-nav px-3"><br>        <li class="nav-item text-nowrap"><br>            <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener">Sign out</a><br>        </li><br>    </ul><br></nav><br><br><!--sidebar--><br><nav class="col-md-2 d-none d-md-block bg-light sidebar" id="sidebar"><br>    <div class="sidebar-sticky"><br>        <ul class="nav flex-column"><br>            <li class="nav-item"><br>                <a class="nav-link active" href="#" th:href="@{/main.html}" th:class="${activeUri == 'main.html' ? 'nav-link active' : 'nav-link'}"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-home"><br/>                        <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><br/>                        <polyline points="9 22 9 12 15 12 15 22"/><br/>                    </svg><br>                    Dashboard <span class="sr-only">(current)</span><br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><br/>                        <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"/><br/>                        <polyline points="13 2 13 9 20 9"/><br/>                    </svg><br>                    Orders<br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-shopping-cart"><br/>                        <circle cx="9" cy="21" r="1"/><br/>                        <circle cx="20" cy="21" r="1"/><br/>                        <path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"/><br/>                    </svg><br>                    Products<br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="#" th:href="@{/emps}" th:class="${activeUri == 'emps' ? 'nav-link active' : 'nav-link'}"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-users"><br/>                        <path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"/><br/>                        <circle cx="9" cy="7" r="4"/><br/>                        <path d="M23 21v-2a4 4 0 0 0-3-3.87"/><br/>                        <path d="M16 3.13a4 4 0 0 1 0 7.75"/><br/>                    </svg><br>                    员工管理<br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-bar-chart-2"><br/>                        <line x1="18" y1="20" x2="18" y2="10"/><br/>                        <line x1="12" y1="20" x2="12" y2="4"/><br/>                        <line x1="6" y1="20" x2="6" y2="14"/><br/>                    </svg><br>                    Reports<br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-layers"><br/>                        <polygon points="12 2 2 7 12 12 22 7 12 2"/><br/>                        <polyline points="2 17 12 22 22 17"/><br/>                        <polyline points="2 12 12 17 22 12"/><br/>                    </svg><br>                    Integrations<br>                </a><br>            </li><br>        </ul><br><br>        <h6 class="sidebar-heading d-flex justify-content-between align-items-center px-3 mt-4 mb-1 text-muted"><br>            <span>Saved reports</span><br>            <a class="d-flex align-items-center text-muted" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-plus-circle"><circle cx="12" cy="12" r="10"/><line x1="12" y1="8" x2="12" y2="16"/><line x1="8" y1="12" x2="16" y2="12"/></svg><br>            </a><br>        </h6><br>        <ul class="nav flex-column mb-2"><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><br/>                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><br/>                        <polyline points="14 2 14 8 20 8"/><br/>                        <line x1="16" y1="13" x2="8" y2="13"/><br/>                        <line x1="16" y1="17" x2="8" y2="17"/><br/>                        <polyline points="10 9 9 9 8 9"/><br/>                    </svg><br>                    Current month<br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><br/>                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><br/>                        <polyline points="14 2 14 8 20 8"/><br/>                        <line x1="16" y1="13" x2="8" y2="13"/><br/>                        <line x1="16" y1="17" x2="8" y2="17"/><br/>                        <polyline points="10 9 9 9 8 9"/><br/>                    </svg><br>                    Last quarter<br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><br/>                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><br/>                        <polyline points="14 2 14 8 20 8"/><br/>                        <line x1="16" y1="13" x2="8" y2="13"/><br/>                        <line x1="16" y1="17" x2="8" y2="17"/><br/>                        <polyline points="10 9 9 9 8 9"/><br/>                    </svg><br>                    Social engagement<br>                </a><br>            </li><br>            <li class="nav-item"><br>                <a class="nav-link" href="http://getbootstrap.com/docs/4.0/examples/dashboard/#" target="_blank" rel="noopener"><br>                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file-text"><br/>                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><br/>                        <polyline points="14 2 14 8 20 8"/><br/>                        <line x1="16" y1="13" x2="8" y2="13"/><br/>                        <line x1="16" y1="17" x2="8" y2="17"/><br/>                        <polyline points="10 9 9 9 8 9"/><br/>                    </svg><br>                    Year-end sale<br>                </a><br>            </li><br>        </ul><br>    </div><br></nav><br><br></body><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 员工列表</span><br><span class="line"></span><br><span class="line">在list.html中已有提现，重点是以下代码：</span><br></pre></td></tr></table></figure><br><br><div class="table-responsive"><br>    <table class="table table-striped table-sm"><br>        <thead><br>            <tr><br>                <th>#</th><br>                <th>lastName</th><br>                <th>email</th><br>                <th>gender</th><br>                <th>department</th><br>                <th>birth</th><br>                <th>操作</th><br>            </tr><br>        </thead><br>        <tbody><br>            <tr th:each="emp:${emps}"><br>                <td th:text="${emp.id}"></td><br>                <td th:text="${emp.lastName}"></td><br>                <td th:text="${emp.email}"></td><br>                <td th:text="${emp.gender} == 0 ? '女' : '男'"></td><br>                <td th:text="${emp.department.departmentName}"></td><br>                <td th:text="${dates.format(emp.birth, 'yyyy-MM-dd HH:mm')}"></td><br>                <td><br>                    <button class="btn btn-sm btn-primary">编辑</button><br>                    <button class="btn btn-sm btn-danger">删除</button><br>                </td><br>            </tr><br>        </tbody><br>    </table><br></div><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 来到添加页面</span><br><span class="line">页面是从bootstrap抓取的，这里不做记录了</span><br><span class="line"></span><br><span class="line">## 员工添加-添加完成</span><br><span class="line">Controller代码，页面代码不做展示了</span><br></pre></td></tr></table></figure><br><br>package com.usst.springboot04web.controller;<br><br>import com.usst.springboot04web.dao.DepartmentDao;<br>import com.usst.springboot04web.dao.EmployeeDao;<br>import com.usst.springboot04web.entities.Department;<br>import com.usst.springboot04web.entities.Employee;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.boot.autoconfigure.mail.MailProperties;<br>import org.springframework.stereotype.Controller;<br>import org.springframework.ui.Model;<br>import org.springframework.ui.ModelMap;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.PostMapping;<br><br>import java.util.Collection;<br><br>@Controller<br>public class EmployeeController {<br>    @Autowired<br>    private EmployeeDao employeeDao;<br><br>    @Autowired<br>    private DepartmentDao departmentDao;<br><br>    // 查询所有员工，返回列表页面<br>    @GetMapping(“/emps”)<br>    public String list(Model model){<br>        Collection&lt;com.usst.springboot04web.entities.Employee&gt; employees = employeeDao.getAll();<br><br>        // 放在请求域中<br>        model.addAttribute(“emps”, employees);<br>        // thymeleaf默认会拼字符串<br>        // classpath:/templates/   .html<br>        return “emp/list”;<br>    }<br><br>    //来到员工添加页面<br>    @GetMapping(“/emp”)<br>    public String toAdd(Model model){<br>        // 查出所有的部门，在页面显示<br>        Collection<department> departments = departmentDao.getDepartments();<br><br>        model.addAttribute(“depts”, departments);<br>        return “emp/add”;<br>    }<br><br>    // 员工添加<br>    // springMVC自动将请求参数和入参对象的属性进行一一绑定，要求请求参数的名字和JavaBean入参的对象里面的属性名是相同的<br>    @PostMapping(“/emp”)<br>    public String addEmp(Employee employee){<br>        // 来到员工列表页面<br>        employeeDao.save(employee);<br>        // redirect:表示重定向到一个地址 /表示当前项目路径<br>        // forward:表示转发到一个地址<br>        return “redirect:/emps”;<br>    }<br>}<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">注意：有的时候，日期格式输入的不正确，会报400错误  </span><br><span class="line"></span><br><span class="line">提交的格式不正确：生日：日期  </span><br><span class="line">2017-12-12；2017/12/12，2017,12,12  </span><br><span class="line">日期的格式化；SpringMVC将页面提交的值需要转换为指定的类型</span><br><span class="line">2017-12-12 -----&gt; 类型转换，格式化  </span><br><span class="line">默认日期是按照/的方式</span><br><span class="line"></span><br><span class="line">## 员工修改-重用页面-修改完成</span><br><span class="line">controller层的代码：</span><br></pre></td></tr></table></figure><br><br>package com.usst.springboot04web.controller;<br><br>import com.usst.springboot04web.dao.DepartmentDao;<br>import com.usst.springboot04web.dao.EmployeeDao;<br>import com.usst.springboot04web.entities.Department;<br>import com.usst.springboot04web.entities.Employee;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.boot.autoconfigure.mail.MailProperties;<br>import org.springframework.stereotype.Controller;<br>import org.springframework.ui.Model;<br>import org.springframework.ui.ModelMap;<br>import org.springframework.web.bind.annotation.GetMapping;<br>import org.springframework.web.bind.annotation.PathVariable;<br>import org.springframework.web.bind.annotation.PostMapping;<br>import org.springframework.web.bind.annotation.PutMapping;<br><br>import java.util.Collection;<br><br>@Controller<br>public class EmployeeController {<br>    @Autowired<br>    private EmployeeDao employeeDao;<br><br>    @Autowired<br>    private DepartmentDao departmentDao;<br><br>    // 查询所有员工，返回列表页面<br>    @GetMapping(“/emps”)<br>    public String list(Model model){<br>        Collection&lt;com.usst.springboot04web.entities.Employee&gt; employees = employeeDao.getAll();<br><br>        // 放在请求域中<br>        model.addAttribute(“emps”, employees);<br>        // thymeleaf默认会拼字符串<br>        // classpath:/templates/   .html<br>        return “emp/list”;<br>    }<br><br>    //来到员工添加页面<br>    @GetMapping(“/emp”)<br>    public String toAdd(Model model){<br>        // 查出所有的部门，在页面显示<br>        Collection<department> departments = departmentDao.getDepartments();<br><br>        model.addAttribute(“depts”, departments);<br>        return “emp/add”;<br>    }<br><br>    // 员工添加<br>    // springMVC自动将请求参数和入参对象的属性进行一一绑定，要求请求参数的名字和JavaBean入参的对象里面的属性名是相同的<br>    @PostMapping(“/emp”)<br>    public String addEmp(Employee employee){<br>        // 来到员工列表页面<br>        employeeDao.save(employee);<br>        // redirect:表示重定向到一个地址 /表示当前项目路径<br>        // forward:表示转发到一个地址<br>        return “redirect:/emps”;<br>    }<br><br>    // 来到修改页面，查出当前员工，在页面回显<br>    @GetMapping(“/emp/{id}”)<br>    public String toEditPage(@PathVariable(“id”) Integer id, Model model){<br>        Employee employee = employeeDao.get(id);<br>        model.addAttribute(“emp”, employee);<br><br>        //页面显示所有的部门列表<br>        Collection<department> departments = departmentDao.getDepartments();<br>        model.addAttribute(“depts”, departments);<br><br>        //回到修改页面（add是一个修改添加二合一的页面）<br>        return “emp/add”;<br>    }<br><br>    // 员工修改,需要提交员工id<br>    @PutMapping(“/emp”)<br>    public String updateEmployee(Employee employee){<br><br>        employeeDao.save(employee);<br><br>        return “redirect:/emps”;<br>    }<br>}<br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">页面不想做展示了。。</span><br><span class="line"></span><br><span class="line">## 员工删除-删除完成</span><br><span class="line">controller层的代码：</span><br></pre></td></tr></table></figure><br><br>    // 员工删除<br>    @DeleteMapping(“/emp/{id}”)<br>    public String deleteEmployee(@PathVariable(“id”) Integer id){<br>        employeeDao.delete(id);<br>        return “redirect:/emps”;<br>    }<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">list.html的代码，注意js的写法以及thymeleaf的常见写法</span><br></pre></td></tr></table></figure><br><br>&lt;!DOCTYPE html&gt;<br><!-- saved from url=(0052)http://getbootstrap.com/docs/4.0/examples/dashboard/ --><br><html lang="en" xmlns:th="http://www.thymeleaf.org"><br><br>    <head><br>        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><br>        <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><br>        <meta name="description" content=""><br>        <meta name="author" content=""><br><br>        <title>Dashboard Template for Bootstrap</title><br>        <!-- Bootstrap core CSS --><br>        <link href="asserts/css/bootstrap.min.css" rel="stylesheet"><br><br>        <!-- Custom styles for this template --><br>        <link href="asserts/css/dashboard.css" rel="stylesheet"><br>        <style type="text/css"><br>            /<em> Chart.js </em>/<br><br>            @-webkit-keyframes chartjs-render-animation {<br>                from {<br>                    opacity: 0.99<br>                }<br>                to {<br>                    opacity: 1<br>                }<br>            }<br><br>            @keyframes chartjs-render-animation {<br>                from {<br>                    opacity: 0.99<br>                }<br>                to {<br>                    opacity: 1<br>                }<br>            }<br><br>            .chartjs-render-monitor {<br>                -webkit-animation: chartjs-render-animation 0.001s;<br>                animation: chartjs-render-animation 0.001s;<br>            }<br>        </style><br>    </head><pre><code>&lt;body&gt;    &lt;!--引入抽取的topbar--&gt;    &lt;!--模板名，会使用thymeleaf的前后缀配置规则进行解析--&gt;    &lt;div th:replace=&quot;commons/bar::topbar&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;container-fluid&quot;&gt;        &lt;div class=&quot;row&quot;&gt;            &lt;!--引入侧边栏--&gt;            &lt;div th:replace=&quot;commons/bar::#sidebar(activeUri=&apos;emps&apos;)&quot;&gt;&lt;/div&gt;            &lt;main role=&quot;main&quot; class=&quot;col-md-9 ml-sm-auto col-lg-10 pt-3 px-4&quot;&gt;                &lt;h2&gt;&lt;a class=&quot;btn btn-sm btn-success&quot; href=&quot;emp&quot; th:href=&quot;@{/emp}&quot;&gt;员工添加&lt;/a&gt;&lt;/h2&gt;                &lt;div class=&quot;table-responsive&quot;&gt;                    &lt;table class=&quot;table table-striped table-sm&quot;&gt;                        &lt;thead&gt;                            &lt;tr&gt;                                &lt;th&gt;#&lt;/th&gt;                                &lt;th&gt;lastName&lt;/th&gt;                                &lt;th&gt;email&lt;/th&gt;                                &lt;th&gt;gender&lt;/th&gt;                                &lt;th&gt;department&lt;/th&gt;                                &lt;th&gt;birth&lt;/th&gt;                                &lt;th&gt;操作&lt;/th&gt;                            &lt;/tr&gt;                        &lt;/thead&gt;                        &lt;tbody&gt;                            &lt;tr th:each=&quot;emp:${emps}&quot;&gt;                                &lt;td th:text=&quot;${emp.id}&quot;&gt;&lt;/td&gt;                                &lt;td th:text=&quot;${emp.lastName}&quot;&gt;&lt;/td&gt;                                &lt;td th:text=&quot;${emp.email}&quot;&gt;&lt;/td&gt;                                &lt;td th:text=&quot;${emp.gender} == 0 ? &apos;女&apos; : &apos;男&apos;&quot;&gt;&lt;/td&gt;                                &lt;td th:text=&quot;${emp.department.departmentName}&quot;&gt;&lt;/td&gt;                                &lt;td th:text=&quot;${#dates.format(emp.birth, &apos;yyyy-MM-dd HH:mm&apos;)}&quot;&gt;&lt;/td&gt;                                &lt;td&gt;                                    &lt;a class=&quot;btn btn-sm btn-primary&quot; th:href=&quot;@{/emp/} + ${emp.id}&quot;&gt;编辑&lt;/a&gt;                                    &lt;button th:attr=&quot;del_uri=@{/emp/} + ${emp.id}&quot; type=&quot;submit&quot; class=&quot;btn btn-sm btn-danger deleteBtn&quot;&gt;删除&lt;/button&gt;                                &lt;/td&gt;                            &lt;/tr&gt;                        &lt;/tbody&gt;                    &lt;/table&gt;                &lt;/div&gt;            &lt;/main&gt;            &lt;form id=&quot;deleteEmpForm&quot; method=&quot;post&quot;&gt;                &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;&gt;            &lt;/form&gt;        &lt;/div&gt;    &lt;/div&gt;    &lt;!-- Bootstrap core JavaScript================================================== --&gt;    &lt;!-- Placed at the end of the document so the pages load faster --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/jquery-3.2.1.slim.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/popper.min.js&quot;&gt;&lt;/script&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/bootstrap.min.js&quot;&gt;&lt;/script&gt;    &lt;!-- Icons --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/feather.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        feather.replace()    &lt;/script&gt;    &lt;script&gt;        $(&quot;.deleteBtn&quot;).click(function () {            // 删除当前员工的            $(&quot;#deleteEmpForm&quot;).attr(&quot;action&quot;,$(this).attr(&quot;del_uri&quot;)).submit();            return false;        })    &lt;/script&gt;    &lt;!-- Graphs --&gt;    &lt;script type=&quot;text/javascript&quot; src=&quot;asserts/js/Chart.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var ctx = document.getElementById(&quot;myChart&quot;);        var myChart = new Chart(ctx, {            type: &apos;line&apos;,            data: {                labels: [&quot;Sunday&quot;, &quot;Monday&quot;, &quot;Tuesday&quot;, &quot;Wednesday&quot;, &quot;Thursday&quot;, &quot;Friday&quot;, &quot;Saturday&quot;],                datasets: [{                    data: [15339, 21345, 18483, 24003, 23489, 24092, 12034],                    lineTension: 0,                    backgroundColor: &apos;transparent&apos;,                    borderColor: &apos;#007bff&apos;,                    borderWidth: 4,                    pointBackgroundColor: &apos;#007bff&apos;                }]            },            options: {                scales: {                    yAxes: [{                        ticks: {                            beginAtZero: false                        }                    }]                },                legend: {                    display: false,                }            }        });    &lt;/script&gt;&lt;/body&gt;</code></pre><p></p></html><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 错误处理原理&amp;定制错误页面</span><br><span class="line">### 1、SpringBoot默认的错误处理机制</span><br><span class="line">默认效果：  </span><br><span class="line">&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;(1)如果是浏览器，返回一个默认的错误页面；</span><br><span class="line">![SpringBoot默认错误页面](Spring-Boot与web开发/SpringBoot默认错误页面.png)</span><br><span class="line"></span><br><span class="line">浏览器发送请求的请求头</span><br><span class="line">![浏览器发送请求](Spring-Boot与web开发/浏览器发送请求.png)</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;(2)如果是其他客户端，默认响应一个json数据</span><br><span class="line">![客户端默认错误](Spring-Boot与web开发/客户端默认错误.png)</span><br><span class="line"></span><br><span class="line">![客户端发送请求](Spring-Boot与web开发/客户端发送请求.png)</span><br><span class="line"></span><br><span class="line">原理：  </span><br><span class="line">可以参照ErrorMvcAutoConfiguration；错误处理自动配置；  </span><br><span class="line">给容器中添加了以下组件：  </span><br><span class="line">（1）DefaultErrorAttributes：</span><br></pre></td></tr></table></figure><p></p><p>帮我们在页面共享信息  </p><pre><code>public Map&lt;String, Object&gt; getErrorAttributes(ServerRequest request, boolean includeStackTrace) {    Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap();    errorAttributes.put(&quot;timestamp&quot;, new Date());    errorAttributes.put(&quot;path&quot;, request.path());    Throwable error = this.getError(request);    HttpStatus errorStatus = this.determineHttpStatus(error);    errorAttributes.put(&quot;status&quot;, errorStatus.value());    errorAttributes.put(&quot;error&quot;, errorStatus.getReasonPhrase());    errorAttributes.put(&quot;message&quot;, this.determineMessage(error));    this.handleException(errorAttributes, this.determineException(error), includeStackTrace);    return errorAttributes;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）BasicErrorController:处理默认/error请求</span><br></pre></td></tr></table></figure><p>@Controller<br>@RequestMapping(“${server.error.path:${error.path:/error}}”)<br>public class BasicErrorController extends AbstractErrorController {<br>    @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) // 产生html类型的数据，浏览器发送的请求来到这里处理<br>    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) {<br>        HttpStatus status = getStatus(request);<br>        Map&lt;String, Object&gt; model = Collections<br>                .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));<br>        response.setStatus(status.value());</p><pre><code>    // 去哪个页面作为错误页面，包含页面地址和页面内容    ModelAndView modelAndView = resolveErrorView(request, response, status, model);    return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);}@RequestMapping // 产生其他数据，其他客户端发送的请求，在这里处理public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) {    Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));    HttpStatus status = getStatus(request);    return new ResponseEntity&lt;&gt;(body, status);}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（3）ErrorPageCustomizer</span><br></pre></td></tr></table></figure></p><pre><code>@Value(&quot;${error.path:/error}&quot;)private String path = &quot;/error&quot;; //系统出现错误之后，来到error请求进行处理</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（4）DefaultErrorViewResolver</span><br></pre></td></tr></table></figure><pre><code>@Overridepublic ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) {    ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);    if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) {        modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);    }    return modelAndView;}private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) {    //SpringBoot默认可以找到一个页面? error/404    String errorViewName = &quot;error/&quot; + viewName;    //模板引擎可以解析这个页面地址就用模板引擎解析    TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,            this.applicationContext);    if (provider != null) {        // 模板引擎可用的情况下返回到ModelAndView指定的视图地址        return new ModelAndView(errorViewName, model);    }    // 若模板引擎不可以用，则调用该方法，在静态资源文件夹下找errorViewName对应的页面 erro4/404.html    return resolveResource(errorViewName, model);}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">步骤：  </span><br><span class="line">一旦系统出现4xx或5xx之类的错误；ErrorPageCustomizer就会生效（定制错误的响应规则），就会来到/error请求，就会被**BasicErrorController**处理</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;(1)响应页面，去哪个页面是由**DefaultErrorViewResolver**解析得到的</span><br></pre></td></tr></table></figure><p>protected ModelAndView resolveErrorView(HttpServletRequest request, HttpServletResponse response, HttpStatus status,<br>        Map&lt;String, Object&gt; model) {<br>        // 所有的ErrorViewResolver得到ModelAndView<br>    for (ErrorViewResolver resolver : this.errorViewResolvers) {<br>        ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);<br>        if (modelAndView != null) {<br>            return modelAndView;<br>        }<br>    }<br>    return null;<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 2、如何定制错误页面</span><br><span class="line">- (1)如何定制错误的页面</span><br><span class="line">- （1）有模板引擎的情况下，error/状态码;【将错误页面命名为 错误状态码.html，放在模板引擎文件夹里面的error文件夹下】，发生此状态码的错误就会来到对应的页面；  </span><br><span class="line">可以使用4xx和5xx作为错误页面的文件名来匹配这种类型的所有错误，精确优先（优先寻找精确的状态码.html）;  </span><br><span class="line">页面能获取的信息</span><br><span class="line">- timestamp:时间戳</span><br><span class="line">- status：状态码</span><br><span class="line">- error：错误提示</span><br><span class="line">- exception：异常对象</span><br><span class="line">- message：异常消息</span><br><span class="line">- errors：JSR303数据校验的错误在这里</span><br><span class="line">- (2)没有模板引擎（模板引擎找不到这个错误页面），静态资源文件夹下找</span><br><span class="line">- （3）以上都没有错误页面，默认来到SpringBoot的默认错误页面</span><br><span class="line">- (2)如何定制错误的json数据</span><br><span class="line"></span><br><span class="line">## 定制错误数据</span><br><span class="line">接上面</span><br><span class="line">### 如何定制错误的json数据</span><br><span class="line">定义一个exception</span><br></pre></td></tr></table></figure></p><p>package com.usst.springboot04web.exception;</p><p>public class UserNotExistException extends RuntimeException {</p><pre><code>public UserNotExistException(){    super(&quot;用户不存在&quot;);}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">访问某个方法时，controller层进行调度</span><br></pre></td></tr></table></figure><pre><code>@ResponseBody@RequestMapping(&quot;/hello&quot;)public String hello(@RequestParam(&quot;user&quot;) String user){    if (user.equals(&quot;aaa&quot;)){        throw new UserNotExistException();    }    return &quot;hello world&quot;;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">下面采用自己定义的格式来显示页面上的内容</span><br><span class="line"></span><br><span class="line">（1）自定义异常处理&amp;返回定制json数据</span><br></pre></td></tr></table></figure><p>package com.usst.springboot04web.controller;</p><p>import com.usst.springboot04web.exception.UserNotExistException;<br>import org.springframework.web.bind.annotation.ControllerAdvice;<br>import org.springframework.web.bind.annotation.ExceptionHandler;<br>import org.springframework.web.bind.annotation.ResponseBody;</p><p>import java.util.HashMap;<br>import java.util.Map;</p><p>@ControllerAdvice<br>public class MyExceptionHandler {</p><pre><code>// 浏览器客户端返回的都是json@ResponseBody@ExceptionHandler(UserNotExistException.class)public Map&lt;String, Object&gt; handleException(Exception e){    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    map.put(&quot;code&quot;, &quot;user.notexist&quot;);    map.put(&quot;message&quot;, e.getMessage());    return map;}</code></pre><p>}</p><p>// 没有自适应效果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）转发到/error进行自适应响应效果处理</span><br></pre></td></tr></table></figure></p><pre><code>@ExceptionHandler(UserNotExistException.class)public String handleException(Exception e, HttpServletRequest request){    Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    // 传入自己的错误状态码,否则不会进入定制错误页面的解析流程    /**     * Integer statusCode = (Integer)request.getAttribute(&quot;javax.servlet.error.status_code&quot;)     */    request.setAttribute(&quot;javax.servlet.error.status_code&quot;, 500);    map.put(&quot;code&quot;, &quot;user.notexist&quot;);    map.put(&quot;message&quot;, e.getMessage());    // 转发到 /error    return &quot;forward:/error&quot;;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（3）将定制数据携带出去  </span><br><span class="line">出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据由getErrorAttributes得到的（是AbstractErrorController（ErrorController）规定的方法）；  </span><br><span class="line"></span><br><span class="line">a、编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</span><br><span class="line"></span><br><span class="line">b、页面上能用的数据，或者是json返回能用的数据都是通过errorAttributes.getErrorAttributes得到；  </span><br><span class="line">容器中DefaultErrorAttributes.getErrorAttributes();默认进行数据处理</span><br><span class="line"></span><br><span class="line">自定义</span><br></pre></td></tr></table></figure><p>package com.usst.springboot04web.commponent;</p><p>import org.springframework.boot.web.servlet.error.DefaultErrorAttributes;<br>import org.springframework.stereotype.Component;<br>import org.springframework.web.context.request.WebRequest;</p><p>import java.util.Map;</p><p>// 给容器加入自己定义的ErrorAttributes<br>@Component<br>public class MyErrorAttributes extends DefaultErrorAttributes {</p><pre><code>@Overridepublic Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) {    Map&lt;String, Object&gt; map = super.getErrorAttributes(webRequest, includeStackTrace);    map.put(&quot;company&quot;, &quot;usst&quot;);    return map;}</code></pre><p>}</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">最终效果：响应式自适应的，可以通过定制ErrorAttributes改变需要返回的内容。</span><br><span class="line"></span><br><span class="line">（好像第三步并没有效果。。。额。。。）</span><br><span class="line"></span><br><span class="line">## 嵌入式Servlet容器配置修改</span><br><span class="line">### 配置嵌入式Servlet容器</span><br><span class="line">SpringBoot默认使用的嵌入式容器是Servlet容器（Tomcat）</span><br><span class="line">![嵌入式默认配置容器](Spring-Boot与web开发/嵌入式默认配置容器.png)</span><br><span class="line"></span><br><span class="line">（1）如何定制和修改Servlet容器的相关配置；（ServerProperties【也是WebServerFactoryCustomizer\&lt;ConfigurableWebServerFactory&gt;】）</span><br><span class="line"></span><br><span class="line">- 修改和server有关的配置</span><br></pre></td></tr></table></figure><p>server.port=8081<br>server.context-path=/crud</p><p>server.tomcat.uri-encoding=UTF-8</p><p>// 通用的Servlet容器设置<br>server.xxx</p><p>// Tomcat的设置<br>server.tomcat.xxx<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 编写一个**WebServerFactoryCustomizer\&lt;ConfigurableWebServerFactory&gt;**：嵌入式的Servlet容器的定制器来修改Servlet容器的配置</span><br></pre></td></tr></table></figure></p><p>@Configuration<br>public class MyMvcConfig implements WebMvcConfigurer {</p><pre><code>//注意：SpringBoot1.x和2.x实现的方法有不同，这里展示的是2.x的方法@Beanpublic WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt; webServerFactoryCustomizer(){// 在WebServerFactoryCustomizer接口中使用ConfigurableWebServerFactory对象实现对customize()方法的转换，从而实现对嵌入式servlet容器的配置。    return new WebServerFactoryCustomizer&lt;ConfigurableWebServerFactory&gt;(){        // 定制嵌入式的Servlet容器相关的规则        @Override        public void customize(ConfigurableWebServerFactory factory) {            factory.setPort(8089);        }    };}</code></pre><p>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">（2）SpringBoot能否支持其他的Servlet容器</span><br><span class="line"></span><br><span class="line">在SpringBoot中也会有很多xxxCustomizer帮我们进行定制配置</span><br><span class="line"></span><br><span class="line">## 注册servlet三大组件</span><br><span class="line">Servlet、Filter、Listener</span><br><span class="line"></span><br><span class="line">由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet来启动SpringBoot的web应用，没有web.xml文件。</span><br><span class="line"></span><br><span class="line">（1）注册三大组件需要用以下方式：</span><br><span class="line"></span><br><span class="line">- ServletRegistrationBean</span><br></pre></td></tr></table></figure></p><pre><code>// 注册三大组件@Beanpublic ServletRegistrationBean myServlet(){    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(), &quot;/myServlet&quot;);    return registrationBean;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- FilterRegistrationBean</span><br></pre></td></tr></table></figure><pre><code>@Beanpublic FilterRegistrationBean myFilter(){    FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean();    filterRegistrationBean.setFilter(new MyFilter());    filterRegistrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;, &quot;/myServlet&quot;));    return filterRegistrationBean;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ServletListenerRegistrationBean</span><br></pre></td></tr></table></figure><pre><code>@Beanpublic ServletListenerRegistrationBean myListener(){    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean =            new ServletListenerRegistrationBean&lt;MyListener&gt;(new MyListener());    return registrationBean;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">SpringBoot帮我们自动注册SpringMVC的时候，自动注册SpringMVC的前端控制器，DispatcherServlet；</span><br></pre></td></tr></table></figure><pre><code>@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)public DispatcherServletRegistrationBean dispatcherServletRegistration(DispatcherServlet dispatcherServlet) {    DispatcherServletRegistrationBean registration = new DispatcherServletRegistrationBean(dispatcherServlet,            this.webMvcProperties.getServlet().getPath());    // 默认拦截器： / 所有请求；包括静态资源，但是不拦截jsp请求  /* 会拦截jsp    // 可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径    registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);    registration.setLoadOnStartup(this.webMvcProperties.getServlet().getLoadOnStartup());    if (this.multipartConfig != null) {        registration.setMultipartConfig(this.multipartConfig);    }    return registration;}</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">（2）SpringBoot能不能支持其他的Servlet容器</span><br><span class="line"></span><br><span class="line">## 切换其他嵌入式Servlet容器</span><br><span class="line">### 使用其他Servlet容器</span><br><span class="line">![默认支持的Servlet容器](Spring-Boot与web开发/默认支持的Servlet容器.png)</span><br><span class="line"></span><br><span class="line">SpringBoot默认可以切换这两种容器</span><br><span class="line"></span><br><span class="line">- Jetty：开发长连接的应用，如：聊天</span><br><span class="line">- Undertow（不支持JSP）：高性能的非阻塞的Servlet容器，并发性能很好</span><br><span class="line"></span><br><span class="line">删除Tomcat依赖之后，引入Jetty依赖，同样的，引入undertow的操作也是类似的</span><br></pre></td></tr></table></figure><pre><code>&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;exclusion&gt;            &lt;artifactId&gt;org.springframeword.boot&lt;/artifactId&gt;            &lt;groupId&gt;spring-starter-tomcat&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入其他Servlet容器--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 嵌入式Servlet容器自动配置原理</span><br><span class="line">EmbeddedWebServerFactoryCustomizerAutoConfiguration嵌入式的Servlet容器自动配置</span><br></pre></td></tr></table></figure><p>@Configuration<br>@ConditionalOnWebApplication<br>@EnableConfigurationProperties(ServerProperties.class)<br>public class EmbeddedWebServerFactoryCustomizerAutoConfiguration {</p><pre><code>@Configuration// 当前是否引入了Tomcat依赖@ConditionalOnClass({ Tomcat.class, UpgradeProtocol.class })public static class TomcatWebServerFactoryCustomizerConfiguration {    @Bean    public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment,            ServerProperties serverProperties) {        return new TomcatWebServerFactoryCustomizer(environment, serverProperties);    }}</code></pre><p>}</p><p>// 配置嵌入式的容器工厂<br><code>`</code></p><p>SpringBoot1.x的处理方式和SpringBoot2.x的处理方式有很大的不同</p><p>步骤：<br>（1）SpringBoot根据导入的依赖情况，给容器中添加相应的容器，比如：【TomcatWebServerFactoryCustomizer】<br>（2）创建出一个TomcatWebServerFactoryCustomizer，在这个类中调用自己定制的方法</p><p>原理可以参考这个博客：<a href="https://www.jianshu.com/p/017a7f40efff" target="_blank" rel="noopener">Spring Boot 2.0.2 版本嵌入式Servlet容器自动配置及启动原理分析</a></p><p>1、Spring Boot 根据导入的依赖信息，自动创建对应的web服务工厂定制器；<br>2、web服务工厂定制器组件的后置处理器获取所有类型为web服务工厂定制器的组件（包含实现WebServerFactoryCustomizer接口，自定义的定制器组件），依次调用customize()定制接口，定制Servlet容器配置；<br>3、嵌入式的Servlet容器工厂创建tomcat容器，初始化并启动容器。</p><h2 id="嵌入式Servlet容器启动原理"><a href="#嵌入式Servlet容器启动原理" class="headerlink" title="嵌入式Servlet容器启动原理"></a>嵌入式Servlet容器启动原理</h2><p>SpringBoot的版本是1.xxx的嵌入式Servlet容器启动原理</p><p>什么时候创建嵌入式Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat</p><p>获取嵌入式的Servlet容器工厂；<br>（1）SpringBoot应用启动运行Run方法<br>（2）refreshContext(context):SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是Web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong><br>（3）refresh(context):刷新刚才创建好的IOC容器<br>（4）onRefresh():web的IOC容器重写了onRefresh方法<br>（5）webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();<br>（6）获取嵌入式的Servlet容器工厂：<br>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p><p>从IOC容器中获取EmbeddedServletContainerFactory组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器是这个对象，就获取所有的定制器来定制Servlet容器的相关配置；<br>（7）<strong>使用容器工厂获取嵌入式的Servlet容器</strong><br>（8）嵌入式的Servlet容器创建对象并启动Servlet容器；</p><p><strong>先启动嵌入式的Servlet容器，再将IOC容器中剩下没有创建出的对象获取出来</strong>；</p><p><strong>IOC容器启动创建嵌入式的Servlet容器</strong></p><h2 id="使用外部Servlet容器-amp-JSP支持"><a href="#使用外部Servlet容器-amp-JSP支持" class="headerlink" title="使用外部Servlet容器&amp;JSP支持"></a>使用外部Servlet容器&amp;JSP支持</h2><h3 id="嵌入式Servlet容器："><a href="#嵌入式Servlet容器：" class="headerlink" title="嵌入式Servlet容器："></a>嵌入式Servlet容器：</h3><p>应用打成可执行的jar</p><p>优点：简单、便携；<br>缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义】，自己编写嵌入式Servlet容器工厂）</p><h3 id="外置的Servlet容器"><a href="#外置的Servlet容器" class="headerlink" title="外置的Servlet容器"></a>外置的Servlet容器</h3><p>外面安装Tomcat — 应用war包的方式打包；  </p><p>步骤：  </p><ul><li>1、必须创建一个war项目；</li><li>2、将嵌入式的Tomcat指定为provided；</li><li>3、必须编写一个SpringBootInitializer的子类，并调用configure方法</li><li>4、启动服务器就可以使用了</li></ul><h2 id="使用外部Servlet容器启动SpringBoot应用原理"><a href="#使用外部Servlet容器启动SpringBoot应用原理" class="headerlink" title="使用外部Servlet容器启动SpringBoot应用原理"></a>使用外部Servlet容器启动SpringBoot应用原理</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jar包：执行SpringBoot主类的Main方法，启动IOC容器，创建嵌入式的Servlet容器；</p><p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>[SpringBootIntializer]，启动IOC容器；</p><p>Servlet3.0（Spring注解版）【一个文档】：<br>8.2.4 Shared libraries / runtimes pluggability:</p><p>规则：</p><ul><li>（1）服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletConatinerInitializer实例；</li><li>（2）ServletConatinerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletConatinerInitializer的实现类的全类名。</li><li>（3）还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</li></ul><p>流程：</p><ul><li>（1）启动Tomcat</li><li>（2）ServletConatinerInitializer：Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></li><li>（3）ServletConatinerInitializer将HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set集合中\&lt;Class&lt;?&gt;&gt;；为WebApplicationInitializer类型的类创建实例；</li><li>（4）每一个WebApplicationInitializer都调用自己的onStartup方法；<br><img src="/2019/07/15/Spring-Boot与Web开发/WebApplicationInitializer的实现.png" alt="WebApplicationInitializer的实现"></li><li>（5）相当于我们的SpringBootInitializer的类会被创建对象，并执行onStartup方法</li><li>（6）SpringBootInitializer执行onStartup的时候会createRootApplicationContext，创建容器</li><li>（7）Spring的应用就启动并且创建IOC容器</li></ul><p>启动Servlet容器，再启动SpringBoot应用</p></department></department></department>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot-web开发&quot;&gt;&lt;a href=&quot;#SpringBoot-web开发&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot-web开发&quot;&gt;&lt;/a&gt;SpringBoot-web开发&lt;/h1&gt;&lt;h2 id=&quot;简介&quot;&gt;&lt;a hr
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="spring boot" scheme="http://blog.letmefly.cc/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot与日志</title>
    <link href="http://blog.letmefly.cc/2019/07/14/Spring-Boot%E4%B8%8E%E6%97%A5%E5%BF%97/"/>
    <id>http://blog.letmefly.cc/2019/07/14/Spring-Boot与日志/</id>
    <published>2019-07-14T03:03:07.000Z</published>
    <updated>2019-07-14T12:29:27.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-Boot与日志"><a href="#Spring-Boot与日志" class="headerlink" title="Spring Boot与日志"></a>Spring Boot与日志</h1><h2 id="日志框架和分类选择"><a href="#日志框架和分类选择" class="headerlink" title="日志框架和分类选择"></a>日志框架和分类选择</h2><h3 id="1、日志框架"><a href="#1、日志框架" class="headerlink" title="1、日志框架"></a>1、日志框架</h3><p>市面上的日志框架：JUL、JCL、Jboss-logging、logback、log4j、log4j2、slf4j</p><table><thead><tr><th>日志门面(日志的抽象层)</th><th>日志实现</th></tr></thead><tbody><tr><td>JCL(Jakarta Commons  Logging)、 SLF4j(Simple Logging Facade for java)、 jboss-logging</td><td>Log4j、JUL(java.util.logging)、Log4j2、Logback</td></tr></tbody></table><p>左边选一个门面（抽象层），右边选一个实现<br>日志门面：选择SLF4j，<br>日志实现：Logback</p><ul><li>Spring Boot：底层是Spring框架，Spring框架默认是用JCL；<ul><li><strong>Spring Boot选用SLF4j和logback</strong></li></ul></li></ul><h2 id="slf4j使用原理"><a href="#slf4j使用原理" class="headerlink" title="slf4j使用原理"></a>slf4j使用原理</h2><h3 id="2、如何在系统中使用SLF4j"><a href="#2、如何在系统中使用SLF4j" class="headerlink" title="2、如何在系统中使用SLF4j"></a>2、如何在系统中使用SLF4j</h3><p>以后开发的时候，日志记录方法的调用，不应该直接调用日志的实现类，而是调用日志抽象层里面的方法；</p><p>应该给系统导入slf4j的jar和logback的实现jar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line">public class HelloWorld &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    Logger logger = LoggerFactory.getLogger(HelloWorld.class);</span><br><span class="line">    logger.info(&quot;Hello World&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/07/14/Spring-Boot与日志/slf4j原理.jpg" alt="slf4j原理"><br>每一个日志的实现框架都有自己的配置文件。使用slf4j以后，<strong>配置文件还是做成日志实现自己本身的配置文件；</strong></p><h2 id="SpringBoot日志-转换为slf4j"><a href="#SpringBoot日志-转换为slf4j" class="headerlink" title="SpringBoot日志-转换为slf4j"></a>SpringBoot日志-转换为slf4j</h2><p>A系统（slf4j+logback）：Spring、Hibernate、MyBatis、xxx</p><p>统一日志记录，即使是别的框架也可以一起使用slf4j进行输出</p><p>如何让系统中的所有日志都统一到slf4j？  </p><ul><li>1、将系统中其他日志框架排除出去；</li><li>2、用中间包来替换原有的日志框架；</li><li>3、导入slf4j其他的实现</li></ul><h2 id="SpringBoot日志关系"><a href="#SpringBoot日志关系" class="headerlink" title="SpringBoot日志关系"></a>SpringBoot日志关系</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>Spring Boot中使用它来做日志功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-logging&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;compile&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>底层依赖关系：<br><img src="/2019/07/14/Spring-Boot与日志/slf4j底层依赖关系.jpg" alt="slf4j底层依赖关系"><br>（1）Spring Boot底层也是使用slf4j+logback的方式进行日志记录<br>（2）Spring Boot也把其他的日志都替换成了slf4j<br>（3）中间替换包，把其他的日志转换为slf4j的日志<br>（4）如果我们引入了其他框架，一定要把这个框架的默认日志依赖移除掉   </p><font color="blue"><strong>SpringBoot能自动适配所有的日志，底层使用slf4j+logback的方式记录日志，我们唯一要做的是，引入其他框架的时候，只需要把这个框架依赖的日志移除掉；</strong></font><h2 id="SpringBoot默认日志配置"><a href="#SpringBoot默认日志配置" class="headerlink" title="SpringBoot默认日志配置"></a>SpringBoot默认日志配置</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 记录器</span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void contextLoads() &#123;</span><br><span class="line">    System.out.println(person.toString());</span><br><span class="line"></span><br><span class="line">    // 日志的级别</span><br><span class="line">    // 由低到高  trace&lt;debug&lt;info&lt;warn&lt;error</span><br><span class="line">    // 可以调整需要输出的日志级别：日志就只会在这个级别以及比他高的级别生效</span><br><span class="line">    logger.trace(&quot;这是trace日志...&quot;);</span><br><span class="line">    logger.debug(&quot;这是debug日志...&quot;);</span><br><span class="line">    // SpringBoot默认使用的是info级别的日志信息,root级别</span><br><span class="line">    logger.info(&quot;这是info日志...&quot;);</span><br><span class="line">    logger.warn(&quot;这是warn日志...&quot;);</span><br><span class="line">    logger.error(&quot;这是error日志...&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志输出格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">日志输出格式：</span><br><span class="line">%d表示日期时间</span><br><span class="line">%thread表示线程名</span><br><span class="line">%-5level：级别从左显示5个字符宽度</span><br><span class="line">%logger(50):表示logger名字最长50个字符，否则按照句点分割</span><br><span class="line">%msg：日志消息</span><br><span class="line">%n：换行符</span><br></pre></td></tr></table></figure><p>SpringBoot修改日志的默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">logging.level.com.usst.springboot02config=trace</span><br><span class="line"># 不指定路径，在当前项目下生成springboot.log日志</span><br><span class="line"># 也可以指定完整的路径，</span><br><span class="line"># logging.file=springboot.log</span><br><span class="line"></span><br><span class="line"># 在当前磁盘的根路径下创建spring文件夹和里面的log文件，使用spring.log作为默认文件</span><br><span class="line">logging.path=/spring/log</span><br><span class="line"></span><br><span class="line"># 在控制台输出的日志的格式</span><br><span class="line">logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span><br><span class="line"></span><br><span class="line"># 指定文件中日志输出的格式</span><br><span class="line">logging.pattern.file=</span><br></pre></td></tr></table></figure><h2 id="指定日志文件和日志profile功能"><a href="#指定日志文件和日志profile功能" class="headerlink" title="指定日志文件和日志profile功能"></a>指定日志文件和日志profile功能</h2><h3 id="指定配置"><a href="#指定配置" class="headerlink" title="指定配置"></a>指定配置</h3><p>给类路径下放上每个日志框架自己的配置文件即可；SpringBoot就不使用其默认的配置了。</p><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td>logback-spring.xml, logback-spring.groovy, logback.xml or logback.groovy</td></tr><tr><td>Log4j2</td><td>log4j2-spring.xml or log4j2.xml</td></tr><tr><td>JDK(Java Util Logging)</td><td>logging.properties</td></tr></tbody></table><p>logback.xml：直接就被日志框架识别了<br>logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot来解析日志配置，可以使用SpringBoot的高级Profile功能</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;springProfile name=&quot;staging&quot;&gt;</span><br><span class="line">可以指定某段配置只在某个环境下生效</span><br><span class="line">&lt;/springProfile&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring-Boot与日志&quot;&gt;&lt;a href=&quot;#Spring-Boot与日志&quot; class=&quot;headerlink&quot; title=&quot;Spring Boot与日志&quot;&gt;&lt;/a&gt;Spring Boot与日志&lt;/h1&gt;&lt;h2 id=&quot;日志框架和分类选择&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="spring boot" scheme="http://blog.letmefly.cc/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot配置</title>
    <link href="http://blog.letmefly.cc/2019/07/11/SpringBoot%E9%85%8D%E7%BD%AE/"/>
    <id>http://blog.letmefly.cc/2019/07/11/SpringBoot配置/</id>
    <published>2019-07-11T12:38:06.000Z</published>
    <updated>2019-07-14T03:02:43.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot配置"><a href="#SpringBoot配置" class="headerlink" title="SpringBoot配置"></a>SpringBoot配置</h1><h2 id="YAML简介"><a href="#YAML简介" class="headerlink" title="YAML简介"></a>YAML简介</h2><ul><li>Spring Boot使用一个全局的配置文件，配置文件名是固定的<ul><li>application.properties</li><li>application.yaml</li></ul></li><li>配置文件的作用：修改SpringBoot自动配置的默认值；</li><li>配置文件放在<font color="red">src/main/resources目录</font>或者<font color="red">类路径/config下</font></li><li>.yml是YAML(YAML isn’t Markup Language)语言文件，<font color="red">以数据为中心</font>，比json、xml等更适合做配置文件<ul><li><a href="http://www.yaml.org/参考语法规范" target="_blank" rel="noopener">http://www.yaml.org/参考语法规范</a></li></ul></li><li>全局配置文件的可以对一些默认配置进行修改</li></ul><p>以前的配置文件：大多数都是xxx.xml</p><p>YAML的配置方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br></pre></td></tr></table></figure><p>XML的配置方式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;server&gt;</span><br><span class="line">&lt;port&gt;8081&lt;/port&gt;</span><br><span class="line">&lt;/server&gt;</span><br></pre></td></tr></table></figure><h2 id="YAML语法"><a href="#YAML语法" class="headerlink" title="YAML语法"></a>YAML语法</h2><h3 id="YAML基本语法"><a href="#YAML基本语法" class="headerlink" title="YAML基本语法"></a>YAML基本语法</h3><ul><li>使用缩进表示层级关系；</li><li>缩进时不允许使用Tab键，只允许使用空格；</li><li><p>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p><p>  以空格的缩进来控制层级关系，只要是左对齐的一列数据，都是同一个层级的</p></li><li><p>属性和值都是大小写敏感的</p></li></ul><h3 id="YAML支持的三种数据结构（值的写法）"><a href="#YAML支持的三种数据结构（值的写法）" class="headerlink" title="YAML支持的三种数据结构（值的写法）"></a>YAML支持的三种数据结构（值的写法）</h3><ul><li>字面量：单个的、不可再分的值</li><li>对象：键值对的集合（key: value:表示一对键值对）</li><li>数组：一组按次序排列的值</li></ul><p>字面量：普通的值(数字、字符串、布尔)<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;字符串默认不用加上单引号或双引号；<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;“”：双引号：不会转义字符串里面的特殊字符，特殊字符会作为本身想要表示的意思：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;name：”zhangsan \n list”:输出的是：zhangsan 换行 list<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;’’：单引号：会转义字符串里面的特殊字符，特殊字符最终只是一个普通的字符串数量：<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;name：”zhangsan \n list”:输出的是：zhangsan \n list</p><p>对象：Map（属性和值）（键值对）<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;k: v</p><p>数组（List、Set）<br>&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;用短横线（-）来表示数组中的一个元素</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pets:  </span><br><span class="line"> - cat</span><br><span class="line"> - dog</span><br><span class="line"> - pig</span><br></pre></td></tr></table></figure><h2 id="获取配置文件值-配置文件值注入"><a href="#获取配置文件值-配置文件值注入" class="headerlink" title="获取配置文件值(配置文件值注入)"></a>获取配置文件值(配置文件值注入)</h2><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">person:</span><br><span class="line">  lastName: zhangsan</span><br><span class="line">  age: 16</span><br><span class="line">  boss: false</span><br><span class="line">  birth: 2018/12/13</span><br><span class="line">  maps: &#123;k1: v1, k2: 12&#125;</span><br><span class="line">  lists:</span><br><span class="line">   - lisi</span><br><span class="line">   - zhaoliu</span><br><span class="line">  dog:</span><br><span class="line">   name: 小狗</span><br><span class="line">   age: 2</span><br></pre></td></tr></table></figure><p>JavaBean：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot02config.bean;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将配置文件中配置的每一个属性的值，</span><br><span class="line"> * 映射到这个组件中</span><br><span class="line"> *</span><br><span class="line"> * @ConfigurationProperties: 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定</span><br><span class="line"> *      prefix = &quot;person&quot;,配置文件中哪个下面的所有属性进行一一映射</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 只有这个组件是容器的组件，才能使用容器提供的@configurationProperties功能</span><br><span class="line"> */</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    private boolean boss;</span><br><span class="line"></span><br><span class="line">    private Date birth;</span><br><span class="line"></span><br><span class="line">    private Map&lt;String, Object&gt; maps;</span><br><span class="line"></span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line"></span><br><span class="line">    private Dog dog;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;lastName=&apos;&quot; + lastName + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, boss=&quot; + boss +</span><br><span class="line">                &quot;, brith=&quot; + birth +</span><br><span class="line">                &quot;, maps=&quot; + maps +</span><br><span class="line">                &quot;, lists=&quot; + lists +</span><br><span class="line">                &quot;, dog=&quot; + dog +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isBoss() &#123;</span><br><span class="line">        return boss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBoss(boolean boss) &#123;</span><br><span class="line">        this.boss = boss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirth() &#123;</span><br><span class="line">        return birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirth(Date brith) &#123;</span><br><span class="line">        this.birth = brith;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; getMaps() &#123;</span><br><span class="line">        return maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaps(Map&lt;String, Object&gt; maps) &#123;</span><br><span class="line">        this.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; getLists() &#123;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLists(List&lt;Object&gt; lists) &#123;</span><br><span class="line">        this.lists = lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Dog getDog() &#123;</span><br><span class="line">        return dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDog(Dog dog) &#123;</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以导入配置文件处理器，以后编写配置会有提示(虽然，我感觉并没有起效果，但是是官方推荐的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入配置文件--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;optional&gt;true&lt;/optional&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>test文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot02config;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot02config.bean.Person;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.boot.test.context.SpringBootTest;</span><br><span class="line">import org.springframework.test.context.junit4.SpringRunner;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * SpringBoot单元测试</span><br><span class="line"> *</span><br><span class="line"> * 可以在测试期间很方便的类似编码一样，进行自动注入的功能</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringBoot02ConfigApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    Person person;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void contextLoads() &#123;</span><br><span class="line">        System.out.println(person.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot配置-properties配置文件编码问题"><a href="#SpringBoot配置-properties配置文件编码问题" class="headerlink" title="SpringBoot配置-properties配置文件编码问题"></a>SpringBoot配置-properties配置文件编码问题</h2><p>application.properties文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 默认idea使用的是utf-8编码</span><br><span class="line"># 配置person的值</span><br><span class="line">person.last-name=张三</span><br><span class="line">person.age=18</span><br><span class="line">person.birth=2017/12/17</span><br><span class="line">person.boss=false</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=v2</span><br><span class="line">person.dog.name=dog</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure><p>修改idea中的file-》settings-》file encoding-》将Properties Files (*.properties)下的Default encoding for properties files设置为UTF-8，将Transparent native-to-ascii conversion前的勾选上。</p><font color="red">配置完成后一定要重新新建一个application.properties </font><p>即可解决乱码问题</p><h2 id="SpringBoot配置-Configuration与-Value的区别"><a href="#SpringBoot配置-Configuration与-Value的区别" class="headerlink" title="SpringBoot配置-@Configuration与@Value的区别"></a>SpringBoot配置-@Configuration与@Value的区别</h2><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>功能</td><td>批量注入配置文件中的属性</td><td>@一个个指定</td></tr><tr><td>松散语法绑定</td><td>支持</td><td>不支持</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>JSR303数据校验</td><td>支持</td><td>不支持</td></tr><tr><td>复杂类型封装</td><td>支持</td><td>不支持</td></tr></tbody></table><p>配置文件无论是yml还是Properties都能获取到值</p><p>如果只是在某个业务逻辑中获取配置文件中的某项值，我们就是用@Value；</p><p>如果我们专门编写了一个JavaBean和配置文件进行映射，就直接使用@ConfigurationProperties；</p><h2 id="配置文件注入值数据校验"><a href="#配置文件注入值数据校验" class="headerlink" title="配置文件注入值数据校验"></a>配置文件注入值数据校验</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line">//@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">//@Validated //和@Email搭配使用，做JSR303校验</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类似于</span><br><span class="line">     * &lt;bean class=&quot;Person&quot;&gt;</span><br><span class="line">     *  &lt;property name=&quot;lastName&quot; value=&quot;?&quot;&gt;&lt;/property&gt;</span><br><span class="line">     * &lt;/bean&gt;</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;person.last-name&#125;&quot;)</span><br><span class="line">//    @Email:lastName必须是一个邮箱格式</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;#&#123;11 * 2&#125;&quot;)</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;true&quot;)</span><br><span class="line">    private boolean boss;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="PropertySource-ImportResource-Bean"><a href="#PropertySource-ImportResource-Bean" class="headerlink" title="@PropertySource,@ImportResource,@Bean"></a>@PropertySource,@ImportResource,@Bean</h2><h3 id="PropertySource-加载指定的配置文件："><a href="#PropertySource-加载指定的配置文件：" class="headerlink" title="@PropertySource:加载指定的配置文件："></a>@PropertySource:加载指定的配置文件：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot02config.bean;</span><br><span class="line"></span><br><span class="line">import org.springframework.beans.factory.annotation.Value;</span><br><span class="line">import org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class="line">import org.springframework.context.annotation.PropertySource;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import org.springframework.validation.annotation.Validated;</span><br><span class="line"></span><br><span class="line">import javax.validation.constraints.Email;</span><br><span class="line">import java.util.Date;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.Map;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 将配置文件中配置的每一个属性的值，</span><br><span class="line"> * 映射到这个组件中</span><br><span class="line"> *</span><br><span class="line"> * @ConfigurationProperties: 告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定</span><br><span class="line"> *      prefix = &quot;person&quot;,配置文件中哪个下面的所有属性进行一一映射，</span><br><span class="line"> *</span><br><span class="line"> *</span><br><span class="line"> * 只有这个组件是容器的组件，才能使用容器提供的@configurationProperties功能</span><br><span class="line"> * @ConfigurationProperties(prefix = &quot;person&quot;) 默认从全局配置文件中获取值</span><br><span class="line"> */</span><br><span class="line">@PropertySource(value = &quot;classpath:person.properties&quot;)</span><br><span class="line">@Component</span><br><span class="line">@ConfigurationProperties(prefix = &quot;person&quot;)</span><br><span class="line">//@Validated //和@Email搭配使用，做JSR303校验</span><br><span class="line">public class Person &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 类似于</span><br><span class="line">     * &lt;bean class=&quot;Person&quot;&gt;</span><br><span class="line">     *  &lt;property name=&quot;lastName&quot; value=&quot;?&quot;&gt;&lt;/property&gt;</span><br><span class="line">     * &lt;/bean&gt;</span><br><span class="line">     */</span><br><span class="line">    @Value(&quot;$&#123;person.last-name&#125;&quot;)</span><br><span class="line">//    @Email:lastName必须是一个邮箱格式</span><br><span class="line">    private String lastName;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;#&#123;11 * 2&#125;&quot;)</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;true&quot;)</span><br><span class="line">    private boolean boss;</span><br><span class="line"></span><br><span class="line">    private Date birth;</span><br><span class="line"></span><br><span class="line">//    @Value(&quot;$&#123;person.maps&#125;&quot;)</span><br><span class="line">    private Map&lt;String, Object&gt; maps;</span><br><span class="line"></span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line"></span><br><span class="line">    private Dog dog;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person&#123;&quot; +</span><br><span class="line">                &quot;lastName=&apos;&quot; + lastName + &apos;\&apos;&apos; +</span><br><span class="line">                &quot;, age=&quot; + age +</span><br><span class="line">                &quot;, boss=&quot; + boss +</span><br><span class="line">                &quot;, brith=&quot; + birth +</span><br><span class="line">                &quot;, maps=&quot; + maps +</span><br><span class="line">                &quot;, lists=&quot; + lists +</span><br><span class="line">                &quot;, dog=&quot; + dog +</span><br><span class="line">                &apos;&#125;&apos;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName = lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean isBoss() &#123;</span><br><span class="line">        return boss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBoss(boolean boss) &#123;</span><br><span class="line">        this.boss = boss;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Date getBirth() &#123;</span><br><span class="line">        return birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBirth(Date brith) &#123;</span><br><span class="line">        this.birth = brith;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Map&lt;String, Object&gt; getMaps() &#123;</span><br><span class="line">        return maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMaps(Map&lt;String, Object&gt; maps) &#123;</span><br><span class="line">        this.maps = maps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public List&lt;Object&gt; getLists() &#123;</span><br><span class="line">        return lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLists(List&lt;Object&gt; lists) &#123;</span><br><span class="line">        this.lists = lists;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Dog getDog() &#123;</span><br><span class="line">        return dog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setDog(Dog dog) &#123;</span><br><span class="line">        this.dog = dog;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ImportResource-导入Spring的配置文件，让配置文件里面的内容生效"><a href="#ImportResource-导入Spring的配置文件，让配置文件里面的内容生效" class="headerlink" title="@ImportResource:导入Spring的配置文件，让配置文件里面的内容生效"></a>@ImportResource:导入Spring的配置文件，让配置文件里面的内容生效</h3><p>Spring Boot中没有Spring的配置文件，自己编写的配置文件不能自动识别，如果要让Spring的配置文件生效，加载进来，需要使用：@”ImportResource”标注一个配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@ImportResource(locations = &quot;classpath:beans.xml&quot;)</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringBoot02ConfigApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringBoot02ConfigApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入Spring的配置文件，让其生效</p><p>xml文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;</span><br><span class="line">    &lt;bean id=&quot;helloService&quot; class=&quot;com.usst.springboot02config.service.HelloService&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>但是上述方式不推荐使用</p><h3 id="Spring-Boot中推荐使用给容器中添加组件的方式："><a href="#Spring-Boot中推荐使用给容器中添加组件的方式：" class="headerlink" title="Spring Boot中推荐使用给容器中添加组件的方式："></a>Spring Boot中推荐使用给容器中添加组件的方式：</h3><p>Spring Boot推荐使用全注解的方式</p><p>1、配置类=====Spring配置文件</p><p>2、使用@Bean给容器添加组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.springboot02config.config;</span><br><span class="line"></span><br><span class="line">import com.usst.springboot02config.service.HelloService;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 指明当前类是一个配置类</span><br><span class="line"> * 配置类就是来替代之前的Spring配置文件</span><br><span class="line"> *</span><br><span class="line"> * 配置文件中使用&lt;bean&gt;&lt;/bean&gt;标签添加组件</span><br><span class="line"> */</span><br><span class="line">@Configuration</span><br><span class="line">public class MyAppConfig &#123;</span><br><span class="line"></span><br><span class="line">    // 将方法的返回值，添加到容器中</span><br><span class="line">    // 容器中组件默认的id就是方法名</span><br><span class="line">    @Bean</span><br><span class="line">    public HelloService helloService()&#123;</span><br><span class="line">        System.out.println(&quot;配置类@Bean给他添加组件&quot;);</span><br><span class="line">        return new HelloService();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SpringBoot配置-配置文件占位符"><a href="#SpringBoot配置-配置文件占位符" class="headerlink" title="SpringBoot配置-配置文件占位符"></a>SpringBoot配置-配置文件占位符</h2><h3 id="随机数"><a href="#随机数" class="headerlink" title="随机数"></a>随机数</h3><p>RandomValuePropertySource：配置文件中可以使用随机数</p><ul><li>${random.value}、${random.int}、${random.long}</li><li>${random.int(10)}、${random.int[1024,65536]}</li></ul><h3 id="属性配置占位符"><a href="#属性配置占位符" class="headerlink" title="属性配置占位符"></a>属性配置占位符</h3><p>占位符获取之前配置的值，如果没有，则使用默认的值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 默认idea使用的是utf-8编码</span><br><span class="line"># 配置person的值</span><br><span class="line">person.last-name=张三$&#123;random.uuid&#125;</span><br><span class="line">person.age=$&#123;random.int&#125;</span><br><span class="line">person.birth=2017/12/17</span><br><span class="line">person.boss=false</span><br><span class="line">person.lists=a,b,c</span><br><span class="line">person.maps.k1=v1</span><br><span class="line">person.maps.k2=v2</span><br><span class="line"># 这里没有配置过person.hello,使用：后面的hello作为默认值</span><br><span class="line">person.dog.name=$&#123;person.hello:hello&#125;---dog</span><br><span class="line">person.dog.age=15</span><br></pre></td></tr></table></figure><p>========我是华丽的分割线===============================</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.name=MyApp</span><br><span class="line">app.description=$&#123;app.name&#125; is a Spring Boot application</span><br></pre></td></tr></table></figure><ul><li>可以在配置文件中引用前面配置过的属性(优先级前面配置过的这里都可以使用)</li><li>${app.name:默认值}来指定找不到属性时的默认值</li></ul><h2 id="SpringBoot配置-Profile多环境支持"><a href="#SpringBoot配置-Profile多环境支持" class="headerlink" title="SpringBoot配置-Profile多环境支持"></a>SpringBoot配置-Profile多环境支持</h2><h3 id="多Profile文件"><a href="#多Profile文件" class="headerlink" title="多Profile文件"></a>多Profile文件</h3><p>在主配置文件编写的时候，文件名可以是：application-{profile}.properties/yml</p><p>默认使用的是applicaiton.properties文件</p><h3 id="yml支持多文档块方式"><a href="#yml支持多文档块方式" class="headerlink" title="yml支持多文档块方式"></a>yml支持多文档块方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8081</span><br><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: dev</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8082</span><br><span class="line">spring:</span><br><span class="line">  profiles: dev</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8083</span><br><span class="line">spring:</span><br><span class="line">  profiles: prod</span><br></pre></td></tr></table></figure><h3 id="激活指定profile"><a href="#激活指定profile" class="headerlink" title="激活指定profile"></a>激活指定profile</h3><p>1、在配置文件(application.properties)中指定Spring.profiles.active=dev</p><p>2、命令行：</p><ul><li><code>--spring.profiles.active=dev</code></li><li><code>java -jar spring-boot02-config-0.0.1-SNAPSHOT.jar --spring.profiles.active=dev</code><br>可以直接在测试的时候，配置传入命令行参数</li></ul><p>3、虚拟机参数：</p><p><code>-Dspring.profiles.active=dev</code></p><h2 id="SpringBoot配置-配置文件加载顺序"><a href="#SpringBoot配置-配置文件加载顺序" class="headerlink" title="SpringBoot配置-配置文件加载顺序"></a>SpringBoot配置-配置文件加载顺序</h2><p>SpringBoot启动会扫描以下位置的application.properties或者application.yml文件作为Spring Boot的默认配置文件</p><ul><li>file:../config/</li><li>file:../</li><li>classpath:/config/</li><li>classpath:/</li></ul><p>优先级由高到低，高优先级的配置会覆盖低优先级的配置；</p><p>Spring Boot会从这四个位置全部加载主配置文件；<strong>互补配置</strong></p><p>也可以通过配置spring.config.location来改变默认的配置文件位置</p><p>项目打包好以后，可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置，指定的配置文件和默认加载的配置文件会共同起作用，形成互补配置</p><h2 id="SpringBoot配置-外部配置加载顺序"><a href="#SpringBoot配置-外部配置加载顺序" class="headerlink" title="SpringBoot配置-外部配置加载顺序"></a>SpringBoot配置-外部配置加载顺序</h2><p>Spring Boot也可以从以下配置加载配置；按照优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置</p><ul><li>1、<strong>命令行参数</strong>多个配置用空格分开；–配置项=值  <code>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar --server.port=8087 --server.context-path=/abc</code></li><li>2、来自java：comp/env的NDI属性</li><li>3、java系统属性（System.getProperties()）</li><li>4、操作系统环境变量</li><li>5、RandomValuePropertySource配置的random.*属性值</li><li><strong>优先加载带profile</strong></li><li><strong>6、jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></li><li><strong>7、jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></li><li><strong>再加载不带profile</strong></li><li><strong>8、jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></li><li><strong>9、jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></li><li>10、@Configuration注解类上的@PropertySource</li><li>11、通过SpringApplication.setDefaultProperties指定的默认属性</li></ul><p>所有支持的配置加载来源</p><p>参考官方文档</p><h2 id="SpringBoot配置-自动配置原理"><a href="#SpringBoot配置-自动配置原理" class="headerlink" title="SpringBoot配置-自动配置原理"></a>SpringBoot配置-自动配置原理</h2><p>配置文件可以些什么：参照文档</p><p>自动配置原理：<br>（1）SpringBoot启动的时候加载主配置类，开启了自动配置功能@EnableAutoConfiguration<br>（2）@EnableAutoConfiguration的作用：<br>&emsp;&emsp;&emsp;&emsp;a.利用EnableAutoConfigurationImportSelector给容器导入一些组件；<br>&emsp;&emsp;&emsp;&emsp;可以插件selectimports()方法的内容；<br><code>List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</code>获取候选配置  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SpringFactoriesLoader.loadFactoryNames()</span><br><span class="line">扫描所有jar包类路径下 META-INF/spring.factories</span><br><span class="line">把扫描到的这些文件的内容包装成properties对象</span><br><span class="line">从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，把他们添加到容器中</span><br></pre></td></tr></table></figure><p>将类路径下 META-INF/spring.factories里面配置的所有EnableAutoConfiguration的值添加到了容器中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudServiceConnectorsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jdbc.JdbcRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoReactiveRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.rest.RestClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.http.codec.CodecsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.influx.InfluxDbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jsonb.JsonbAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.quartz.QuartzAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.core.ReactorCoreAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityRequestMatcherProviderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.UserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.reactive.ReactiveUserDetailsServiceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.servlet.OAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.client.reactive.ReactiveOAuth2ClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.servlet.OAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.resource.reactive.ReactiveOAuth2ResourceServerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.task.TaskSchedulingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.client.RestTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.embedded.EmbeddedWebServerFactoryCustomizerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.HttpHandlerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.ReactiveWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.WebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.error.ErrorWebFluxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.ClientHttpConnectorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.reactive.function.client.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.ServletWebServerFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.reactive.WebSocketReactiveAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.servlet.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.client.WebServiceTemplateAutoConfiguration</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.NonUniqueSessionRepositoryFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.servlet.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure><p>每一个这样的XXXAutoConfiguration类都是容器的一个组件，都加入到容器中；用他们来做自动配置  </p><p>（3）每一个自动配置类进行自动配置功能<br>（4）以<strong>HttpEncodingAutoConfiguration</strong>为例解释自动配置原理  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">@Configuration //表示一个配置类，可以给容器添加组件</span><br><span class="line">@EnableConfigurationProperties(HttpProperties.class) //启动ConfigurationProperties功能，启动指定的类；将配置文件中对应的值和HttpEncodingProperties绑定其起来；并把HttpEncodingProperties加入到ioc容器中</span><br><span class="line"></span><br><span class="line">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET) //Spring底层@Conditional注解，根据不同的条件，满足指定的条件，整个配置类里面的配置才会生效；作用：判断当前应用是否是Web应用，如果是，当前配置类生效</span><br><span class="line"></span><br><span class="line">@ConditionalOnClass(CharacterEncodingFilter.class) //判断当前项目有没有这个类CharacterEncodingFilter，SpringMVC中进行乱码解决的过滤器</span><br><span class="line"></span><br><span class="line">@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true) //判断配置文件中是否存在某个配置spring.http.encoding.enabled；如果不存在，判断也是成立的</span><br><span class="line">// 即使我们配置文件中不配置spring.http.encoding.enabled=true也是默认生效的</span><br><span class="line">public class HttpEncodingAutoConfiguration &#123;</span><br><span class="line">//已经和SpringBoot的配置文件做了映射</span><br><span class="line">private final HttpProperties.Encoding properties;</span><br><span class="line"></span><br><span class="line">// 只有一个有参构造器的情况下，会从构造器中取</span><br><span class="line">public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;</span><br><span class="line">this.properties = properties.getEncoding();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean //给容器中添加一个组件，这个组件的某些值，需要从properties中获取</span><br><span class="line">@ConditionalOnMissingBean</span><br><span class="line">public CharacterEncodingFilter characterEncodingFilter() &#123;</span><br><span class="line">CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();</span><br><span class="line">filter.setEncoding(this.properties.getCharset().name());</span><br><span class="line">filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));</span><br><span class="line">filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));</span><br><span class="line">return filter;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据当前不同的条件判断，决定这个配置类是否生效</p><p>一旦这个配置类生效，那么这个配置类就会给容器类添加各种组件；这些组件的属性从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；</p><p>（5）所有在配置文件中能配置的属性都在xxxProperties类中封装好了；配置文件能配置什么，就可以参照某个功能对应的这个属性类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;spring.http&quot;) //从配置文件中获取值</span><br><span class="line">public class HttpProperties &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Whether logging of (potentially sensitive) request details at DEBUG and TRACE level</span><br><span class="line"> * is allowed.</span><br><span class="line"> */</span><br><span class="line">private boolean logRequestDetails;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * HTTP encoding properties.</span><br><span class="line"> */</span><br><span class="line">private final Encoding encoding = new Encoding();</span><br><span class="line"></span><br><span class="line">public boolean isLogRequestDetails() &#123;</span><br><span class="line">return this.logRequestDetails;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setLogRequestDetails(boolean logRequestDetails) &#123;</span><br><span class="line">this.logRequestDetails = logRequestDetails;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public Encoding getEncoding() &#123;</span><br><span class="line">return this.encoding;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Configuration properties for http encoding.</span><br><span class="line"> */</span><br><span class="line">public static class Encoding &#123;</span><br><span class="line"></span><br><span class="line">public static final Charset DEFAULT_CHARSET = StandardCharsets.UTF_8;</span><br></pre></td></tr></table></figure><h3 id="Spring-Boot精髓"><a href="#Spring-Boot精髓" class="headerlink" title="Spring Boot精髓"></a>Spring Boot精髓</h3><ul><li>（1）SpringBoot启动会加载大量的自动配置类；</li><li>（2）看我们需要的功能有没有SpringBoot默认写好的自动配置类；</li><li>（3）看这个配置类中到底配置了哪些组件；（只要我们要用的组件已经有了，就不需要在配置了）；</li><li>（4）给容器中自动配置类添加组件的时候，会从properties类中获取某些属性，我们可以从配置文件中指定这些属性的值；</li></ul><p>xxxAutoConfiguration:自动配置类  </p><p>给容器中添加组件</p><p>xxxProperties：封装配置文件中的相关属性</p><h2 id="SpringBoot配置-自动配置报告"><a href="#SpringBoot配置-自动配置报告" class="headerlink" title="SpringBoot配置-自动配置报告"></a>SpringBoot配置-自动配置报告</h2><h3 id="1、-Conditional派生注解-Spring注解版原生的-COnditional作用"><a href="#1、-Conditional派生注解-Spring注解版原生的-COnditional作用" class="headerlink" title="1、@Conditional派生注解(Spring注解版原生的@COnditional作用)"></a>1、@Conditional派生注解(Spring注解版原生的@COnditional作用)</h3><p>必须是@Conditional指定的条件成立，才给容器中添加组件，配置里面的所有内容才生效；</p><table><thead><tr><th>@Conditional扩展注解</th><th>作用(判断是否满足当前指定条件)</th></tr></thead><tbody><tr><td>@ConditionalOnJava</td><td>系统的java版本是否符合要求</td></tr><tr><td>@ConditionalOnBean</td><td>容器中存在指定Bean</td></tr><tr><td>@ConditionalOnMissingBean</td><td>容器中不存在指定Bean</td></tr><tr><td>@ConditionalOnExpression</td><td>满足SpEL表达式指定</td></tr><tr><td>@ConditionalOnClass</td><td>系统中有指定的类</td></tr><tr><td>@ConditionalOnMissingClass</td><td>系统中没有指定的类</td></tr><tr><td>@ConditionalOnSingleCandidate</td><td>容器中只有一个指定的Bean，或者这个Bean是首选Bean</td></tr><tr><td>@ConditionalOnProperty</td><td>系统中指定的属性是否有指定的值</td></tr><tr><td>@ConditionalOnResource</td><td>类路径下是否存在指定资源文件</td></tr><tr><td>@ConditionalOnWebApplication</td><td>当前是web环境</td></tr><tr><td>@ConditionalOnNotWebApplication</td><td>当前不是web环境</td></tr><tr><td>@ConditionalOnjndi</td><td>JNDI存在指定项</td></tr></tbody></table><h3 id="2、自动配置类必须在一定条件下才能生效"><a href="#2、自动配置类必须在一定条件下才能生效" class="headerlink" title="2、自动配置类必须在一定条件下才能生效"></a>2、自动配置类必须在一定条件下才能生效</h3><p>我们如何知道哪些自动配置类生效了呢？  </p><p>可以通过启用debug=true属性，来让控制台打印自动配置报告，就可以很方便的知道哪些自动配置类生效</p><p>自动配置报告：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">============================</span><br><span class="line">CONDITIONS EVALUATION REPORT</span><br><span class="line">============================</span><br><span class="line"></span><br><span class="line">//匹配成功的自动配置</span><br><span class="line">Positive matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   CodecsAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &apos;org.springframework.http.codec.CodecConfigurer&apos; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   CodecsAutoConfiguration.JacksonCodecConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &apos;com.fasterxml.jackson.databind.ObjectMapper&apos; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   CodecsAutoConfiguration.JacksonCodecConfiguration#jacksonCodecCustomizer matched:</span><br><span class="line">      - @ConditionalOnBean (types: com.fasterxml.jackson.databind.ObjectMapper; SearchStrategy: all) found bean &apos;jacksonObjectMapper&apos; (OnBeanCondition)</span><br><span class="line"></span><br><span class="line">   DispatcherServletAutoConfiguration matched:</span><br><span class="line">      - @ConditionalOnClass found required class &apos;org.springframework.web.servlet.DispatcherServlet&apos; (OnClassCondition)</span><br><span class="line">      - found &apos;session&apos; scope (OnWebApplicationCondition)</span><br><span class="line">      ......</span><br><span class="line"> </span><br><span class="line">// 没有匹配上的自动配置  </span><br><span class="line">Negative matches:</span><br><span class="line">-----------------</span><br><span class="line"></span><br><span class="line">   ActiveMQAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &apos;javax.jms.ConnectionFactory&apos; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   AopAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &apos;org.aspectj.lang.annotation.Aspect&apos; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   ArtemisAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &apos;javax.jms.ConnectionFactory&apos; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   BatchAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnClass did not find required class &apos;org.springframework.batch.core.launch.JobLauncher&apos; (OnClassCondition)</span><br><span class="line"></span><br><span class="line">   CacheAutoConfiguration:</span><br><span class="line">      Did not match:</span><br><span class="line">         - @ConditionalOnBean (types: org.springframework.cache.interceptor.CacheAspectSupport; SearchStrategy: all) did not find any beans of type org.springframework.cache.interceptor.CacheAspectSupport (OnBeanCondition)</span><br><span class="line">      Matched:</span><br><span class="line">         - @ConditionalOnClass found required class &apos;org.springframework.cache.CacheManager&apos; (OnClassCondition)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot配置&quot;&gt;&lt;a href=&quot;#SpringBoot配置&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot配置&quot;&gt;&lt;/a&gt;SpringBoot配置&lt;/h1&gt;&lt;h2 id=&quot;YAML简介&quot;&gt;&lt;a href=&quot;#YAML简介&quot;
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="spring boot" scheme="http://blog.letmefly.cc/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>springBoot入门Hello World</title>
    <link href="http://blog.letmefly.cc/2019/07/08/springBoot%E5%85%A5%E9%97%A8Hello-World/"/>
    <id>http://blog.letmefly.cc/2019/07/08/springBoot入门Hello-World/</id>
    <published>2019-07-08T12:43:41.000Z</published>
    <updated>2019-07-11T12:23:20.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot入门-HelloWorld"><a href="#SpringBoot入门-HelloWorld" class="headerlink" title="SpringBoot入门-HelloWorld"></a>SpringBoot入门-HelloWorld</h1><h2 id="一个功能："><a href="#一个功能：" class="headerlink" title="一个功能："></a>一个功能：</h2><p>浏览器发送Hello请求，服务器接受请求并处理，响应hello world字符串</p><h3 id="1、创建一个maven工程（jar）"><a href="#1、创建一个maven工程（jar）" class="headerlink" title="1、创建一个maven工程（jar）"></a>1、创建一个maven工程（jar）</h3><h3 id="2、导入依赖（Spring-boot相关依赖）"><a href="#2、导入依赖（Spring-boot相关依赖）" class="headerlink" title="2、导入依赖（Spring boot相关依赖）"></a>2、导入依赖（Spring boot相关依赖）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;!--这个artifactId名称必须和项目名称相同--&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-01-helloworld&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure><h3 id="3、编写一个主程序，启动Spring-Boot应用"><a href="#3、编写一个主程序，启动Spring-Boot应用" class="headerlink" title="3、编写一个主程序，启动Spring Boot应用"></a>3、编写一个主程序，启动Spring Boot应用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.usst;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class HelloWorldMainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        //启动SpringBoot应用</span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4、编写相关的Controller或Service"><a href="#4、编写相关的Controller或Service" class="headerlink" title="4、编写相关的Controller或Service"></a>4、编写相关的Controller或Service</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package com.usst.controller;</span><br><span class="line"></span><br><span class="line">import org.springframework.stereotype.Controller;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.ResponseBody;</span><br><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">    </span><br><span class="line">    @ResponseBody</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello()&#123;</span><br><span class="line">        return &quot;hello world&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：@ResponseBody是作用在方法上的，@ResponseBody 表示该方法的返回结果直接写入 HTTP response body 中，一般在异步获取数据时使用【也就是AJAX】，在使用 @RequestMapping后，返回值通常解析为跳转路径，但是加上 @ResponseBody 后返回结果不会被解析为跳转路径，而是直接写入 HTTP response body 中。 比如异步获取 json 数据，加上 @ResponseBody 后，会直接返回 json 数据。@RequestBody 将 HTTP 请求正文插入方法中，使用适合的 HttpMessageConverter 将请求体写入某个对象。</p><p>@RequestBody是作用在形参列表上，用于将前台发送过来固定格式的数据【xml 格式或者 json等】封装为对应的 JavaBean 对象，封装时使用到的一个对象是系统默认配置的 HttpMessageConverter进行解析，然后封装到形参上。</p><h3 id="5、运行主程序测试"><a href="#5、运行主程序测试" class="headerlink" title="5、运行主程序测试"></a>5、运行主程序测试</h3><p>访问：localhost:8080/hello,返回hello world的字符串</p><h3 id="6、部署"><a href="#6、部署" class="headerlink" title="6、部署"></a>6、部署</h3><p>导入maven插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--maven插件，可以将应用打包成可执行的jar包--&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>即可将这个应用打成jar包，直接使用<code>java -jar 项目名</code>即可运行。</p><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><p>注意：有的时候会报错，错误为：将maven项目打包后，启动时出现SpringBoot01-1.0-SNAPSHOT.jar中没有主清单属性的提示的解决办法</p><p>此时，我们需要在maven插件中加入一段代码，最终效果如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--maven插件，可以将应用打包成可执行的jar包--&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;repackage&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><h2 id="Hello-World探究"><a href="#Hello-World探究" class="headerlink" title="Hello World探究"></a>Hello World探究</h2><h3 id="1、POM文件"><a href="#1、POM文件" class="headerlink" title="1、POM文件"></a>1、POM文件</h3><h4 id="1-父项目"><a href="#1-父项目" class="headerlink" title="(1)父项目"></a>(1)父项目</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>他的父项目是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--真正管理Spring Boot应用里面的所有依赖版本--&gt;</span><br><span class="line">&lt;parent&gt;</span><br><span class="line">&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;1.5.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure><p>这里面定义了诸多依赖的版本，所有的jar包依赖，spring都进行了依赖管理。<br>以后我们导入依赖，默认是不需要写版本的；（没有在depencies中管理的依赖版本，还是要声明版本号）</p><h3 id="2、导入依赖"><a href="#2、导入依赖" class="headerlink" title="2、导入依赖"></a>2、导入依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>可以拆成两个部分，分别是spring-boot-starter和web</p><h4 id="spring-boot-starter"><a href="#spring-boot-starter" class="headerlink" title="spring-boot-starter"></a>spring-boot-starter</h4><p>spring-boot-starter：spring-boot场景启动器，帮我们导入了web模块正常运行所依赖的组件；<br><img src="/2019/07/08/springBoot入门Hello-World/spring-boot-starter的依赖.jpg" alt="spring-boot-starter的依赖"><br>Spring Boot将所有的功能场景都抽取出来了，做成了一个个的starters（启动器），只需要在项目中引入这些starter相关场景的所有依赖都会导入进来，要用什么功能就导入什么场景的启动器</p><h4 id="web"><a href="#web" class="headerlink" title="web"></a>web</h4><p>web就是最后的spring-web和spring-webmvc的依赖。</p><h2 id="主程序类，主入口类"><a href="#主程序类，主入口类" class="headerlink" title="主程序类，主入口类"></a>主程序类，主入口类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package com.usst;</span><br><span class="line"></span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class HelloWorldMainApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(HelloWorldMainApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@SpringBootApplicaiton:SpringBoot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot通过运行这个类的主方法来启动SpringBoot应用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(</span><br><span class="line">    excludeFilters = &#123;@Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;TypeExcludeFilter.class&#125;</span><br><span class="line">), @Filter(</span><br><span class="line">    type = FilterType.CUSTOM,</span><br><span class="line">    classes = &#123;AutoConfigurationExcludeFilter.class&#125;</span><br><span class="line">)&#125;</span><br><span class="line">)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br></pre></td></tr></table></figure><ul><li><p>@SpringBootConfiguration：Spring Boot的配置类：</p><ul><li>标注在某个类上，表示这是一个Spring Boot的配置类；</li><li>底层是Configuration，配置类上来标注这个注解。<ul><li>配置类就是配置文件，配置类也是容器中的一个组件</li></ul></li></ul></li><li><p>@EnableAutoConfiguration：开启自动配置功能  </p><ul><li><p>以前需要配置的东西，SpringBoot帮我们自动配置，@EnableAutoConfiguration告诉SpringBoot开启自动配置功能，配置才能生效。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(&#123;EnableAutoConfigurationImportSelector.class&#125;)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">    String ENABLED_OVERRIDE_PROPERTY = &quot;spring.boot.enableautoconfiguration&quot;;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] exclude() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] excludeName() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- AutoConfigurationPackage：自动配置包    - @Import({Registrar.class})：Spring的底层注解，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class;    - 将主配置类（@SpringBootApplication标注的类）的所在包下及下面所有子包里面的所有组件扫描到Spring容器；- @Import(EnableAutoConfigurationImportSelector.class)- 给容器导入哪些选择器？- EnableAutoConfigurationImportSelector：导入哪些组件？- 将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中- 会给容器中导入非常多的自动配置类（xxxAutoConfiguration）;给容器中导入这个场景需要的所有组件，并配置好所有组件</code></pre><p><img src="/2019/07/08/springBoot入门Hello-World/自动配置类.jpg" alt="自动配置类"></p><pre><code>- 有了自动配置类免去了手动编写配置注入功能组件等工作；    - SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());    - 从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</code></pre><ul><li><font color="grey">Spring Boot在启动的时候从类路径下的META/INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入容器中，自动配置类就生效了，帮我们进行自动配置工作。</font>以前我们自己需要配置的东西，自动配置都帮我们做好了。  </li></ul><p>整个J2EE的整体整合方案和自动配置都在org/springframework/boot/spring-boot-autoconfigure/1.5.9.RELEASE/spring-boot-autoconfigure-1.5.9.RELEASE.jar!/org/springframework/boot/autoconfigure包下</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot入门-HelloWorld&quot;&gt;&lt;a href=&quot;#SpringBoot入门-HelloWorld&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot入门-HelloWorld&quot;&gt;&lt;/a&gt;SpringBoot入门-Hell
      
    
    </summary>
    
      <category term="spring" scheme="http://blog.letmefly.cc/categories/spring/"/>
    
    
      <category term="spring boot" scheme="http://blog.letmefly.cc/tags/spring-boot/"/>
    
  </entry>
  
  <entry>
    <title>mysql Replication</title>
    <link href="http://blog.letmefly.cc/2019/06/27/mysql-Replication/"/>
    <id>http://blog.letmefly.cc/2019/06/27/mysql-Replication/</id>
    <published>2019-06-27T05:36:09.000Z</published>
    <updated>2019-06-30T06:53:21.132Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL-Replication"><a href="#MySQL-Replication" class="headerlink" title="MySQL Replication"></a>MySQL Replication</h1><p>MySQL Replication主要用于主服务器和从服务器之间的数据复制操作。</p><h2 id="MySQL-Replication概述"><a href="#MySQL-Replication概述" class="headerlink" title="MySQL Replication概述"></a>MySQL Replication概述</h2><p>MySQL复制是指从一个MySQL主服务器(master)将数据复制到另一台或多台MySQL从服务器(slaves)的过程，将主数据库的DDL和DML操作通过二进制日志传到复制服务器上，然后再从服务器上对这些日志重新执行，从而使得主从服务器的数据保持同步。  </p><p>在MySQL中，复制操作是异步进行的，slaves服务器不需要持续的保持连接接收master服务器的数据。  </p><p>MySQL支持一台主机服务器同时向多台从服务器进行复制操作，从服务器同时可以作为其他从服务器的主服务器，如果MySQL主服务器访问量比较大，可以通过复制数据，然后在从服务器上进行查询操作，从而降低主服务器的访问压力，同时从服务器作为主服务器的备份，可以避免主服务器因为故障而数据丢失的问题。  </p><p>MySQL数据库复制操作大致可以分成三个步骤：  </p><ul><li>(1)主服务器将数据的改变记录到二进制日志（binary log）中；</li><li>(2)从服务器将主服务器的binary log events复制到它的中继日志(relay log)中;</li><li>(3)从服务器重做中继日志中的事件，将数据的改变与从服务器保持同步。</li></ul><p>首先，主服务器会记录二进制日志，每个事务更新数据完成之前，主服务器将这些操作的信息记录在二进制日志里面，在事件写入二进制日志完成后，主服务器通知存储引擎提交事务。  </p><p>Slave上面的I/O进程连接上Master，并发出日志请求，Master接收到来自Slave的I/O进程的请求后，通过负责复制的I/O进程根据请求信息读取制定日志指定位置之后的日志信息，返回给Slave的I/O进程。返回信息中除了日志所包含的信息之外，还包括本次返回的信息已经到Master端的bin-log文件的名称以及bin-log的位置。  </p><p>Slave的I/O进程接收到信息后，将接收到的日志内容添加到Slave端的relay-log文件的最末端，并将读取到的Master端的bin-log文件名和位置记录到master-info文件中。</p><p>Slave的Sql进程检测到relay-log中新增加了内容后，会马上解析relay-log的内容成为在Master端真实执行时候的那些可执行的内容，并在自身执行。</p><p>MySQL复制环境，90%以上都是一个Master带一个或者多个Slave的架构模式。如果master和Slave的压力不是太大的话，异步复制的延时一般都很少。尤其是Slave端的复制改成两个进程处理之后，更是减小了Slave端的延时。</p><p>提示：对于数据实时性要求不是特别的严格的应用，只需要通过廉价的电脑服务器来扩展Slave的数量，将读压力分散到多台Slave的机器上面，即可解决数据库端的读压力的瓶颈。</p><h2 id="查看Slave进度"><a href="#查看Slave进度" class="headerlink" title="查看Slave进度"></a>查看Slave进度</h2><p>用户如果想知道从服务器复制的进度，从而判断从服务器上复制数据的完整性，同时判断是否需要手工来做主从的同步工作。那么，可以通过SHOW PROCESSLIST列表中的Slave_SQL_Running线程的Time值得到，他记录了从服务器当前执行的SQL时间戳与系统时间之间的差距。</p><h2 id="日常管理和维护"><a href="#日常管理和维护" class="headerlink" title="日常管理和维护"></a>日常管理和维护</h2><p>数据库管理员需要进行日常的监控和管理维护工作，以便能够及时发现问题和解决问题，以此来保证主从数据库能够正常工作。当运行状况不好时，要定期进行主从服务器的数据同步操作。</p><h3 id="了解服务器的状态"><a href="#了解服务器的状态" class="headerlink" title="了解服务器的状态"></a>了解服务器的状态</h3><p><code>show slave status\G;</code><br>在查看从服务器信息中，首先要查看“Slave_IO_Running”和“Slave_SQL_Running”这两个进程状态是否是yes。Slave_IO_Running表明此进程是否能够由从服务器到主服务器上正确地读取BINLOG日志，并写入到从服务器的中继日志中；Slave_SQL_Running则表明此进程，能否读取并执行中继日志中的BINGOG（BINLOG）信息。</p><h3 id="服务器复制出错的原因"><a href="#服务器复制出错的原因" class="headerlink" title="服务器复制出错的原因"></a>服务器复制出错的原因</h3><p>有时，会出现从服务器更新失败的情况，首先要确定是否由主从服务器的表不同而造成的。如果是表结构不同而导致的，则修改从服务器上的表与主服务器上的表一致，然后重新执行START SLAVE命令。服务器复制出错的常见问题如下：</p><p>（1）出现“log enent entry exceeded max_allowed_pack”错误<br>（2）多主复制时的自增长变量冲突问题  </p><h2 id="切换主从服务器"><a href="#切换主从服务器" class="headerlink" title="切换主从服务器"></a>切换主从服务器</h2><p>可以通过配置将一个从服务器修改成主数据库，也可以将一个主数据库配置成为一个从数据库，这里不展开了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL-Replication&quot;&gt;&lt;a href=&quot;#MySQL-Replication&quot; class=&quot;headerlink&quot; title=&quot;MySQL Replication&quot;&gt;&lt;/a&gt;MySQL Replication&lt;/h1&gt;&lt;p&gt;MySQL Repl
      
    
    </summary>
    
      <category term="mysql" scheme="http://blog.letmefly.cc/categories/mysql/"/>
    
    
      <category term="mysql主从复制" scheme="http://blog.letmefly.cc/tags/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>mysql性能优化</title>
    <link href="http://blog.letmefly.cc/2019/06/26/mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://blog.letmefly.cc/2019/06/26/mysql性能优化/</id>
    <published>2019-06-26T02:43:45.000Z</published>
    <updated>2019-06-26T05:53:02.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL性能优化"><a href="#MySQL性能优化" class="headerlink" title="MySQL性能优化"></a>MySQL性能优化</h1><p>MySQL性能优化是通过合理安排资源，调整系统参数使MySQL运行更快、更节省资源。MySQL性能优化包括查询速度优化、更新速度优化、MySQL服务器优化等。</p><h2 id="优化简介"><a href="#优化简介" class="headerlink" title="优化简介"></a>优化简介</h2><p>MySQL优化，一方面是找出系统的瓶颈，提高MySQL数据库整体的性能；另一方面需要合理的结构设计和参数调整，以提高用户操作响应速度；同时还要尽可能节省系统资源，以便系统可以提供更大负荷的服务。  </p><p>MySQL数据库优化是多方面的，原则是减少系统的瓶颈，减少资源的占用，增加系统的反应速度。例如，通过优化文件系统，提高磁盘I/O的读写速度；通过优化操作系统调度策略，提高MySQL在高负荷情况下的负载能力；优化表结构、索引、查询语句等使查询响应更快。</p><p>在MySQL中，可以使用SHOW STATUS语句查询一些MySQL数据库的性能参数。SHOW STATUS语句语法如下：<br><code>SHOW STATUS LIKE &#39;value&#39;;</code><br>其中value是要查询的参数值，一些常用的性能参数如下：</p><ul><li>Connections: 连接MySQL服务器的次数</li><li>Uptime: MySQL服务器的上线时间</li><li>Slow_queries: 慢查询的次数</li><li>Com_select: 查询操作的次数</li><li>Com_insert: 插入操作的次数</li><li>Com_update: 更新操作的次数</li><li>Com_delete: 删除操作的次数</li></ul><p>如果查询MySQL服务器的连接次数，可以执行如下语句：<br><code>SHOW STATUS LIKE &#39;Connections&#39;;</code><br>如果查询MySQL服务器的慢查询次数，可以执行如下语句：<br><code>SHOW STATUS LIKE &#39;Slow_queries&#39;;</code><br>查询其他参数的方法和两个参数的查询方法相同。慢查询的次数查询可以结合慢查询日志，找出慢查询语句，然后针对慢查询语句进行表结构优化或者查询语句优化。</p><p>也可以使用<code>SHOW TABLE STATUS like &#39;表名&#39;\G;</code>来查询表、视图的一些基本信息。</p><h2 id="优化查询"><a href="#优化查询" class="headerlink" title="优化查询"></a>优化查询</h2><p>提高查询速度可以有效地提高MySQL数据库的性能。</p><h3 id="分析查询语句"><a href="#分析查询语句" class="headerlink" title="分析查询语句"></a>分析查询语句</h3><p>MySQL中提供了EXPLAIN和DESCRIBE语句，用来分析查询语句。<br>EXPLAIN语句的基本语法如下：<br><code>EXPLAIN [EXTENDED] SELECT select_options;</code><br>使用EXTENED关键字，EXPLAIN语句将产生附加信息。select_options是SELECT语句的查询的表的一些特征。  </p><h4 id="使用EXPLAIN分析后面的SELECT语句的执行情况"><a href="#使用EXPLAIN分析后面的SELECT语句的执行情况" class="headerlink" title="使用EXPLAIN分析后面的SELECT语句的执行情况"></a>使用EXPLAIN分析后面的SELECT语句的执行情况</h4><p><code>explain select * from fruits;</code></p><ul><li>id: SELECT识别符。这是SELECT的查询序列号。  </li><li>select_type: 表示SELECT语句的类型<ul><li>SIMPLE：表示简单查询，其中不包括连接查询和子查询；</li><li>PRIMARY：表示主查询，或者是最外层的查询语句；</li><li>UNION：表示连接查询的第2个或后面的查询语句；</li><li>DEPENDENT UNION：连接查询中的第2个或后面的SELECT语句，取决于外面的查询；</li><li>UNION RESULT：连接查询的结果；</li><li>SUBQUERY：子查询中的第1个SELECT语句；</li><li>DEPENDENTSUBQUERY：子查询中的第1个SELECT，取决于外面的查询；</li><li>DERIVED：导出表的SELECT（FROM子句的子查询）</li></ul></li><li>table：表示查询的表</li><li>type：表示表的连接查询<ul><li>system：该表是仅有一行的系统表。这是const连接类型的一个特例。</li><li>const：数据表最多只有匹配行，他将在查询开始时被读取，并在余下的查询优化中作为常量对待。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL性能优化&quot;&gt;&lt;a href=&quot;#MySQL性能优化&quot; class=&quot;headerlink&quot; title=&quot;MySQL性能优化&quot;&gt;&lt;/a&gt;MySQL性能优化&lt;/h1&gt;&lt;p&gt;MySQL性能优化是通过合理安排资源，调整系统参数使MySQL运行更快、更节省资源。
      
    
    </summary>
    
      <category term="mysql" scheme="http://blog.letmefly.cc/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://blog.letmefly.cc/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>SecureCRT无法连接到CentOS7</title>
    <link href="http://blog.letmefly.cc/2019/06/23/SecureCRT%E6%97%A0%E6%B3%95%E8%BF%9E%E6%8E%A5%E5%88%B0CentOS7/"/>
    <id>http://blog.letmefly.cc/2019/06/23/SecureCRT无法连接到CentOS7/</id>
    <published>2019-06-23T03:26:05.000Z</published>
    <updated>2019-06-23T04:00:38.615Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SecureCRT无法连接到CentOS7"><a href="#SecureCRT无法连接到CentOS7" class="headerlink" title="SecureCRT无法连接到CentOS7"></a>SecureCRT无法连接到CentOS7</h1><p>这两天打算学习下linux，在Parallels Desktop软件中安装了CentOS7，本机中使用SecureCRT连接CentOS的时候发现无法连接。</p><p>原因是centos中没有安装ssh，而且当时ip也选错了。<br>这里简单记录下我当时的解决方案。</p><h2 id="CentOS7安装ssh"><a href="#CentOS7安装ssh" class="headerlink" title="CentOS7安装ssh"></a>CentOS7安装ssh</h2><p>SecureCRT和CentOS是通过ssh协议进行传输的。如果想要通过SecureCRT连接CentOS，首先要在CentOS中安装ssh。<br>安装指令是：<br><code>sudo yum install -y openssl openssh-server</code><br>安装完成后启动ssh的服务即可.启动的命令是：<br><code>systemctl start sshd.service</code><br>设置开机自动启动ssh服务的命令是：<br><code>systemctl enable sshd.service</code></p><p>安装好ssh之后，就可以通过SecureCRT连接CentOS了。</p><p>但是我没有连接成功的原因是，ip没有显示出来。。。</p><p>在CentOS系统中输入<code>ifconfig</code>可以查看ip，但是我当时输入这个指令之后并没有显示出来ip。即：</p><font color="red">inet addr:。。。。Bcast:。。。。。Mask:255.255.254.0——–这一行显示的是16进制的数字，也就是看不到IP地址。</font><p>经过一番查找之后，发现可以通过另外两条命令获取ip地址，如下：</p><p>1：先用<code>dhclient eth0</code>获取IP地址<br>2：运行<code>ifconfig eth0</code>即可。如果是静态IP 可能获取到的IP不是/etc/sysconfig/network-scripts/ifcfg-eth0 配置的IP</p><p>查看到ip之后再通过SecureCRT和CentOS连接就可以了，如果不行的话，可以reboot一下CentOS，应该就ok了。</p><p>参考博客：<a href="https://blog.csdn.net/johnstrive/article/details/5625121" target="_blank" rel="noopener">ifconfig eth0输出里没有IP地址</a> </p><h2 id="ssh协议定义"><a href="#ssh协议定义" class="headerlink" title="ssh协议定义"></a>ssh协议定义</h2><p>Secure Shell（安全外壳协议，简称SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。 SSH通过在网络中建立安全隧道来实现SSH客户端与服务器之间的连接。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SecureCRT无法连接到CentOS7&quot;&gt;&lt;a href=&quot;#SecureCRT无法连接到CentOS7&quot; class=&quot;headerlink&quot; title=&quot;SecureCRT无法连接到CentOS7&quot;&gt;&lt;/a&gt;SecureCRT无法连接到CentOS7&lt;/
      
    
    </summary>
    
      <category term="云计算" scheme="http://blog.letmefly.cc/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="linux" scheme="http://blog.letmefly.cc/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>mysql索引</title>
    <link href="http://blog.letmefly.cc/2019/06/22/mysql%E7%B4%A2%E5%BC%95/"/>
    <id>http://blog.letmefly.cc/2019/06/22/mysql索引/</id>
    <published>2019-06-22T05:12:34.000Z</published>
    <updated>2019-06-27T05:37:20.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL的索引"><a href="#MySQL的索引" class="headerlink" title="MySQL的索引"></a>MySQL的索引</h1><p>索引用于快速找出在某个列中有一特定值的行。如果不使用索引，MySQL必须从第1条记录开始读完整个表，直到找到相关的行。表越大，查询数据花费的时间也就越多。 如果表中查询的列有一个索引，MySQL就可以快速到达一个位置去搜索数据文件，而不必查看所有的数据。</p><h2 id="索引简介"><a href="#索引简介" class="headerlink" title="索引简介"></a>索引简介</h2><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可以提高数据库中特定数据的查询速度。</p><h3 id="索引的含义和特点"><a href="#索引的含义和特点" class="headerlink" title="索引的含义和特点"></a>索引的含义和特点</h3><p>索引是一个单独的、存储在磁盘上的数据库结构，它们包含着对数据表里所有记录的引用指向。使用索引用于快速查找出在某个或多个列中有特定值的行，所有MySQL列类型都可以被索引，对相关列使用索引是提高查询操作速度的最佳途径。</p><p>索引是在存储引擎中实现的，每种存储引擎的索引都不一定完全相同，并且每种存储引擎也不一定支持索引类型。 根据存储引擎定义每个表的最大索引数和最大索引长度。所有存储引擎支持每个表至少16个索引，总索引长度至少为256个字节。大多数存储引擎有更高的限制。MySQL中索引的存储类型有两种：BTREE和HASH，具体和表的存储引擎相关；MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。</p><h4 id="索引的优点："><a href="#索引的优点：" class="headerlink" title="索引的优点："></a>索引的优点：</h4><ul><li>（1）通过创建唯一索引，可以保证数据库表中每一行数据的唯一性；</li><li>（2）可以加快数据的查询速度，这是创建索引的主要原因；</li><li>（3）在实现数据的参考完整性方面，可以加速表和表之间的连接；（参考的完整性要求关系中不允许引用不存在的实体）  </li><li>（4）在使用分组和排序子句进行数据查询时，也可以显著减少查询中分组和排序的时间；</li></ul><h4 id="索引的缺点："><a href="#索引的缺点：" class="headerlink" title="索引的缺点："></a>索引的缺点：</h4><ul><li>（1）创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加；</li><li>（2）索引需要占用磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件尺寸；</li><li>（3）当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ul><h3 id="索引的分类"><a href="#索引的分类" class="headerlink" title="索引的分类"></a>索引的分类</h3><h4 id="1、普通索引和唯一索引"><a href="#1、普通索引和唯一索引" class="headerlink" title="1、普通索引和唯一索引"></a>1、普通索引和唯一索引</h4><p>普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。<br>唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。<br>主键索引是一种特殊的唯一索引，不允许有空值。</p><h4 id="2、单列索引和组合索引"><a href="#2、单列索引和组合索引" class="headerlink" title="2、单列索引和组合索引"></a>2、单列索引和组合索引</h4><p>单列索引即一个索引只包含单个列，一个表可以有多个单列索引。<br>组合索引指在表的多个多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左字段时，索引才会被使用。<font color="green">使用组合索引时遵循最左前缀集合。</font></p><h4 id="3、全文索引"><a href="#3、全文索引" class="headerlink" title="3、全文索引"></a>3、全文索引</h4><p>全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。MySQL中只有MyISAM存储引擎支持全文索引。</p><h4 id="4、空间索引"><a href="#4、空间索引" class="headerlink" title="4、空间索引"></a>4、空间索引</h4><p>空间索引是对空间数据类型的字段建立的索引，MySQL中的空间数据类型有4种，分别是：GEOMETRY、POINT、LINESTRING、POLYGON。MySQL使用SPATIAL关键字进行扩展，使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL，空间索引只能在存储引擎为MyISAM的表中创建。</p><h3 id="索引的设计原则"><a href="#索引的设计原则" class="headerlink" title="索引的设计原则"></a>索引的设计原则</h3><p>索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获取良好的性能非常重要。设计索引时，应该考虑以下准则：</p><ul><li>（1）索引并非越多越好。如果一个表中有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为当表中的数据更改的同时，索引也会进行调整和更新；</li><li>（2）避免对经常更新的表进行过多的索引，并且索引中的列要尽可能少。而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段；</li><li>（3）数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能无法达到优化的效果；</li><li>（4）在条件表达式中经常用到不同值较多的列上建立索引，在不同值少的列上不要建立索引。比如，学生表的“性别”字段上只有“男”与“女”两个不同值，因此就无须创建索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。</li><li>（5）当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，提高查询速度。</li><li>（6）在频繁进行排序或分组（即group by和order by操作）的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。</li></ul><h2 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h2><p>MySQL中支持多种方法在单个或多个列上创建索引：在创建表的定义语句CREATE TABLE中指定索引列，使用ALTER TABLE语句在存在的表上创建索引或者使用CREATE INDEX语句在已经存在的表上添加索引。</p><h3 id="创建表的时候创建索引"><a href="#创建表的时候创建索引" class="headerlink" title="创建表的时候创建索引"></a>创建表的时候创建索引</h3><p>当然，其他创建表时的基本语法在这里也同样适用，比如定义列的数据类型、定义主键约束、外键约束或者唯一性约束，而不论创建哪种约束，在定义约束的同时相当于在指定列上创建了一个索引。  </p><p>创建表时创建索引的基本语法格式如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name[col_name data_type]</span><br><span class="line">[UNIQUE|FULLTEXT|SPATIAL][INDEX|KEY][index_name](col_name[length])[ASC|DESC]</span><br></pre></td></tr></table></figure><p>UNIQUE、FULLTEXT、SPATIAL为可选参数，分别表示唯一索引、全局索引和空间索引；INDEX和KEY为同义词，两者作用相同，用来指定创建索引；index_name指定索引的名称，为可选参数，如果不指定，MySQL默认col_name为索引的值；col_name为需要创建索引的字段列，该列必须从数据表中定义的多个列中选择；length为可选参数，表示索引的长度，只有字符串类型的字段才能指定索引长度；ASC或DESC指定升序或者降序的索引值存储。</p><h4 id="1、创建普通索引"><a href="#1、创建普通索引" class="headerlink" title="1、创建普通索引"></a>1、创建普通索引</h4><p>最基本的索引类型，没有唯一性之类的限制，其作用只是加快对数据的访问速度。</p><p>例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE book(</span><br><span class="line">bookid INT NOT NULL,</span><br><span class="line">bookname VARCHAR(255) NOT NULL,</span><br><span class="line">authors VARCHAR(255) NOT NULL,</span><br><span class="line">info VARCHAR(255) NULL,</span><br><span class="line">comment VARCHAR(255) NULL,</span><br><span class="line">year_publication YEAR NOT NULL,</span><br><span class="line">INDEX(year_publication)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>该语句执行完毕后，可以使用<code>SHOW CREATE TABLE</code>查看表的结构。</p><p>例如：<br><code>SHOW CREATE table book\G</code></p><p><img src="/2019/06/22/mysql索引/创建普通索引-查看book表结构.jpg" alt="创建普通索引-查看book表结构"><br>可以看到，book表中的yuer_publication字段上成功创建索引，其索引名称year_publication为MySQL自动添加。使用EXPLAIN语句查看索引是否正在使用：<br><code>explain select * from book where year_publication=1990\G</code></p><p><img src="/2019/06/22/mysql索引/创建普通索引-查看索引是否正在使用.jpg" alt="创建普通索引-查看索引是否正在使用"></p><p>使用explain语句查看语句<br><code>explain select * from book where year_publication=1990;</code></p><p><img src="/2019/06/22/mysql索引/创建普通索引-explain语句各个行解释.jpg" alt="创建普通索引-查看索引是否正在使用"><br>EXPLAIN语句输出结果的各个行解释如下：</p><ul><li>（1）id：id为SELECT的标识符。它是在SELECT查询中的顺序编号。如果这一行表示其他行的union结果，这个值可以为空。在这种情况下，table列会显示为形如<union m,n="">，表示它是id为M和N的查询行的联合结果</union></li><li>（2）select_type:指定所使用的SELECT查询类型，这里值为SIMPLE，表示简单的SELECT、不使用UNION或子查询。其他有可能的取值有：PRIMARY、UNION、SUBQUERY等；</li><li>（3）table：指定数据库读取的数据的数据表的名字，它们按被读取的先后顺序排列；</li><li>（4）paritions：该列显示的为分区表命中的分区情况。非分区表该字段为空（null）。版本5.7以前，该项是explain partitions显示的选项，5.7以后成为了默认选项；</li><li>（5）type：指定了本数据表与其他数据表之间的关联关系，可能的取值有system、const、eq_ref、ref、range、index和All；</li><li>（6）possible_keys：给出了MySQL在搜索数据记录时可选用的各个索引；</li><li>（7）key：MySQL实际选用的索引；</li><li>（8）key_len:给出索引按字节计算的长度，key_len数值越小，表示越快；</li><li>（9）ref：给出了关联关系中另一个数据表里的数据列的名字；</li><li>（10）rows：MySQL在执行这个查询时预计会从这个数据表中读出的行的个数；</li><li>（11）filtered：这个字段表示存储引擎返回的数据在server层过滤后，剩下多少满足查询的记录数量的比例，注意是百分比，不是具体记录数。使用explain extended时会出现这个列，5.7之后的版本默认就有这个字段，不需要使用explain extended了。</li><li>（12）extra：提供了与关联操作有关的信息。</li></ul><p>关于explain各行的解释，可以参考下面的链接：<br><a href="https://www.jianshu.com/p/73f2c8448722" target="_blank" rel="noopener">Mysql优化之explain详解</a><br>或者<br><a href="https://www.jianshu.com/p/8fab76bbf448" target="_blank" rel="noopener">explain结果每个字段的含义说明</a></p><h4 id="2、创建唯一索引"><a href="#2、创建唯一索引" class="headerlink" title="2、创建唯一索引"></a>2、创建唯一索引</h4><p>创建索引的主要原因是减少查询索引列操作的执行时间，尤其是对比较庞大的数据表。它与前面的普通索引类似，不同的是：索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一。</p><p>使用UNIQUE关键字创建唯一索引，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t1(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">UNIQUE INDEX UniqIdx(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用语句<code>show create table t1\G;</code>查看表结构<br><img src="/2019/06/22/mysql索引/创建唯一索引-查看表结构.jpg" alt="创建唯一索引-查看表结构"><br>可以看到，id字段上已经创建了一个名为uniqIdx的索引。</p><h4 id="3、创建单列索引"><a href="#3、创建单列索引" class="headerlink" title="3、创建单列索引"></a>3、创建单列索引</h4><p>单列索引是在数据表中的某一个字段上创建的索引，一个表中可以有多个单列索引。前面两个例子中创建的索引都是单列索引。<br>创建单列索引的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t2(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(50) NOT NULL,</span><br><span class="line">INDEX SingleIdx(name(20))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用语句<code>show create table t2\G;</code>查看表结构<br><img src="/2019/06/22/mysql索引/创建单列索引-查看表结构.jpg" alt="创建单列索引-查看表结构"><br>可以看到，id字段上已经创建了一个名为SingleIdx的单列索引，索引长度为20。</p><h4 id="4、创建组合索引"><a href="#4、创建组合索引" class="headerlink" title="4、创建组合索引"></a>4、创建组合索引</h4><p>组合索引是在多个字段上创建一个索引。<br>创建组合索引的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t3(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">INDEX MultiIdx(id, name, age)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用语句<code>show create table t3\G;</code>查看表结构<br><img src="/2019/06/22/mysql索引/创建组合索引-查看表结构.jpg" alt="创建组合索引-查看表结构"><br>可以看到，id、name和age字段上已经成功建立了一个名为MultiIdx的组合索引。</p><p>提示:<font color="blue">组合索引可起几个索引的作用，但是使用时并不是随便查询哪个字段都可以使用索引，而是遵从“最左前缀”：利用索引中最左边的列集来匹配行，这样的列集成为最左前缀。例如，这里由id，name和age3个字段构成的索引，索引中按id/name/age的顺序存放，索引可以搜索下面字段组合：(id,name,age)、(id,name)、(id,age)或者id。如果列不构成索引最前面的前缀，MySQL不能使用局部索引，如(age)或者(name, age)组合不能使用索引查询</font></p><h4 id="5、创建全文索引"><a href="#5、创建全文索引" class="headerlink" title="5、创建全文索引"></a>5、创建全文索引</h4><p>FULLTEXT全文索引可以用于全文搜索。只有MyISAM存储引擎支持FULLTEXT索引，并且只为CHAR、VARCHAR和TEXT列。索引总是对整个列进行，不支持局部（前缀）索引。</p><p>创建全文索引的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t4(</span><br><span class="line">id INT NOT NULL,</span><br><span class="line">name CHAR(30) NOT NULL,</span><br><span class="line">age INT NOT NULL,</span><br><span class="line">info VARCHAR(255),</span><br><span class="line">FULLTEXT INDEX FullTxtIdx(info)</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>使用语句<code>show create table t4\G;</code>查看表结构<br><img src="/2019/06/22/mysql索引/创建全文索引-查看表结构.jpg" alt="创建全文索引-查看表结构"><br>可以看到，info字段上已经成功创建了一个名为FullTxtIdx的FULLTEXT索引。全文索引非常适合于大型数据集，对于小的数据集，它的用处可能比较小。</p><h4 id="6、创建空间索引"><a href="#6、创建空间索引" class="headerlink" title="6、创建空间索引"></a>6、创建空间索引</h4><p>空间索引必须在MyISAM类型的表中创建，且空间类型的字段必须为非空。</p><p>创建空间索引的例子如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE t5(</span><br><span class="line">g GEOMETRY NOT NULL,</span><br><span class="line">SPATIAL INDEX spatIdx(g)</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>使用语句<code>show create table t4\G;</code>查看表结构<br><img src="/2019/06/22/mysql索引/创建空间索引-查看表结构.jpg" alt="创建空间索引-查看表结构"><br>可以看到，t5表上的g字段上创建了名称为spatIdx的空间索引。注意创建时指定空间类型字段值的非空约束，并且表的存储类型是MyISAM。</p><h3 id="在已经存在的表上创建索引"><a href="#在已经存在的表上创建索引" class="headerlink" title="在已经存在的表上创建索引"></a>在已经存在的表上创建索引</h3><p>在已经存在的表中创建索引，可以使用ALTER TABLE语句或者CREATE INDEX语句。</p><h4 id="1、使用ALTER-TABLE语句创建索引"><a href="#1、使用ALTER-TABLE语句创建索引" class="headerlink" title="1、使用ALTER TABLE语句创建索引"></a>1、使用ALTER TABLE语句创建索引</h4><p>ALTER TABLE创建索引的基本语法如下：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER TABLE table_name ADD [UNIQUE|FULLTEXT|SPATIAL] </span><br><span class="line">[INDEX|KEY] [index+name])(col_name[length],...)[ASC|DESC]</span><br></pre></td></tr></table></figure><h5 id="在book表中的bookname字段上建立名为BkNameIdx的普通索引"><a href="#在book表中的bookname字段上建立名为BkNameIdx的普通索引" class="headerlink" title="在book表中的bookname字段上建立名为BkNameIdx的普通索引"></a>在book表中的bookname字段上建立名为BkNameIdx的普通索引</h5><p>SQL语句如下：</p><p><code>alter table book add index BkNameIdx(bookname(30));</code></p><p>添加索引之前，使用SHOW INDEX语句查看指定表中创建的索引：<br><code>show index from book\G;</code><br><img src="/2019/06/22/mysql索引/在表上创建索引-alter之前.jpg" alt="在表上创建索引-alter之前"><br>红色标注的是已有的索引，其中各个参数的含义为：</p><ul><li>Table: 表示创建索引的表</li><li>Non_unique: 表示索引非唯一，1代表是非唯一索引，0代表唯一索引</li><li>Key_name: 表示索引的名称</li><li>Seq_in_index: 表示该字段在索引中的位置，单列索引该值为1，组合索引为每个字段在索引定义中的顺序</li><li>Column_name: 表示定义索引的字段</li><li>Collation: 列以什么方式存储在索引中。在MySQLSHOW INDEX语法中，有值’A’（升序）或NULL（无分类</li><li>Cardinality: 索引中唯一值的数目的估计值。通过运行ANALYZE TABLE或myisamchk -a可以更新。基数根据被存储为整数的统计数据来计数，所以即使对于小型表，该值也没有必要是精确的。基数越大，当进行联合时，MySQL使用该索引的机会就越大</li><li>Sub_part: 表示索引的长度。如果列只是被部分地编入索引，则为被编入索引的字符的数目。如果整列被编入索引，则为NULL。</li><li>Packed: 指示关键字如何被压缩。如果没有被压缩，则为NULL。</li><li>Null: 表示该字段是否能为空值。如果列含有NULL，则含有YES。如果没有，则该列含有NO</li><li>Index_type: 表示索引类型。用过的索引方法（BTREE, FULLTEXT, HASH, RTREE）</li><li>Comment: 多种注释</li><li>Index_comment: 为索引创建时提供了一个注释属性的索引的任何评论</li><li>Visible: 索引是否可见</li><li>Expression: </li></ul><p>可以看到，book表中已经存在了一个索引，即前面已经定义的名称为year_publication索引，该索引为非唯一索引。</p><p>使用ALTER TABLE在bookname字段上添加索引，SQL语句如下：<br><code>alter table book add index BkNameIdx(bookname(30));</code>  </p><p>使用SHOW INDEX语句查看表中的索引：<br><img src="/2019/06/22/mysql索引/在表上创建索引-alter之后.jpg" alt="在表上创建索引-alter之后"><br>可以看到，表中出现了两个索引，另一个为通过ALTER TABLE语句添加的名称为BkNameIdx的索引，该索引为非唯一索引，长度为30.</p><h5 id="在book表中添加唯一索引"><a href="#在book表中添加唯一索引" class="headerlink" title="在book表中添加唯一索引"></a>在book表中添加唯一索引</h5><p>在book表的bookId字段上建立名称为UniqidIdx的唯一索引，SQL语句如下：<br><code>alter table book add unique index UniqidIdx(bookId);</code></p><p>使用SHOW INDEX语句查看表中的索引：<br><img src="/2019/06/22/mysql索引/在表上创建唯一索引-查看表结构.jpg" alt="在表上创建唯一索引-查看表结构"><br>可以看到，Non_unique属性值为0，表示名称为UniqidIdx的索引为唯一索引，创建唯一索引成功。</p><h5 id="在book表中添加单列索引"><a href="#在book表中添加单列索引" class="headerlink" title="在book表中添加单列索引"></a>在book表中添加单列索引</h5><p>在book表的comment字段上建立单列索引，SQL语句如下：<br><code>alter table book add index BkcmtIdx(comment(50));</code></p><p>使用SHOW INDEX语句查看表中的索引：<br><img src="/2019/06/22/mysql索引/在表上创建单列索引-查看表结构.jpg" alt="在表上创建单列索引-查看表结构"><br>可以看到，book表的commet字段上建立了名称为BkcmgIdx的索引，长度为50，在查询时，只需要检索前50个字符。</p><h5 id="在book表中添加组合索引"><a href="#在book表中添加组合索引" class="headerlink" title="在book表中添加组合索引"></a>在book表中添加组合索引</h5><p>在book表的authors和info字段上建立组合索引，SQL语句如下：<br><code>alter table book add index BkAuAndInfoIdx(authors(20),info(50));</code></p><p>使用SHOW INDEX语句查看表中的索引：<br><img src="/2019/06/22/mysql索引/在表上创建组合索引-查看表结构.jpg" alt="在表上创建组合索引-查看表结构"><br>可以看到，名称为BkAuAndInfoIdx的索引由两个字段组成，authors字段长度为30，在组合索引中的序号为1，该字段不允许为空值NULL；info字段长度为50，在组合索引中的序号为2，该字段可以为空值NULL。</p><h5 id="创建全文索引"><a href="#创建全文索引" class="headerlink" title="创建全文索引"></a>创建全文索引</h5><p>创建表t6,在t6表上使用ALTER TABLE创建全文索引，SQL语句如下：<br>首先创建表t6，语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table t6(</span><br><span class="line">id int not null,</span><br><span class="line">info char(255)</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>注意修改ENGINE参数为MyISAM，MySQL默认引擎InnoDB不支持全文索引。<br>使用ALTER TABLE语句在info字段上创建全文索引：<br><code>alter table t6 add fulltext index infoFTIdx(info);</code><br>使用SHOW INDEX语句查看索引：<br><img src="/2019/06/22/mysql索引/在表上创建全文索引-查看表结构.jpg" alt="在表上创建全文索引-查看表结构"><br>可以看到，t6表中已经创建了infoFTIdx的索引，该索引在info字段上创建，类型为FULLTEXT，运行空值。</p><h5 id="创建空间索引"><a href="#创建空间索引" class="headerlink" title="创建空间索引"></a>创建空间索引</h5><p>创建表t7,在t7的空间数据类型字段g上创建名称为spatIdx的空间索引，SQL语句如下：<br>首先创建表t7，语句如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">create table t7(</span><br><span class="line">g GEOMETRY NOT NULL</span><br><span class="line">)ENGINE=MyISAM;</span><br></pre></td></tr></table></figure><p>注意修改ENGINE参数为MyISAM，MySQL默认引擎InnoDB不支持空间索引。<br>使用ALTER TABLE语句在g字段上建立空间索引：<br><code>alter table t7 add spatial index spatIdx(g);</code><br>使用SHOW INDEX语句查看索引：<br><img src="/2019/06/22/mysql索引/在表上创建空间索引-查看表结构.jpg" alt="在表上创建空间索引-查看表结构"><br>可以看到，t7表的g字段上创建了名称为spatIdx的空间索引。</p><h4 id="2、使用CREATE-INDEX创建索引"><a href="#2、使用CREATE-INDEX创建索引" class="headerlink" title="2、使用CREATE INDEX创建索引"></a>2、使用CREATE INDEX创建索引</h4><p>CREATE INDEX语句可以在已经存在的表上添加索引，MySQL中CREATE INDEX被映射到一个ALTER TABLE语句上，基本语法为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE [UNIQUE|FULLTEXT|SPATIAL] INDEX index_name ON </span><br><span class="line">table_name(col_name[length],...)[ASC|DESC]</span><br></pre></td></tr></table></figure><h5 id="建立名为BkNameIdx的普通索引"><a href="#建立名为BkNameIdx的普通索引" class="headerlink" title="建立名为BkNameIdx的普通索引"></a>建立名为BkNameIdx的普通索引</h5><p><code>create index BkNameIdx on book(bookname)</code></p><h5 id="建立名称为UniqidIdx的唯一索引"><a href="#建立名称为UniqidIdx的唯一索引" class="headerlink" title="建立名称为UniqidIdx的唯一索引"></a>建立名称为UniqidIdx的唯一索引</h5><p><code>create unique index UniqidIdx on book(bookId)</code></p><h5 id="建立单列索引"><a href="#建立单列索引" class="headerlink" title="建立单列索引"></a>建立单列索引</h5><p><code>create index BkcmtIdx on book(comment(50))</code></p><h5 id="建立组合索引"><a href="#建立组合索引" class="headerlink" title="建立组合索引"></a>建立组合索引</h5><p><code>create index BkAuAndInfoIdx on book(authors(20),info(50))</code></p><h5 id="建立全文索引"><a href="#建立全文索引" class="headerlink" title="建立全文索引"></a>建立全文索引</h5><p><code>create fulltext index on t6(info)</code></p><h5 id="建立空间索引"><a href="#建立空间索引" class="headerlink" title="建立空间索引"></a>建立空间索引</h5><p><code>create spatial index spatIdx on t7(g)</code></p><p>建立完索引之后仍然可以通过SHOW INDEX或者SHOW CREATE TABLE语句查看表中的索引，与ALTER TABLE 创建索引得到的结果是一致的。</p><h2 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h2><p>MySQL中删除索引使用ALTER TABLE或者DROP INDEX语句，两者可以实现相同的功能，DROP INDEX语句在内部被映射到一个ALTER TABLE语句中。</p><h3 id="使用ALTER-TABLE删除索引"><a href="#使用ALTER-TABLE删除索引" class="headerlink" title="使用ALTER TABLE删除索引"></a>使用ALTER TABLE删除索引</h3><p>ALTER TABLE删除索引的基本语法格式如下：<br><code>ALTER TABLE table_name drop index index_name;</code></p><h4 id="删除book表中名称为UniqidIdx的索引"><a href="#删除book表中名称为UniqidIdx的索引" class="headerlink" title="删除book表中名称为UniqidIdx的索引"></a>删除book表中名称为UniqidIdx的索引</h4><p>首先查看book表中是否有名称为UniqidIdx的索引，输入SHOW语句如下：<br><code>show create table book\G;</code><br><img src="/2019/06/22/mysql索引/创建唯一索引-查看表结构2.jpg" alt="创建唯一索引-查看表结构"></p><p>查询结果可以看到，book表中有名称为UniqidIdx的唯一索引，该索引在id字段上创建，下面删除该索引，删除语句如下：<br><code>alter table book drop index UniqidIdx;</code><br><img src="/2019/06/22/mysql索引/删除唯一索引-查看表结构.jpg" alt="删除唯一索引-查看表结构"><br>由结果可知，book表中已经没有名为UniqidIdx的唯一索引，删除索引成功。</p><font color="red">添加AUTO_INCREMENT约束字段的唯一索引不能被删除</font><h4 id="使用DROP-INDEX语句删除索引"><a href="#使用DROP-INDEX语句删除索引" class="headerlink" title="使用DROP INDEX语句删除索引"></a>使用DROP INDEX语句删除索引</h4><p>DROP INDEX删除索引的基本语法格式如下：<br><code>DROP INDEX index_name ON table_name;</code></p><h5 id="删除book表中名称为BkAndIndoIdx的组合索引"><a href="#删除book表中名称为BkAndIndoIdx的组合索引" class="headerlink" title="删除book表中名称为BkAndIndoIdx的组合索引"></a>删除book表中名称为BkAndIndoIdx的组合索引</h5><p><code>DROP INDEX BkAuAndInfoIdx ON book;</code><br><img src="/2019/06/22/mysql索引/删除组合索引-查看表结构.jpg" alt="删除组合索引-查看表结构"><br>可以看到，book表中已经没有名称为BkAuAndInfoIdx的组合索引，删除索引成功。   </p><font color="red">注意：删除表中的列时，如果要删除的列为索引的组成部分，则该列也会从索引中删除。如果组成索引的所有列都被删除，则整个索引将被删除</font>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL的索引&quot;&gt;&lt;a href=&quot;#MySQL的索引&quot; class=&quot;headerlink&quot; title=&quot;MySQL的索引&quot;&gt;&lt;/a&gt;MySQL的索引&lt;/h1&gt;&lt;p&gt;索引用于快速找出在某个列中有一特定值的行。如果不使用索引，MySQL必须从第1条记录开始读完
      
    
    </summary>
    
      <category term="mysql" scheme="http://blog.letmefly.cc/categories/mysql/"/>
    
    
      <category term="mysql索引" scheme="http://blog.letmefly.cc/tags/mysql%E7%B4%A2%E5%BC%95/"/>
    
  </entry>
  
  <entry>
    <title>centos搭建docker</title>
    <link href="http://blog.letmefly.cc/2019/06/22/centos%E6%90%AD%E5%BB%BAdocker/"/>
    <id>http://blog.letmefly.cc/2019/06/22/centos搭建docker/</id>
    <published>2019-06-22T01:02:04.000Z</published>
    <updated>2019-06-22T04:56:05.926Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在CentOS7下安装docker"><a href="#在CentOS7下安装docker" class="headerlink" title="在CentOS7下安装docker"></a>在CentOS7下安装docker</h1><p>Dokcer从1.13版本之后分为社区版CE和企业版EE，并且采用时间线的方式作为版本号</p><p>社区版是免费提供给个人开发者和小型团队使用的，企业版是收费的，但是会提供额外的服务，比如经过官方测试认证通过的基础设施、容器、插件等。</p><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><h3 id="查看以前是否安装过docker"><a href="#查看以前是否安装过docker" class="headerlink" title="查看以前是否安装过docker"></a>查看以前是否安装过docker</h3><p>可以使用命令：<br><code>yum list installed | grep docker</code><br>如果没有权限的话，使用<br><code>sudo yum list installed | grep docker</code><br>如果没有安装过docker，则直接安装docker即可。  </p><p>如果安装过docker，使用命令<code>sudo docker version</code>查看安装的版本，如果版本过久，则要先删除旧版本的docker</p><h4 id="删除旧版本的docker"><a href="#删除旧版本的docker" class="headerlink" title="删除旧版本的docker"></a>删除旧版本的docker</h4><p>使用命令：<code>sudo yum remove ...</code>,将以前安装的docker删除即可。</p><h3 id="安装需要的软件包"><a href="#安装需要的软件包" class="headerlink" title="安装需要的软件包"></a>安装需要的软件包</h3><p>yum-util提供yum-config-manager功能，另外两个是devicemapper驱动依赖的。  </p><p><code>sudo yum install -y yum-utils device-mapper-persistent-data lvm2</code></p><h3 id="设置yum源"><a href="#设置yum源" class="headerlink" title="设置yum源"></a>设置yum源</h3><p>官方源网速较慢，不建议使用<br>我们设置为阿里源，这个速度较快<br><code>sudo yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</code></p><h3 id="查看所有仓库中所有docker版本"><a href="#查看所有仓库中所有docker版本" class="headerlink" title="查看所有仓库中所有docker版本"></a>查看所有仓库中所有docker版本</h3><p><code>yum list docker-ce --showduplicates | sort -r</code><br>可以选择默认安装版本，也可以选择特定版本安装  </p><h3 id="安装docker-1"><a href="#安装docker-1" class="headerlink" title="安装docker"></a>安装docker</h3><h4 id="安装默认版本"><a href="#安装默认版本" class="headerlink" title="安装默认版本"></a>安装默认版本</h4><p><code>sudo yum install docker-ce</code><br>由于repo中默认只开启stable仓库，所以这里默认安装的就是最新最稳定的版本</p><h4 id="选择指定版本安装"><a href="#选择指定版本安装" class="headerlink" title="选择指定版本安装"></a>选择指定版本安装</h4><p><code>yum install docker-ce-版本号</code><br>例如：<code>yum install docker-ce-17.12.1.ce</code></p><h3 id="启动docker服务"><a href="#启动docker服务" class="headerlink" title="启动docker服务"></a>启动docker服务</h3><p><code>sudo systemctl start docker</code><br>只有启动docker服务之后，docker才可以正常使用</p><h3 id="加入开机启动docker"><a href="#加入开机启动docker" class="headerlink" title="加入开机启动docker"></a>加入开机启动docker</h3><p><code>sudo systemctl enable docker</code><br>centOS启动后会自动启动docker服务，不用我们手动开启docker</p><h3 id="验证docker安装是否成功"><a href="#验证docker安装是否成功" class="headerlink" title="验证docker安装是否成功"></a>验证docker安装是否成功</h3><p><code>docker version</code><br>有client和service两部分表示docker安装启动都成功了</p><p><font color="red">默认情况下，docker命令必须获得root权限。</font><br>如果执行<code>docker version</code>后出现  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">”Got permission denied while trying to connect to </span><br><span class="line">the Docker daemon socket at unix:///var/run/</span><br><span class="line">docker.sock: Get http://</span><br><span class="line">%2Fvar%2Frun%2Fdocker.sock/v1.26/images/json: </span><br><span class="line">dial unix /var/run/docker.sock: connect: </span><br><span class="line">permission denied“</span><br></pre></td></tr></table></figure><p>大概意思是说：docker进程使用Unix Socket而不是TCP端口。而默认情况下，Unix socket属于root用户，需要root权限才能访问。</p><p>此时，我们执行<code>sudo docker version</code>，重新查看docker是否已经安装成功即可。</p><h3 id="docker常用的一些命令"><a href="#docker常用的一些命令" class="headerlink" title="docker常用的一些命令"></a>docker常用的一些命令</h3><ul><li>docker ps（docker ps -s），查看当前正在运行的容器</li><li>docker ps -a，查看所有容器的状态</li><li>docker start/stop 容器名，启动/停止某个容器</li><li>docker attach id，进入某个容器（使用exit退出后容器也跟着停止运行）</li><li>docker exec -it id [bash]，启动一个伪终端以交互式的方式进入某个容器（使用exit退出容器后不停止运行）</li><li>docker images，查看本地镜像</li><li>docker rm id/name, 删除某个容器</li><li>docker rmi id/name, 删除某个镜像</li><li>docker run –name=test -it ubuntu /bin/bash，复制Ubuntu容器并且重命名为test且运行，然后以伪终端的交互方式进入容器，运行bash</li><li>docker build -t sora/centos:7.1 通过当前目录下的DockerFile创建一个名为soar/centos:7.1的镜像</li><li>docker run -d -p 2222:22 –name=test soar/centos:7.1 以镜像soar/centos:7.1创建名为test的容器，并以后台模式运行，并做端口映射到宿主机2222端口，-P参数重启容器宿主机端口会发生改变</li></ul><p>参考地址：<a href="https://blog.csdn.net/hylaking/article/details/87978819" target="_blank" rel="noopener">CentOS7上安装docker笔记</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;在CentOS7下安装docker&quot;&gt;&lt;a href=&quot;#在CentOS7下安装docker&quot; class=&quot;headerlink&quot; title=&quot;在CentOS7下安装docker&quot;&gt;&lt;/a&gt;在CentOS7下安装docker&lt;/h1&gt;&lt;p&gt;Dokcer从1.1
      
    
    </summary>
    
      <category term="云计算" scheme="http://blog.letmefly.cc/categories/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    
      <category term="docker" scheme="http://blog.letmefly.cc/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>监听器Listener</title>
    <link href="http://blog.letmefly.cc/2019/01/23/%E7%9B%91%E5%90%AC%E5%99%A8Listener/"/>
    <id>http://blog.letmefly.cc/2019/01/23/监听器Listener/</id>
    <published>2019-01-23T06:46:35.000Z</published>
    <updated>2019-06-22T02:39:05.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="监听器Listener"><a href="#监听器Listener" class="headerlink" title="监听器Listener"></a>监听器Listener</h1><p>&emsp;&emsp;监听器是一个实现特定接口的普通Java程序，该程序专门用于监听另一个java对象的方法调用或属性改变，当被监听对象发生上述事件后，监听器某个方法将立即被执行。<br>&emsp;&emsp;Listener用于监听Java Web程序中的事件，例如：创建、修改、删除Session、request、context等，并触发相应的事件。利用Listener可以用很少的代码实现很酷炫的效果。</p><h2 id="Listener概述"><a href="#Listener概述" class="headerlink" title="Listener概述"></a>Listener概述</h2><p>&emsp;&emsp;Listener也是Servlet规范2.3中加入的，对应设计模式中的Listener模式，事件发生的时候会自动触发该事件对应的Listener。Listener主要用于对Session、request、context等进行监控。目前Servlet2.5规范中共有8种Listener，分别完成对不同事件的监听。</p><h3 id="Listener概述-1"><a href="#Listener概述-1" class="headerlink" title="Listener概述"></a>Listener概述</h3><p>&emsp;&emsp;JavaWeb中使用Listener与Event完成相应事件的处理。使用Listener不需要关注该类事件是怎样触发的或者怎么相应的Listener，只要记住该类事件触发时一定会调用相应的Listener。遵循Servlet规范的服务器完成了相应的工作。</p><h3 id="Listener的使用"><a href="#Listener的使用" class="headerlink" title="Listener的使用"></a>Listener的使用</h3><p>&emsp;&emsp;使用Listener需要实现相应的Listener接口。应该触发Listener事件的时候，Tomcat会自动调用Listener的方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">pulic class SessionListenerTest implements HttpSessionListener&#123;</span><br><span class="line">public void sessionCreated(HttpSessionEvent se)&#123;</span><br><span class="line">//创建Session时会被调用</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">//输出到控制台</span><br><span class="line">System.out.println(&quot;新创建了一个session：&quot; + session);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void sessionDestroyed(HttpSessionEvent se)&#123;</span><br><span class="line">//销毁Session前被调用</span><br><span class="line">HttpSession session = se.getSession();</span><br><span class="line">//输出到控制台</span><br><span class="line">System.out.println(&quot;销毁了一个session：&quot; + session);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这段代码实现了HttpSessionListener接口。创建Session会使用服务器调用SessionCreated()方法，销毁Session(包括session超时自动销毁)时服务器会调用sessionDestroyed()方法，都以HttpSessionEvent对象为参数。HttpSessionEvent代表了当前的事件，能从中获取到Session。Listener需要在web.xml文件中配置才生效。配置代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">//类的全限定名</span><br><span class="line">  &lt;listener-class&gt;</span><br><span class="line">  com.usst.listener.SessionListenerTest </span><br><span class="line">  &lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;\<listener>标签一般配置在\<servlet>标签的前面。启动Web服务后，每当创建一个Session或者销毁一个Session，控制台都会打印出相应的日志。<br>&emsp;&emsp;注意：一个完整的Listener包括Listener类、\<listener>配置。一个web.xml文件中可以配置多个Listener。同一种类型的Listener也可以配置多个，触发的时候服务器会顺次执行各个Listener的相应方法。</listener></servlet></listener></p><h3 id="监听器术语"><a href="#监听器术语" class="headerlink" title="监听器术语"></a>监听器术语</h3><ul><li>事件源：被监听的对象（目标对象）</li><li>监听器对象：用于监听“事件源”的对象</li><li>注册（绑定）：将“监听器对象”注册给“事件源”。当“事件源”发生某些行为时，监听对象将被执行</li><li>事件：事件源行为的称呼</li><li><p>事件对象：在“监听器对象”中获得“事件源”</p><h2 id="Listener的分类"><a href="#Listener的分类" class="headerlink" title="Listener的分类"></a>Listener的分类</h2><p>&emsp;&emsp;Servlet2.5规范中共有8种Listener，分别用于监听Session、context、request等的创建与销毁、属性变化等。另有一个Listener能够监听存放在Session中的对象。共有6种Event。</p><h3 id="监听对象的创建与销毁"><a href="#监听对象的创建与销毁" class="headerlink" title="监听对象的创建与销毁"></a>监听对象的创建与销毁</h3><p>&emsp;&emsp;HttpSessionListener、ServletContextListener、ServletRequestListener分别用于监控Session、context、request的创建与销毁。触发时机分别为：</p></li><li><p>HttpSessionListener：监听（Http）Session的创建与销毁。创建Session时执行sessionCreated（HttpSessionEvent se）方法。超时或者执行session.invalidate()时执行sessionDestroyed(HttpSessionEvent se)方法。该Listener可用于收集在线者信息。</p><ul><li>Session域对象创建和销毁的时机创建：用户第一次访问时，服务器创建session</li><li>销毁：如果用户的session30分钟没有使用，服务器会销毁session，我们在web.xml文件中也可以配置session的失效时间。</li></ul></li><li>ServletContextListener：监听context的创建与销毁。context代表当前的Web应用程序。服务器启动或者热部署war包时执行contextInitialized(ServletContextEvent event)方法。服务器关闭时或者只关闭该Web时会执行contextDestroyed(ServletContextEvent event)方法。该Listener可用于启动时获取web.xml里配置的初始化参数。<ul><li>提问：servletContext域对象何时创建和销毁？<ul><li>创建：服务器启动<font color="red">针对每一个web应用创建servletcontext</font></li><li>销毁：服务器关闭前关闭代表每一个web应用的</li></ul></li><li>servletContext主流应用<ul><li>保存全局应用数据对象<ul><li>例如：创建数据库连接池</li></ul></li><li>加载框架配置文件<ul><li>Spring框架(配置文件随服务器启动加载)</li><li>org.springframework.web.context.ContextLoaderListener</li></ul></li><li>实现任务调度（定时器）<ul><li>Timer</li><li>TimerTask</li></ul></li><li>主要作用<ul><li>a.初始化的工作：初始化对象、初始化数据 —-加载数据库驱动、连接池的初始化</li><li>b.加载—初始化的配置文件 —-spring的配置文件</li><li>c.任务调度—定时器—-Timer/Timer Task</li></ul></li></ul></li></ul></li><li>ServletRequestListener：监听request的创建与销毁。用户每次请求request都会执行requestInitialized(ServletRequestEvent event)方法。Request对象被销毁时，监听器的requestDestroyed方法会被调用。注意如果一个HTML页面内含有多个图片，则请求一次HTML页面可能会触发多次request事件。<ul><li>servletRequest域对象创建和销毁的时机：<ul><li>创建：用户每一次访问，都会创建一个request</li><li>销毁：当前访问结束，request对象就会销毁</li></ul></li></ul></li></ul><h3 id="监听Session、Request、ServletContext"><a href="#监听Session、Request、ServletContext" class="headerlink" title="监听Session、Request、ServletContext"></a>监听Session、Request、ServletContext</h3><p>&emsp;&emsp;Java中的类可以实现多个接口，因此实现Listener时可以使用一个类实现多个Listener接口。这样的好处是多种Listener一块儿工作，使用同一个类的资源。<br><code>public class ListenerTest implements HttpSessionListener,ServletContextListener,ServletRequestListener</code></p><h3 id="监听对象的属性变化"><a href="#监听对象的属性变化" class="headerlink" title="监听对象的属性变化"></a>监听对象的属性变化</h3><p>&emsp;&emsp;另一类Listener用于监听Session、context、request的属性变化，接口名称格式为XXXAttributeListener，包括HttpSessionAttributeListener、ServletContextAttributeListener、ServletRequestAttributeListener。当向被监听对象中添加、更新、移除属性时，会分别执行xxxAdded()、xxxReplaced()、XXXRemoved()方法，xxx分别代表Session、context、request。</p><ul><li>attributeAdded方法<ul><li>当向被监听器对象中增加一个属性时，web容器就调用事件监听器的attributeAdded方法进行相应，这个方法接受一个事件类型的参数，监听器可以通过这个参数来获得正在增加的域对象和被保存到域中的属性对象。</li><li>各个域属性监听器中的完整语法定义为：<ul><li>public void attributeAdded(ServletContextAttributeEvent scae)</li><li>public void attributeAdder(HttpSessionBindingEvent hsbe)</li><li>public void attributeAdder(ServletRequestAttributeEvent srae)</li></ul></li></ul></li><li>attributeRemoved方法<ul><li>当删除被监听对象中的一个属性时，web容器调用事件监听器的这个方法进行相应操作</li><li>各个域属性监听器中的完整语法定义为：<ul><li>public void attributeRemoved(ServletContextAttributeEvent scae)</li><li>public void attributeRemoved(HttpSessionBindingEvent hsbe)</li><li>public void attributeRemoved(ServletRequestAttributeEvent srae)</li></ul></li></ul></li><li>attributeReplaced方法<ul><li>当监听器的域对象中的某个属性被替换时，web容器调用事件监听器的这个方法进行相应操作</li><li>各个域属性监听器中的完整语法定义为：<ul><li>public void attributeReplaced(ServletContextAttributeEvent scae)</li><li>public void attributeReplaced(HttpSessionBindingEvent hsbe)</li><li>public void attributeReplaced(ServletRequestAttributeEvent srae)</li></ul></li></ul></li></ul><h3 id="监听Session内的内容"><a href="#监听Session内的内容" class="headerlink" title="监听Session内的内容"></a>监听Session内的内容</h3><p>&emsp;&emsp;除了上面的6种Listener，还有两种Listener用于监控Session内的对象，分别是HttpSessionBindingListener和HttpSessionActivationListener。它们的触发时机分别为：</p><ul><li>HttpSessionBindingListener：JavaBean对象可以感知自己被绑定到Session中以及从Session中删除的事件。当对象被放到Session里是执行valueBound(HttpSessionBindingEvent event)方法。当对象被从Session里移除时执行valueUnbound(HttpSessionBindingEvent event)方法。对象必须实现该Listener接口。</li><li>HttpSessionActivationListener：JavaBean对象可以感知自己被活化和钝化的事件。服务器关闭时，会将Session中的内容保存到硬盘上，这个过程叫钝化。服务器重新启动时，会将Session里的内容从硬盘上重新加载。当Session里的对象被钝化时执行sessionWillPassivate(HttpSessionEvent se)方法，当该对象被重新加载时执行sessionDidActivate(HttpSessionEvent se)。对象必须实现Listener接口。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context&gt;</span><br><span class="line">&lt;Manager className=&quot;org.apache.catalina.session.PersistentManager&quot; maxIdleSwap=&quot;1&quot;&gt;</span><br><span class="line">&lt;Store className=&quot;org.apache.catalina.session.FileStore&quot; directory=&quot;it315&quot;/&gt;</span><br><span class="line">&lt;/Manager&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;与上面的6种Listener不同，这两个Listener监听的是Session中的对象而非Session等，因此不需要在web.xml文件中声明。</p><h2 id="Listener的使用案例"><a href="#Listener的使用案例" class="headerlink" title="Listener的使用案例"></a>Listener的使用案例</h2><p>&emsp;&emsp;Listener的特性使得它可以做许多事情，而且不会和Servlet等有任何的耦合。</p><ul><li>单态登录</li><li>统计在线用户<ul><li>记录服务器信息，包括：</li><li>活动时间</li><li>累计访问人数</li><li>最大同时在线数</li><li>发生的时间</li><li>当前用户数</li><li>最后一次访问时间</li><li>访问次数</li><li>IP地址</li></ul></li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&emsp;&emsp;Listener和Filter一样是Servlet的高级特性，提供辅助性功能，与Servlet没有任何耦合。Filter用于过滤request与response，而Listener用于监控context、Session、request相关的事情。</p><h1 id="附：电子邮件"><a href="#附：电子邮件" class="headerlink" title="附：电子邮件"></a>附：电子邮件</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li>邮件服务器：<ul><li>要在Internet上提供电子邮件功能，必须有专门的电子邮件服务器。例如现在Internet很多提供邮件服务的厂商：sina、sohu、163等等他们都有自己的邮件服务器。</li><li>邮件服务器类似于邮局，主要负责接收用户投递过来的邮件，并把邮件投递到邮件接收者的电子邮箱中。</li><li>邮件服务器，按照提供的服务类型，可以分为发送邮件的服务器和接收邮件的服务器</li></ul></li><li>电子邮箱：<ul><li>电子邮箱（E-mail地址）的获得需要在邮件服务器上进行申请，电子邮箱即用户在邮件服务器上申请的一个账户。用户在邮件服务器上申请了一个账号后，邮件服务器会为这个账户分配一定的空间，用户可以使用这个账户以及空间，发送电子邮件和保存别人发送过来的电子邮件。</li></ul></li></ul><h2 id="邮件协议"><a href="#邮件协议" class="headerlink" title="邮件协议"></a>邮件协议</h2><ul><li>SMTP协议—发邮件协议<ul><li>全称为Simple Mail Transfer Protocol(简单邮件传输协议)，它定义了邮件客户端软件与SMTP服务器之间、以及两台SMTP服务器之间的通讯规则。</li><li>端口号：25</li></ul></li><li>POP3协议—收邮件协议<ul><li>全称为Post Office Protocol(邮局协议)，他定义了邮件客户端软件与POP3服务器的通讯规则。</li><li>端口号：110<br><img src="/2019/01/23/监听器Listener/发送邮件的流程.jpg" alt="发送邮件的流程"></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;监听器Listener&quot;&gt;&lt;a href=&quot;#监听器Listener&quot; class=&quot;headerlink&quot; title=&quot;监听器Listener&quot;&gt;&lt;/a&gt;监听器Listener&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;监听器是一个实现特定接口的普通Java程序，
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://blog.letmefly.cc/categories/JavaWeb/"/>
    
    
      <category term="Web" scheme="http://blog.letmefly.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>JSP和JSTL以及EL</title>
    <link href="http://blog.letmefly.cc/2019/01/09/JSP%E5%92%8CJSTL%E4%BB%A5%E5%8F%8AEL/"/>
    <id>http://blog.letmefly.cc/2019/01/09/JSP和JSTL以及EL/</id>
    <published>2019-01-09T12:09:00.000Z</published>
    <updated>2019-01-21T12:21:19.639Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP技术"><a href="#JSP技术" class="headerlink" title="JSP技术"></a>JSP技术</h1><p>&emsp;&emsp;JSP全名是Java Server Page，他是建立在Servlet规范之上的动态网页开发技术。在JSP文件中，HTML代码与Java代码共同存在，其中，HTML代码用来实现网页中静态内容的显示，Java代码用来实现网页中的动态内容的显示。为了与传统的HTML有所区别，JSP文件的扩展名为.jsp。<br>&emsp;&emsp;JSP技术所开发的Web应用程序是基于Java语言的，他可以使用一种简洁而快速的方法从Java程序生成Web页面，其使用上具有以下特征：</p><ul><li>跨平台：由于JSP是基于Java语言的，他可以使用Java API，所以他也是跨平台的，可以应用于不同的系统中，如Windows、Linux等。当从一个平台移植到另一个平台时，JSP和JavaBean的代码并不需要重新编译，因为Java的字节码是与平台无关的，这也验证了Java语言”一次编译，到处运行“的特点。</li><li>业务代码分离：再使用JSP技术开发Web应用时，可以将界面的开发与应用程序的开发分离开。开发人员使用HTML来设计界面，使用JSP标签和脚本来动态生成页面上的内容。在服务器端，JSP引擎(或容器，如Tomcat)负责解析JSP标签和脚本程序，生成所请求的内容，并将执行结果以HTML页面的形式返回给浏览器。</li><li>组件重用：JSP中可以使用JavaBean编写业务组件，也就是使用一个JavaBean类封装业务处理代码或者作为一个数据存储模型，在JSP页面中，甚至在整个项目中，都可以重复使用这个JavaBean，同时，JavaBean也可以应用到其他Java应用程序中。</li><li>预编译：预编译指的是用户第一次通过浏览器访问JSP页面时，服务器将对JSP页面代码进行编译，并且仅执行一次编译。编译好的代码被保存，用户下一次访问时，会执行编译好的代码。这样不仅节约了服务器的CPU资源，还大大的提升了客户端的访问速度。</li></ul><p>JSP文件必须发布到Web容器中的某个Web应用中才能查看出效果。  </p><p>JSP的运行过程具体如下：<br>（1）客户端发送请求，请求访问JSp文件；<br>（2）JSP容器先将JSP文件转换成一个Java源文件（Java Servlet源程序），在转换过程中，如果发现JSP文件存在任何语法错误，则中断转换过程，并向服务器端和客户端返回出错信息。<br>（3）如果转换成功，则JSP容器将生成Java源文件编译成相应的字节码文件*.class。该class文件就是一个Servlet，Servlet容器会像处理其他Servlet一样来处理它。</p><h2 id="JSP基本语法"><a href="#JSP基本语法" class="headerlink" title="JSP基本语法"></a>JSP基本语法</h2><p>详见另一篇文章JSP技术，这里不再赘述。</p><h1 id="Java-Bean及内省"><a href="#Java-Bean及内省" class="headerlink" title="Java Bean及内省"></a>Java Bean及内省</h1><h2 id="什么是JavaBean"><a href="#什么是JavaBean" class="headerlink" title="什么是JavaBean"></a>什么是JavaBean</h2><ul><li>Java Bean是一个遵守特定写法的Java类，通常具有如下特点：<br>1：这个Java类必须具有一个无参的构造函数<br>2：属性私有化<br>3：私有化的属性必须通过public类型的方法暴露给其他程序，并且方法的命名也必须遵守一定的命名规范。</li><li>Java Bean在J2EE开发中，通常用于<font color="red">数据封装</font>，对于遵守以上写法的Java Bean组件，其他程序可以通过反射技术实例化Java Bean对象，并且通过反射那些遵守命名规范的方法，从而货值Java Bean的属性，进而调用其属性保存数据。</li></ul><h2 id="Java-Bean的属性"><a href="#Java-Bean的属性" class="headerlink" title="Java Bean的属性"></a>Java Bean的属性</h2><ul><li>Java Bean的属性可以是任意类型，并且一个Java Bean可以有多个属性。每个属性都需要具有相应的setter、getter方法，setter方法称为属性修改器，getter方法称为属性访问器。</li><li>属性修改器必须以小写的set前缀开始，后跟属性名，且属性名的第一个字母要改为大写，例如，name属性的修改器名称为setName，password属性的修改名称为setPassword。</li><li>属性访问器必须以小写的get前缀开始，后跟属性名，且属性名的第一个字母要改为大写，例如，name属性的访问器名称为getName，password属性的访问器名称为getPassword。</li><li><font>一个Java Bean的某个属性也可以只有set方法或get，这样的属性也常称为只读、只写属性。</font></li></ul><h2 id="在JSP中使用Java-Bean"><a href="#在JSP中使用Java-Bean" class="headerlink" title="在JSP中使用Java Bean"></a>在JSP中使用Java Bean</h2><ul><li>JSP技术提供了三个关于Java Bean组件的动作元素，即JSP标签，它们分别是：<br>1：\<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标签：用于在JSP页面中查找或实例化一个Java Bean组件。<br>2：\<a href="jsp:setProperty" target="_blank" rel="noopener">jsp:setProperty</a>标签：用于在JSP页面中设置一个Java Bean组件的属性。<br>3：\<a href="jsp:getProperty" target="_blank" rel="noopener">jsp:getProperty</a>标签：用于在JSP页面中获取一个Java Bean组件的属性。</li></ul><h3 id="jsp-useBean标签"><a href="#jsp-useBean标签" class="headerlink" title="\jsp:useBean标签"></a>\<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标签</h3><ul><li>\<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标签用于在指定的域范围内查找指定名称的Java Bean对象：<ul><li>如果存在则直接返回该Java Bean对象的引用。</li><li>如果不存在则实例化一个新的Java Bean对象，并将它以指定的名称存储到指定的域范围中。</li></ul></li><li>常用语法<ul><li>\&lt;jsp:useBean id=”beanName” class=”cn.itcast.Test” scope=”page|request|session|application” /&gt;</li><li>id属性用于指定Java Bean实例对象的引用名称和其存储在域范围中的名称</li><li>class属性用于指定Java Bean的完整类名(即必须带有包名)</li><li>scope属性用于指定Java Bean实例对象所存储的域范围，其取值只能是page、request、session和application等四个值中的一个，其默认是page。</li></ul></li></ul><h4 id="jsp-useBean执行原理"><a href="#jsp-useBean执行原理" class="headerlink" title="\jsp:useBean执行原理"></a>\<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>执行原理</h4><ul><li>\&lt;jsp:useBean id=”currentDate” class=”java.util.Date”&gt;</li><li>翻译成Servlet源码</li></ul><h4 id="带标签体的-jsp-useBean标签"><a href="#带标签体的-jsp-useBean标签" class="headerlink" title="带标签体的\jsp:useBean标签"></a>带标签体的\<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标签</h4><ul><li>语法：<br>  \<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a><pre><code>Body</code></pre>  \&lt;/jsp:useBean&gt;  </li><li>功能：<br>  Body部分的内容只在\<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标签创建JavaBean的实例对象时才执行。</li></ul><h4 id="jsp-setProperty标签"><a href="#jsp-setProperty标签" class="headerlink" title="\jsp:setProperty标签"></a>\<a href="jsp:setProperty" target="_blank" rel="noopener">jsp:setProperty</a>标签</h4><ul><li>\<a href="jsp:setProperty" target="_blank" rel="noopener">jsp:setProperty</a>标签用于设置和访问Java Bean对象的属性</li><li>语法格式:\&lt;jsp:setProperty name=”beanName”{<br>  &emsp;&emsp;&emsp;property=”propertyName” value=”{string | &lt;%=expression%&gt;}” |  <pre><code>&amp;emsp;&amp;emsp;&amp;emsp;property=&quot;propertyName&quot; [param=&quot;parameterName&quot;] |  &amp;emsp;&amp;emsp;&amp;emsp;property=&quot;*&quot;  </code></pre>  }/&gt;  <ul><li>name属性用于指定Java Bean对象的名称。  </li><li>property属性用于指定Java Bean实例对象的属性名。  </li><li>value属性用于指定Java Bean对象的某个属性的值，value的值可以使字符串，也可以是表达式。为字符串时，该值会自动转换为Java Bean属性相应的类型，如果value的值是一个表达式，那么该表达式的计算结果必须与所要设置的Java Bean属性的类型一致。  </li><li>param属性用于将Java Bean实例对象的某个属性值设置为一个请求参数值，该属性值同样会自动转换成要设置的Java Bean属性的类型。</li></ul></li></ul><h4 id="jsp-getProperty标签"><a href="#jsp-getProperty标签" class="headerlink" title="\jsp:getProperty标签"></a>\<a href="jsp:getProperty" target="_blank" rel="noopener">jsp:getProperty</a>标签</h4><ul><li>\<a href="jsp:getProperty" target="_blank" rel="noopener">jsp:getProperty</a>标签用于读取Java Bean对象的属性，也就是调用Java Bean对象的getter方法，然后将读取的属性值转换为字符串后插入进输出的响应正文中。</li><li>语法：<ul><li>\&lt;jsp:getProperty name=”beanInstanceName” property=”PropertyName” /&gt;<ul><li>name属性值用于指定Java Bean实例对象的名称，其值应与\<a href="jsp:useBean" target="_blank" rel="noopener">jsp:useBean</a>标签的id属性值相同。</li><li>property属性用于指定Java Bean实例对象的属性名。</li></ul></li></ul></li><li>如果一个Java Bean实例对象的某个属性为null，那么，使用\<a href="jsp:getProperty" target="_blank" rel="noopener">jsp:getProperty</a>标签输出该属性的结果将是一个内容为“null”的字符串。</li></ul><h2 id="内省-Introspector-—-Java-Bean"><a href="#内省-Introspector-—-Java-Bean" class="headerlink" title="内省(Introspector) — Java Bean"></a>内省(Introspector) — Java Bean</h2><ul><li><p>访问Java Bean属性的两种方式：</p><ul><li>直接调用bean的setXXX或者getXXX方法；</li><li><p>通过内省技术访问(java.beans包提供了内省的API)</p><ul><li>内省技术是基于反射技术的。</li><li><p>通过Introspector类获得Bean对象的BeanInfo，然后通过BeanInfo来获取属性的描述器(PropertyDescriptor),通过这个属性描述器就可以获取某个属性对应的getter/setter方法，然后通过反射机制来调用这些方法。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void populate(Map&lt;String, String[]&gt; map, User user)&#123;</span><br><span class="line">BeanInfo info = Introspector.getBeanInfo(user.class);  </span><br><span class="line">PropertyDescriptor[] pds = info.getPropertyDescriptors();  </span><br><span class="line">for(PropertyDescriptor pd : pds)&#123;</span><br><span class="line">String attrName = pd.getName();</span><br><span class="line">if(map.containsKey(attrName))&#123;</span><br><span class="line">Method m = pd.getWriteMethod();</span><br><span class="line">m.invoke(user, map.get(attrName)[0]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul><h3 id="内省—-beanutils工具包"><a href="#内省—-beanutils工具包" class="headerlink" title="内省—-beanutils工具包"></a>内省—-beanutils工具包</h3><ul><li>Apache组织开发了一套用于操作Java Bean的API，这套API考虑到了很多实际开发中的应用场景，因此在实际开发中很多人都使用这套API操作Java Bean，以简化程序代码的编写。</li><li>Beanutils工具包的常用类：<ul><li>Beanutils<ul><li>populate(Object bean, Map properties)</li></ul></li><li>自定义转换器<ul><li>ConvertUtils.register(Converter convert, Class clazz)</li><li>传入日期类型的Date.class</li></ul></li></ul></li></ul><h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><h2 id="EL表达式简介"><a href="#EL表达式简介" class="headerlink" title="EL表达式简介"></a>EL表达式简介</h2><p>&emsp;&emsp;EL全名为Expression Language，是一种表达式语言，它对应&lt;%=…%&gt;。在JSP中，表达式会被输出，所以EL表达式也会被输出。EL表达式的目的是为了使JSP写起来更加简单，它提供了在JSP中简化表达式的方法，让JSP的代码更加简化。<br>EL表达式格式:<code>${表达式}</code>,例如,${1 + 2}<br>在使用EL表达式时，要求page指令的isELIgnored属性为false。这样在JSP编译成.java时，才不会忽略EL表达式。如果你希望某个EL表达式被JSP编辑器忽略，那么可以在EL表达式之前添加“\”,例如：\ ${1+2}.<br>EL主要作用：</p><ul><li>获取数据<ul><li>EL表达式主要用于替换JSP页面中的脚本表达式，以各种类型的web域中检索Java对象、获取数据。(某个web域中的对象，访问Java Bean的属性，访问list集合、访问map集合、访问数组)</li></ul></li><li>执行运算<ul><li>利用EL表达式可以在JSP页面中执行一些基本的关系运算、逻辑运算和算术运算，以及在JSP页面中完成一些简单的逻辑运算。${user == null}</li></ul></li><li>获取web开发常用对象<ul><li>EL表达式定义了一些隐式对象，利用这些隐式对象，web开发人员可以很轻松获得对web常用对象的引用，从而获得这些对象中的数据。</li></ul></li><li>调用Java方法<ul><li>EL表达式允许用户开发自定义EL函数，以在JSP页面中通过EL表达式调用Java类方法。</li></ul></li></ul><h2 id="EL注意事项"><a href="#EL注意事项" class="headerlink" title="EL注意事项"></a>EL注意事项</h2><ul><li>EL表达式是JSP2.0(JavaEE1.4)规范中的一门技术。因此，若想正确解析EL表达式，需使用支持Servlet2.4/JSP2.0技术的WEB服务器。</li><li>注意：有些Tomcat服务器如果不能使用EL表达式<ul><li>（1）升级成Tomcat6</li><li>（2）在JSP中加入\&lt;%@page isELlgnored=”false”%&gt;</li></ul></li></ul><h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><ul><li>使用EL表达式获取数据语法：”${标识符}”</li><li>EL表达式语句在执行时，会调用pageContext.findAttribute方法，用标识符为关键字，分别从page、request、session、application四个域中查找相应的对象，找到则返回相应对象，找不到则返回” “。（注意，不是null，而是空字符串）</li><li>示例：${user}</li><li>EL表达式也可以很轻松获取Java Bean的属性，或获取数组、Collection、Map类型集合的数据，例如：<ul><li>${user.address.city}</li><li>${user.list[0]}:访问<font color="blue">有序集合某个位置的元素</font></li><li>${map.key}:获得map集合中指定key的值</li></ul></li><li>[]和.的区别</li><li>结合JSTL的foreach标签，使用EL表达式也可以很轻松迭代各种类型的数组或集合，示例：<ul><li>迭代数组</li><li>迭代collection类型集合</li><li>迭代map类型集合  </li></ul></li></ul><h3 id="执行运算"><a href="#执行运算" class="headerlink" title="执行运算"></a>执行运算</h3><ul><li>语法：${运算表达式}，EL表达式支持如下运算符：  </li></ul><table><thead><tr><th>关系运算符</th><th>说明</th><th>范例</th><th>结果</th></tr></thead><tbody><tr><td>== 或 eq</td><td>等于</td><td>${5 == 5} 或 ${5 eq 5}</td><td>true</td></tr><tr><td>!= 或 ne</td><td>不等于</td><td>${5 != 5} 或 ${5 ne 5}</td><td>false</td></tr><tr><td>&lt; 或 lt</td><td>小于</td><td>${3 &lt; 5} 或 ${3 lt 5}</td><td>true</td></tr><tr><td>&gt; 或 gt</td><td>大于</td><td>${3 &gt; 5} 或 ${3 gt 5}</td><td>false</td></tr><tr><td>&lt;= 或 le</td><td>小于等于</td><td>${3 &lt;= 5} 或 ${3 le 5}</td><td>true</td></tr><tr><td>&gt;= 或 ge</td><td>大于等于</td><td>${3 &gt;= 5} 或 ${3 ge 5}</td><td>false</td></tr></tbody></table><table><thead><tr><th>逻辑运算符</th><th>说明</th><th>范例</th><th>结果</th></tr></thead><tbody><tr><td>&amp;&amp; 或 and</td><td>交集</td><td>${A &amp;&amp; B} 或 ${A and B}</td><td>true/false</td></tr><tr><td>\</td><td>\</td><td>或 or</td><td>并集</td><td>${A \</td><td>\</td><td>B} 或 ${A or B}</td><td>true/false</td></tr><tr><td>! 或 not</td><td>非</td><td>${!A} 或 ${not A}</td><td>true/false</td></tr></tbody></table><ul><li>empty运算符：检查对象是否为null或”空“</li><li>二元表达式：${user != null ? user.name : “”}</li></ul><h3 id="EL表达式保留关键字"><a href="#EL表达式保留关键字" class="headerlink" title="EL表达式保留关键字"></a>EL表达式保留关键字</h3><table><thead><tr><th>—–</th><th>—–</th><th>—–</th><th>——</th></tr></thead><tbody><tr><td>And</td><td>eq</td><td>gt</td><td>true</td></tr><tr><td>Or</td><td>ne</td><td>le</td><td>false</td></tr><tr><td>No</td><td>lt</td><td>ge</td><td>null</td></tr><tr><td>instanceof</td><td>empty</td><td>div</td><td>mod</td></tr></tbody></table><h3 id="获得web开发常用对象"><a href="#获得web开发常用对象" class="headerlink" title="获得web开发常用对象"></a>获得web开发常用对象</h3><ul><li>EL表达式语言中定义了11个隐含对象，其中10个是Map，一个是PageContext。使用这些隐含对象可以很方便地获取web开发中的一些常见对象，并读取这些对象的数据。</li><li>语法：${隐式对象名称}：获得对象的引用</li></ul><table><thead><tr><th>隐含对象名称</th><th>描述</th></tr></thead><tbody><tr><td>pageContext</td><td>对应于JSP页面中的pageContext对象（注意：取的是pageContext对象）</td></tr><tr><td>pageScope</td><td>代表page域中用于保存属性的Map对象</td></tr><tr><td>requestScoppe</td><td>代表request域中用于保存属性的Map对象</td></tr><tr><td>sessionScope</td><td>代表session域中用于保存属性的Map对象</td></tr><tr><td>applicationScope</td><td>代表application域中用于保存属性的Map对象</td></tr><tr><td>param</td><td>表示一个保存了所有请求参数的Map对象</td></tr><tr><td>paramValues</td><td>表示一个保存了所有请求参数的Map对象，它对于某个请求参数，返回的是一个string[]</td></tr><tr><td>header</td><td>表示一个保存了所有http请求头字段的Map对象</td></tr><tr><td>headerValues</td><td>同上，返回string[]数组。注意：如果头里面有”-“，例如Accept-Encoding，则要headerValues[“Accept-Encodings”]</td></tr><tr><td>cookie</td><td>表示保存了所有cookie的Map对象</td></tr><tr><td>initParam</td><td>表示一个保存了所有web应用初始化参数的map对象</td></tr></tbody></table><ul><li>测试各个隐式对象</li><li>注意事项：<ul><li>测试headerValues时，如果头里面有”-“，例如Accept-Encoding，则要headerValues[“Accept-Encoding”]</li><li>测试cookie时，例${cookie.key}取的是cookie对象，如访问cookie的名称和值，须${cookie.key.name}或${cookie.key.value}</li></ul></li></ul><h3 id="EL操作对象的方式"><a href="#EL操作对象的方式" class="headerlink" title="EL操作对象的方式"></a>EL操作对象的方式</h3><ul><li>操作List和数组：${list[0]、${arr[0];}}</li><li>操作bean的属性：${person.name}、${person[‘name’]，对应person.name方法}</li><li>操作Map的值：${map.key}、${map[‘key’]},对应map.get(key)</li></ul><h3 id="使用EL调用Java方法"><a href="#使用EL调用Java方法" class="headerlink" title="使用EL调用Java方法"></a>使用EL调用Java方法</h3><ul><li>EL表达式语法允许开发人员开发自定义函数，以调用Java类的方法。<ul><li>示例：${prefix: method(params)}</li><li>在EL表达式中调用的只能是Java类的静态方法。</li><li>Java类的静态方法需要在TLD文件中描述，才可以被EL表达式调用</li><li>EL自定义函数用于扩展EL表达式的功能，可以让EL表达式完成普通Java程序代码所能完成的功能。</li></ul></li></ul><h3 id="EL-Function开发步骤"><a href="#EL-Function开发步骤" class="headerlink" title="EL Function开发步骤"></a>EL Function开发步骤</h3><ul><li>一般来说，EL自定义函数开发与应用包括以下三个步骤：<ul><li>编写一个Java类的静态方法</li><li>编写<font color="blue">标签库描述符(tld)文件</font>，在tld文件中描述自定义函数。</li><li>在JSP页面中导入和使用自定义函数。</li></ul></li><li>编写完标签库描述文件后，需要将其放置到\&lt;web应用&gt;\WEB-INF目录中或WEB-INF目录下的除了classes和lib目录之外的任意子目录中。</li><li>TLD文件中的\<uri>元素用指定该TLD文件的URI，在JSP文件中需要通过这个URI来引入该标签库描述文件。</uri></li><li>\<function>元素用于描述一个EL自定义函数，其中：<ul><li>\<name>子元素用于指定EL自定义函数的名称。</name></li><li>\<function-class>子元素用于指定<font color="blue">完整的Java类名</font></function-class></li><li>\<function-signature>子元素用于指定Java类中的静态方法的签名，方法签名必须指明方法的返回值类型以及各个参数的类型，各个参数之间用逗号分隔。</function-signature></li></ul></function></li></ul><h4 id="SUN公司：EL函数库"><a href="#SUN公司：EL函数库" class="headerlink" title="SUN公司：EL函数库"></a>SUN公司：EL函数库</h4><p>网页开发中常引入sun公司开发的jstl表达式。</p><ul><li>由于在JSP页面中显示数据时，经常需要对显示的字符串进行处理，SUN公司针对一些常见处理定义了一套EL函数库供开发者使用。</li><li>这些EL函数在JSTL开发包中进行描述，因此在JSP页面中使用SUN公司的EL函数库，需要导入JSTL开发包，并在页面中导入EL函数库，如下所示：<ul><li>在页面中使用JSTL定义的EL函数：</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt;</span><br></pre></td></tr></table></figure><p>JSTL搭配EL主要使用循环、判断，用来获取、显示数据。<br>JSTL标准标签库包括核心标签库和SQL标签库，核心标签库常用的是if和forEach<br>EL即Expression Language（表达式语言）<br>EL的语法:${ EL exprission }<br>//$</p><h1 id="JSTL"><a href="#JSTL" class="headerlink" title="JSTL"></a>JSTL</h1><h2 id="什么是JSTL"><a href="#什么是JSTL" class="headerlink" title="什么是JSTL"></a>什么是JSTL</h2><p>&emsp;&emsp;JSTL是apache对EL表达式的扩展（就是说JSTL依赖EL），JSTL是标签语言。<br><img src="/2019/01/09/JSP和JSTL以及EL/JSTL标签库结构.jpg" alt="JSTL标签库结构"></p><h3 id="JSTL的作用"><a href="#JSTL的作用" class="headerlink" title="JSTL的作用"></a>JSTL的作用</h3><ul><li>提供给Java Web开发人员一个标准通用的标签函数库</li><li>和EL来取代传统直接在页面上嵌入Java程序（Scripting）的做法，以提高程序可读性、维护性和方便性。</li></ul><h3 id="倒入标签库"><a href="#倒入标签库" class="headerlink" title="倒入标签库"></a>倒入标签库</h3><p>&emsp;&emsp;导入标签库需要使用taglib指令！<br>&emsp;&emsp;\&lt;% taglib prefix=”c” uri=”<a href="http://java.sun.com/jstl/core&quot;%&gt;" target="_blank" rel="noopener">http://java.sun.com/jstl/core&quot;%&gt;</a></p><h2 id="JSTL核心库"><a href="#JSTL核心库" class="headerlink" title="JSTL核心库"></a>JSTL核心库</h2><p>1.out和set（重点）<br>out。  </p><table><thead><tr><th>标签</th><th>结果</th></tr></thead><tbody><tr><td>\&lt;c:out value=”aaa” /&gt;</td><td>输出aaa字符串常量</td></tr><tr><td>\&lt;c:out value=”${aa}” /&gt;</td><td>与${aaa}相同</td></tr><tr><td>\&lt;c:out value=”${aa}” default=”xxx” /&gt;</td><td>当${aaa}不存在时，输出xxx字符串</td></tr><tr><td>\&lt;%requets.setAttribute(“a”,”\<script>alert(‘hello’);\</script>“);%/&gt; &lt;c:out value=”${a}” default=”xxx” escapeXml=”false”</td><td>当escapeXml为false，不会转换”&lt;”,”&gt;”。这可能会受到JavaScript攻击。</td></tr><tr><td>\&lt;c:set var=”a” value=”hello” /&gt;</td><td>在pageContext中添加name为a，value为hello的数据</td></tr><tr><td>\&lt;c:set var=”a” value=”hello” scope=”session”/&gt;</td><td>在session中添加name为a，value为hello的数据</td></tr><tr><td>\&lt;jsp:useBean id=”user” class=”cn.usst.domain.User” /&gt; \&lt;c:set target=”${user}” property=”username” value=”qdmmy6” /&gt; \&lt;c:out value=”${user}” /&gt;</td><td>给user的username属性赋值qdmmy6</td></tr></tbody></table><p>set：set标签的var、value、scope是一组，而target、property、value是一组。</p><p>2.remove</p><table><thead><tr><th>标签</th><th>结果</th></tr></thead><tbody><tr><td>\&lt;% pageContext.setAttribute(“a”,”pageContext”);pageContext.setAttribute(“a”,”request”);pageContext.setAttribute(“a”,”session”);pageContext.setAttribute(“a”,”application”);%&gt;\&lt;c:remove value=”a” /&gt; \&lt;c:out value=”${a}” default=”none”/&gt;</td><td>删除所有域中name为a的数据</td></tr><tr><td>\&lt;c:remove var=”a” scope=”page” /&gt;</td><td>删除pageContext域中name为a的数据</td></tr></tbody></table><p>3.url<br>url标签会在需要URL重写时添加sessionid</p><table><thead><tr><th>标签</th><th>结果</th></tr></thead><tbody><tr><td>\&lt;c:url value=”/“ /&gt;</td><td>输出上下文路径：/day08/</td></tr><tr><td>\&lt;c:url var=”$a” /&gt; scope=”request”</td><td>把本该输出的结果赋给变量a。范围为request</td></tr></tbody></table><ol start="4"><li>if和choose（重点）<br>&emsp;&emsp;if标签的test属性必须是一个boolean类型的值，如果test的值为true，那么执行if标签的内容，否则不执行。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var=&quot;a&quot; value=&quot;hello&quot; /&gt;</span><br><span class="line">&lt;c:if test=&quot;$&#123;not empty a&#125;&quot; value=&quot;hello&quot; /&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;a &#125;&quot;&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure><p>choose标签对应Java中的if/else if/else结构<br>when标签的test为true时，会执行这个when的内容。<br>当所有when标签的test都为false时，才会执行otherwise标签的内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var=&quot;score&quot; value=&quot;param.score&quot; /&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;score &gt; 100&#125; || score &lt; 0&quot;&gt;错误的分数：$&#123;score &#125;&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;score &gt;= 90&#125;&quot;&gt;A级&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;score &gt;= 80&#125;&quot;&gt;B级&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;score &gt;= 70&#125;&quot;&gt;C级&lt;/c:when&gt;</span><br><span class="line">&lt;c:when test=&quot;$&#123;score &gt;= 60&#125;&quot;&gt;D级&lt;/c:when&gt;</span><br><span class="line">&lt;c:oterwise&gt;E级&lt;/c:when&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>forEach（重点）<br>&emsp;&emsp;forEach是循环标签，下面例子中设置域变量为i，初始值为1，结束值为100.即i的值从1遍历到100，包含100.</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:set var=&quot;sum&quot; value=&quot;0&quot; /&gt;</span><br><span class="line">&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot;&gt;</span><br><span class="line">&lt;c:set var=&quot;sum&quot; value=&quot;$&#123;sum + i &#125;&quot;&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;c:out value=&quot;sum=$&#123;sum &#125;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:set var=&quot;sum&quot; value=&quot;0&quot; /&gt;</span><br><span class="line">&lt;c:forEach var=&quot;i&quot; begin=&quot;1&quot; end=&quot;10&quot; step=&quot;2&quot;&gt;</span><br><span class="line">&lt;c:set var=&quot;sum&quot; value=&quot;$&#123;sum + i &#125;&quot;&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br><span class="line">&lt;c:out value=&quot;sum=$&#123;sum &#125;&quot;&gt;</span><br></pre></td></tr></table></figure><p>还可以使用forEach来遍历数据或集合，遍历数组：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String[] names = &#123;&quot;zhangSan&quot;,&quot;liSi&quot;,&quot;wangWu&quot;,&quot;zhaoLiu&quot;&#125;</span><br><span class="line">pageContext.setAttribute(&quot;ns&quot;, names);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach var=&quot;item&quot; items=&quot;$&#123;ns&#125;&quot;&gt;</span><br><span class="line">&lt;c:out value=&quot;name:$&#123;item &#125;&quot;&gt;&lt;/br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>遍历list  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">List&lt;String&gt; names = new ArrayList&lt;String&gt;();</span><br><span class="line">names.add(&quot;zhangsan&quot;);</span><br><span class="line">names.add(&quot;lisi&quot;);</span><br><span class="line">names.add(&quot;zhaoLiu&quot;);</span><br><span class="line">pageContext.setAttribute(&quot;ns&quot;, names);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach var=&quot;item&quot; items=&quot;$&#123;ns&#125;&quot;&gt;</span><br><span class="line">&lt;c:out value=&quot;name:$&#123;item &#125;&quot;&gt;&lt;/br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>遍历Map  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">Map&lt;String,String&gt; stu = </span><br><span class="line">new LinkedHashMap&lt;String, String&gt;();</span><br><span class="line">stu.put(&quot;number&quot;,&quot;N_1001&quot;);</span><br><span class="line">stu.put(&quot;name&quot;,&quot;zhangSan&quot;);</span><br><span class="line">stu.put(&quot;age&quot;,&quot;23&quot;);</span><br><span class="line">pageContext.setAttribute(&quot;stu&quot;, stu);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;c:forEach var=&quot;item&quot; items=&quot;$&#123;stu&#125;&quot;&gt;</span><br><span class="line">&lt;c:out value=&quot;$&#123;item.key&#125;:$&#123;item.value&#125;&quot;&gt;&lt;/br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;forEach标签还有一个属性：varStatus，这个属性用来指定接收”循环状态“的变量名，例如：\<foreach varstatus="vs" ...="">，这时就可以使用vs这个变量来获取循环的状态了。</foreach></p><ul><li>count：int类型，当前已遍历元素的个数</li><li>index:int类型，当前元素的下标</li><li>first：boolean类型，是否为第一个元素</li><li>last：boolean类型，是否为最后一个元素</li><li>current：Object类型，表示当前项目</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;c:forEach var=&quot;item&quot; items=$&#123;ns &#125; varStatus=&quot;vs&quot;&gt;</span><br><span class="line">&lt;c:if test=$&#123;vs.first &#125;&gt;第一行&lt;/c:if&gt;</span><br><span class="line">&lt;c:if test=$&#123;vs.last &#125;&gt;最后一行&lt;/c:if&gt;</span><br><span class="line">&lt;c:out value=&quot;第$&#123;vs.count行：&quot; &#125; /&gt;</span><br><span class="line">&lt;c:out value=&quot;[$&#123;vs.index&#125;]: &quot; /&gt;</span><br><span class="line">&lt;c:out value=&quot;name: $&#123;vs.current&#125;&quot; /&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure><h1 id="JSP开发模式"><a href="#JSP开发模式" class="headerlink" title="JSP开发模式"></a>JSP开发模式</h1><ul><li>Sun公司推出JSP技术后，同时也推荐了两种web应用程序的开发模式，一种是JSP+JavaBean，另一种是Servlet+JSP+JavaBean模式。</li><li>JSP+JavaBean模式适合开发业务逻辑不太复杂的web应用，在这种模式下，servlet负责处理用户请求，JavaBean负责封装数据。Servlet+JSP+JavaBean模式下，程序各个模块之间层次清晰，web开发推荐采用这种模式。</li></ul><h2 id="Model1-设计模型"><a href="#Model1-设计模型" class="headerlink" title="Model1 设计模型"></a>Model1 设计模型</h2><p>JSP  完成逻辑上的处理和显示<br><img src="/2019/01/09/JSP和JSTL以及EL/模式1.png" alt="模式1"><br>JSP Model 1的特点：<br>（a）JSP页面负责响应用户的请求并将处理结果返回用户；<br>（b）JSP既要负责业务流程控制，又要负责提供表示层数据；<br>（c）供表示层数据，同时充当视图和控制器<br>（d）适合简单的应用的需求</p><p>Model1使得Java代码与HTML代码强耦在一起，导致视图与逻辑无法分离，使程序的可读性大大降低，使代码调试以及后期维护都带来了很大的困难。</p><h2 id="Model2-设计模型"><a href="#Model2-设计模型" class="headerlink" title="Model2 设计模型"></a>Model2 设计模型</h2><ul><li>Servlet：控制层，负责找到合适的模型对象来处理业务逻辑，转发到合适的视图。（控制显示哪个JSP页面给用户，调用哪个JavaBean）</li><li>JSP：视图层，用来与用户打交道。负责接收用来的数据，以及显示数据给用户（响应用户请求，把结果数据展现给用户）</li><li>JavaBean：模型层，完成具体的业务工作（对数据库的数据的存取，复杂的业务功能和逻辑处理）<br><img src="/2019/01/09/JSP和JSTL以及EL/模式2.png" alt="模式2"></li></ul><p>Model1和Model2的文字描述图<br><img src="/2019/01/09/JSP和JSTL以及EL/02-JSP模式.bmp" alt="JSP模式"></p><h2 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h2><p>&emsp;&emsp;MVC是软件工程中一种软件架构模式，是一种分离业务逻辑与显示界面的设计方法。注意，MVC不是Java所特有的，几乎现在所有B/S结构的软件都采用了MVC设计模式。</p><ul><li>MVC是Model-View-Controller的简称<ul><li>M：Model—-模型：JavaBean：封装数据，编写程序应用的功能（实现算法、数据库管理等）</li><li>V：View—–视图：（JSP）界面设计人员进行图形界面设计，单纯进行页面的展示</li><li>C：Controller—-控制器：Servlet：获取数据–对数据进行封装—传递数据—指派显示的jsp页面，对请求进行处理，负责请求转发    </li></ul></li><li>MVC是一种设计模式</li><li>把应用程序分成三个核心模块<ul><li>模型、视图、控制器<br><img src="/2019/01/09/JSP和JSTL以及EL/MVC模式.png" alt="MVC模式"><br><img src="/2019/01/09/JSP和JSTL以及EL/03-MVC开发流程.bmp" alt="MVC开发流程"><br><img src="/2019/01/09/JSP和JSTL以及EL/MVC设计模式.jpg" alt="MVC开发流程"></li></ul></li></ul><h3 id="软件的三层架构"><a href="#软件的三层架构" class="headerlink" title="软件的三层架构"></a>软件的三层架构</h3><p>表述层（web）、业务逻辑层（Business Logic）、数据层（Data）。<br>web层：JSP和Servlet，都是与web相关的东西。与客户端交互<br>业务层：通常以Service为后缀，对应一个业务。复杂业务处理，专门用于处理业务数据<br>数据层：通常以Dao为后缀，用来访问数据层。与数据库进行交互<br><img src="/2019/01/09/JSP和JSTL以及EL/模式.jpg" alt="模式"></p><h4 id="ORM映射"><a href="#ORM映射" class="headerlink" title="ORM映射"></a>ORM映射</h4><p>&emsp;&emsp;当Dao从数据库中读取到数据后，需要把数据转换成Java对象。所以需要ORM工具，可以把关系型数据库中的数据转换成Java对象。</p><h4 id="业务实体（实体域）"><a href="#业务实体（实体域）" class="headerlink" title="业务实体（实体域）"></a>业务实体（实体域）</h4><p>&emsp;&emsp;在Dao中，数据已经是Java对象了，这种Java对象我们称为业务实体类。它也是JavaBean，而且是最简单的JavaBean，例如User类、Book类等等。业务实体在Model中各个层之间传递。</p><h4 id="页面实体（FormBean）"><a href="#页面实体（FormBean）" class="headerlink" title="页面实体（FormBean）"></a>页面实体（FormBean）</h4><p>&emsp;&emsp;Service从Dao那里获取到的是实体域对象，然后Service会把实体域对象转换成页面实体对象，传递给Servlet。页面的实体是对应页面中的某个表单数据，或者对应页面中的某个表格。有时页面实业与业务实体是完全相同的，所以有时候偷懒，直接把业务实体传递到Web层。</p><h4 id="IOC解耦"><a href="#IOC解耦" class="headerlink" title="IOC解耦"></a>IOC解耦</h4><p>&emsp;&emsp;上层依赖底层，例如Servlet中需要创建Service对象，而Service中还要创建Dao对象。这就是强化了耦合。为了解决这一问题，需要使用IOC工具来解耦合。IOC首先要求我们面向接口编程，然后才能解耦。IOC使用通用工厂在各层之间解耦，可以在配置文件中通过配置为各个组件的依赖注入依赖。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="EL表达式-1"><a href="#EL表达式-1" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>从域中取出数据${域中存储的数据的name}<br><code>pageContext.request.contextPath</code></p><h2 id="JSTL标签（核心库）"><a href="#JSTL标签（核心库）" class="headerlink" title="JSTL标签（核心库）"></a>JSTL标签（核心库）</h2><p>&lt;%@ taglib uri=”” prefix=”c” %&gt;<br>\&lt;c:if test=” “&gt;<br>\&lt;c:forEach items=”数组或集合” var=”数组或集合中的每一个元素”&gt;</p><h2 id="JavaEE三层架构-MVC"><a href="#JavaEE三层架构-MVC" class="headerlink" title="JavaEE三层架构+MVC"></a>JavaEE三层架构+MVC</h2><ul><li>web层：收集页面数据，封装数据，传递数据，指定响应jsp页面</li><li>service层：逻辑业务代码的编写</li><li>dao层：数据库的访问代码的编写<br><img src="/2019/01/09/JSP和JSTL以及EL/javaEE三层架构.png" alt="javaEE三层架构"></li></ul><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p><img src="/2019/01/09/JSP和JSTL以及EL/显示商品列表.png" alt="javaEE三层架构"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSP技术&quot;&gt;&lt;a href=&quot;#JSP技术&quot; class=&quot;headerlink&quot; title=&quot;JSP技术&quot;&gt;&lt;/a&gt;JSP技术&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;JSP全名是Java Server Page，他是建立在Servlet规范之上的动态网页开发
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://blog.letmefly.cc/categories/JavaWeb/"/>
    
    
      <category term="JSP、JSTL、EL" scheme="http://blog.letmefly.cc/tags/JSP%E3%80%81JSTL%E3%80%81EL/"/>
    
  </entry>
  
  <entry>
    <title>mysql连接错误</title>
    <link href="http://blog.letmefly.cc/2019/01/05/mysql%E8%BF%9E%E6%8E%A5%E9%94%99%E8%AF%AF/"/>
    <id>http://blog.letmefly.cc/2019/01/05/mysql连接错误/</id>
    <published>2019-01-05T04:05:59.000Z</published>
    <updated>2019-01-14T01:46:21.245Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL无法连接"><a href="#MySQL无法连接" class="headerlink" title="MySQL无法连接"></a>MySQL无法连接</h1><p>&emsp;&emsp;之前朋友遇到一个问题，mysql8安装完成之后无法连接到数据库。错误如下：<br><img src="/2019/01/05/mysql连接错误/无法连接.png" alt="mysql无法连接"><br>一开始以为是服务没有启动，后来发现服务已经启动了。无奈只能找了网上的教程，网上说要在my.ini文件中加一句：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># skip_grant_tables</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;一开始的时候没有找到my.ini这个文件，后来在mysql的根目录下创建了一个my.ini的文件。该配置文件的大致内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[mysql]</span><br><span class="line"># 设置mysql客户端默认字符集</span><br><span class="line">default-character-set=utf8</span><br><span class="line"> </span><br><span class="line">[mysqld]</span><br><span class="line"># 设置3306端口</span><br><span class="line">port = 3306</span><br><span class="line"># 设置mysql的安装目录</span><br><span class="line">basedir=C:\wamp-all\mysql-5.7.13</span><br><span class="line"># 设置mysql数据库的数据的存放目录</span><br><span class="line">datadir=C:\wamp-all\sqldata</span><br><span class="line"># 允许最大连接数</span><br><span class="line">max_connections=20</span><br><span class="line"># 服务端使用的字符集默认为8比特编码的latin1字符集</span><br><span class="line">character-set-server=utf8</span><br><span class="line"># 创建新表时将使用的默认存储引擎</span><br><span class="line">default-storage-engine=INNODB</span><br><span class="line"></span><br><span class="line"># skip_grant_tables</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是加上这句话之后会导致另外一个错误，如下图所示：<br><img src="/2019/01/05/mysql连接错误/拒绝连接.png" alt="mysql无法连接"><br>无奈又把这句话注销掉，后来几经辗转，在网上看到说可以查看mysql的日志，其日志存放在mysql安装目录下的data下的尾缀为err的文件下，同时百度到了一篇由于data文件夹错误引起的mysql无法访问，附上原博客：<br><a href="https://blog.csdn.net/her__0_0/article/details/79181241" target="_blank" rel="noopener">mysql服务无法启动，ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)解决办法</a><br>就是这篇博客让我觉得可能是mysql目录下的data文件夹出现了错误，果断把它删除，然后按照下面的博客所提供的方法尝试之后，mysql成功连接。<br><a href="https://blog.csdn.net/chen97_08/article/details/81484286" target="_blank" rel="noopener">MySQL出现：ERROR 2003 (HY000): Can’t connect to MySQL server on ‘localhost’ (10061)问题解决</a> </p><p>我这里也简单记录下我的操作过程，也算是对得起自己捣鼓的这一个多小时。</p><p>1.首先删除原来的mysql服务，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --remove mysql服务器名</span><br></pre></td></tr></table></figure><p>2.安装mysqld服务器，输入命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --install</span><br></pre></td></tr></table></figure><p>前两步是我个人觉得这样会更稳妥一些进行的，不知道会不会对结果产生一些影响。 </p><p>3.删除原数据库目录下的data文件<br>4.启动服务器，输入命令：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net start mysql</span><br><span class="line">```  </span><br><span class="line"></span><br><span class="line">5.初始化mysql，输入命令：</span><br></pre></td></tr></table></figure><ol><li>mysqld –initialize-insecure自动生成无密码的root用户，</li><li>mysqld –initialize自动生成带随机密码的root用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里我执行的是命令1，执行之后再使用</span><br></pre></td></tr></table></figure></li></ol><p>mysql -uroot<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">命令就可以连接上数据库了.  </span><br><span class="line">连上数据库之后可以对密码进行修改。只需要输入命令：</span><br></pre></td></tr></table></figure></p><p>ALTER USER ‘root‘@’localhost’ IDENTIFIED WITH mysql_native_password BY ‘你的密码’;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">设置好密码之后，退出，重新使用账户密码登录即可。</span><br></pre></td></tr></table></figure></p><p>mysql -uroot -p<br><code>`</code></p><p>以上，也就是这次所踩的坑。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;MySQL无法连接&quot;&gt;&lt;a href=&quot;#MySQL无法连接&quot; class=&quot;headerlink&quot; title=&quot;MySQL无法连接&quot;&gt;&lt;/a&gt;MySQL无法连接&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;之前朋友遇到一个问题，mysql8安装完成之后无法连接到数据
      
    
    </summary>
    
      <category term="mysql" scheme="http://blog.letmefly.cc/categories/mysql/"/>
    
    
      <category term="mysql" scheme="http://blog.letmefly.cc/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>Cookie和Session</title>
    <link href="http://blog.letmefly.cc/2018/12/28/Cookie%E5%92%8CSession/"/>
    <id>http://blog.letmefly.cc/2018/12/28/Cookie和Session/</id>
    <published>2018-12-28T05:20:35.000Z</published>
    <updated>2019-01-08T15:48:00.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="会话跟踪"><a href="#会话跟踪" class="headerlink" title="会话跟踪"></a>会话跟踪</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>&emsp;&emsp;前面两个章节讲解的对象中，HttpServletRequest对象和ServletContext对象都可以对数据进行保存，但这个对象都不能满足会话的要求，具体原因如下：<br>&emsp;&emsp;(1)客户端请求Web服务器时，针对每次HTTP请求，Web服务器都会创建一个HttpServletRequest对象，该对象只能保存本次请求所传递的数据。由于购买和结账时两个不同的请求，因此，在发送结账请求时，之前购买请求中的数据将会丢失。<br><img src="/2018/12/28/Cookie和Session/request保存数据.jpg" alt="request保存数据"><br>&emsp;&emsp;(2)使用ServletContext对象保存数据时，由于同一个Web应用共享的是同一个ServletContext对象，因此，当用户发送结账请求时，由于无法区分哪些商品是那个用户所购买的，而会将该购物网站中所有用户购买的商品进行结算，这显然不可取。<br><img src="/2018/12/28/Cookie和Session/ServletContext保存数据.jpg" alt="ServletContext保存数据"><br>&emsp;&emsp;(3)为了保存会话过程中产生的数据，在Servlet技术中，体用了两个用于保存会话数据的对象，分别是Cookie和Session。<br><img src="/2018/12/28/Cookie和Session/Cookie和Session.jpg" alt="Cookie和Session"></p><ul><li>Cookie和浏览器缓存有什么区别？<br>&emsp;&emsp;共同点:浏览器缓存可以缓存任意内容(上网浏览的所有内容),cookie只是服务器需要浏览器缓存数据(浏览器缓存中一部分)。</li></ul><p>&emsp;&emsp;会话(Session)跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。因为HTTP协议是无状态的，也就是说每个客户访问服务器端资源时，服务器并不知道该客户是谁，所以需要绘画识别识别客户端状态。会话技术是帮助服务器记住客户端状态(区分客户端)。</p><h2 id="会话技术"><a href="#会话技术" class="headerlink" title="会话技术"></a>会话技术</h2><p>&emsp;&emsp;从打开一个浏览器访问某个站点，到关闭这个浏览器的整个过程，称为一次会话。会话技术是记录这次会话中客户端的状态和数据的。常用的会话跟踪技术是Cookie和Session。<br>Cookie通过在客户端记录信息确定用户身份，数据存储在客户端本地，减少服务器端的存储压力，安全性不好，客户端可以清除cookie。<br>Session通过在服务器端记录信息确定用户身份，将数据存储到服务器端，安全性相对好，增加服务器的压力。</p><h2 id="Cookie机制"><a href="#Cookie机制" class="headerlink" title="Cookie机制"></a>Cookie机制</h2><p>&emsp;&emsp;理论上，一个用户的所有请求操作都应该属于同一个会话，而另一个用户的所有请求操作则属于另一个会话，二者不能混淆。而Web应用程序使用HTTP协议传输数据的。HTTP协议是无状态的协议。一旦数据交换完毕，客户端与服务端的连接就会关闭，再次交换数据需要建立新的连接。这就意味着服务器无法从连接上跟踪会话。</p><h3 id="什么是Cookie"><a href="#什么是Cookie" class="headerlink" title="什么是Cookie"></a>什么是Cookie</h3><p>&emsp;&emsp;Cookie实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用response向客户端浏览器颁发一个Cookie。<br>&emsp;&emsp;注意：Cookie功能需要浏览器的支持。如果浏览器不支持Cookie或者把Cookie禁用了，Cookie功能就会失效。不同的浏览器采用不同的方式保存Cookie。<br>&emsp;&emsp;Java中把Cookie封装成了javax.servlet.http.Cookie类。每个Cookie都是该Cookie类的对象。服务器通过操作Cookie类对象对客户端Cookie进行操作。通过request.getCookie()获取客户端提交的所有Cookie（以Cookie[]数组形式返回）,通过response.addCookie(Cookie cookie)向客户端设置Cookie。<br>&emsp;&emsp;Cookie对象使用key-value属性对的形式保存用户状态，一个Cookie对象保存一个属性对，一个request或者response同时使用多个Cookie。  </p><h2 id="Cookie技术"><a href="#Cookie技术" class="headerlink" title="Cookie技术"></a>Cookie技术</h2><p>&emsp;&emsp;Cookie技术是将用户的数据存储到客户端的技术,当用户通过浏览器访问Web服务器时，服务器会给客户端发送一些信息，这些信息会保存在Cookie中。这里进行两方面的展示：第一个是服务器端怎样将一个Cookie发送到客户端；另一个是服务器端怎样接受客户端携带的Cookie。</p><h3 id="Cookie在浏览器和服务器之间传输的过程"><a href="#Cookie在浏览器和服务器之间传输的过程" class="headerlink" title="Cookie在浏览器和服务器之间传输的过程"></a>Cookie在浏览器和服务器之间传输的过程</h3><p><img src="/2018/12/28/Cookie和Session/Cookie在浏览器和服务器之间传输的过程.jpg" alt="Cookie在浏览器和服务器之间传输的过程"><br>&emsp;&emsp;该图描述了Cookie在浏览器和服务器之间的传输过程。当用户第一次访问服务器时，服务器会在响应消息中增加Set-Cookie头字段，将用户信息以Cookie的形式发送给浏览器。一旦用户接受了服务器发送的Cookie信息，就会将它保存在浏览器的缓存区中，以后浏览器访问该服务器时，都会在请求消息中将用户信息以Cookie的形式发送给Web服务器，从而使服务器端分辨出当前请求是由哪个用户发出的。<br><img src="/2018/12/28/Cookie和Session/Cookie在浏览器和服务器过程.jpg" alt="Cookie在浏览器和服务器之间传输的过程"></p><h3 id="服务器端向客户端端发送一个Cookie"><a href="#服务器端向客户端端发送一个Cookie" class="headerlink" title="服务器端向客户端端发送一个Cookie"></a>服务器端向客户端端发送一个Cookie</h3><p>1).创建Cookie<br>Cookie cookie = new Cookie(String cookieName, String cookieValue)<br>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(name, value);</span><br><span class="line">Cookie cookie = new Cookie(&quot;username&quot;,&quot;zhangsan&quot;);</span><br><span class="line">```  </span><br><span class="line">那么该cookie会以响应头的形式发送给客户端：</span><br><span class="line">```  </span><br><span class="line">Set-Cookie: user=&quot;&quot;;path=/;</span><br><span class="line">Set-Cookie:&quot;name=zhangsan&quot;</span><br></pre></td></tr></table></figure></p><p>注意：Cookie中不能存储中文<br>2)设置Cookie在客户端的持久化时间：  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">cookie.setMaxAge(int seconds);--时间秒</span><br><span class="line"></span><br><span class="line">注意：如果不设置持久化时间，</span><br><span class="line">cookie会存储在浏览器的内存中，</span><br><span class="line">浏览器关闭cookie信息会销毁（会话级别的cookie），</span><br><span class="line">如果设置持久化时间，cookie信息会被持久化到浏览器的磁盘文件里。  </span><br><span class="line">示例：  </span><br><span class="line">cookie.setMaxAge(10 * 60);</span><br></pre></td></tr></table></figure><p>设置cookie信息在浏览器的磁盘存储的时间是10分钟，过期浏览器自动删除该cookie信息。（详细的内容可以参考下面的Cookie有效期）  </p><p>3)设置cookie的携带路径<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cookie.setPath(String path); </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">注意：如果不设置携带路径，那么该cookie信息会在访问产生该cookie的web资源所在的路径携带cookie信息：  </span><br><span class="line">示例：</span><br></pre></td></tr></table></figure></p><p>cookie.setPath(“/web16”); //代表访问web16应用中的任何资源都携带cookie<br>cookie.setPath(“/web16/cookieServlet”); //代表访问web16中的cookieServlet时才携带cookie信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4)向客户端发送cookie:</span><br></pre></td></tr></table></figure></p><p>response.addCookie(Cookie cookie)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">5)删除客户端的cookie:</span><br><span class="line">&amp;emsp;&amp;emsp;如果想删除客户端的已经存储的cookie信息，就使用同名同路径的持久化时间为0的cookie进行覆盖即可。</span><br><span class="line">### 服务器端如何接收客户端携带的Cookie</span><br><span class="line">cookie信息是以请求头的方式发送到服务器端的：  </span><br><span class="line">Cookie : &quot;name=zhang&quot;</span><br><span class="line">1)通过request获得所有的Cookie：</span><br></pre></td></tr></table></figure></p><p>Cookie[] cookies = request.getCookies();<br>Cookie[] cookies = HttpServletRequest.getCookies()<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2)遍历Cookie数组，通过Cookie的名称获得我们想到的Cookie：</span><br><span class="line">getName():获得cookie名称；  </span><br><span class="line">getValue():获得cookie的值；</span><br></pre></td></tr></table></figure></p><p>for(Cookie cookie : cookies){<br>    if(cookie.getName().equal(cookieName)){<br>        String cookieValue = cookie.getValue();<br>    }<br>}<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### Cookie的不可跨域名性</span><br><span class="line">&amp;emsp;&amp;emsp;Cookie具有不可跨域名性。根据Cookie规范，浏览器访问Google只会携带Google的Cookie，而不会携带Baidu的Cookie。Google也只能操作Google的Cookie，而不能操作Baidu的Cookie。  </span><br><span class="line">&amp;emsp;&amp;emsp;Cookie在客户端是由浏览器来管理的。浏览器可以保证Google只会操作Google的Cookie而不会操作Baidu的Cookie，从而保证用户的隐私安全。浏览器判断一个网站是否能操作另一个网站的Cookie是根据。Google和Baidu的域名不同，所以Google不能操作Baidu的Cookie。  </span><br><span class="line">&amp;emsp;&amp;emsp;注意：对普通的Cookie而言，虽然网站images.google.com与网站www.google.com同属于Google，但域名不同，二者同样不能相互操作彼此的Cookie。有时候用户登录www.google.com后发现访问images.google.com时登录信息仍然有效，是因为做了特殊的处理。</span><br><span class="line">### Unicode编码：保存中文</span><br><span class="line">&amp;emsp;&amp;emsp;中文与英文字符不同，中文属于Unicode字符，而英文属于ASCII字符。Cookie中使用Unicode字符时需要对Unicode字符进行编码，否则会乱码。编码可以使用java.net.URLEncoder类的encode(String str, String encoding)方法，解码使用java.net.URLDecoder类的decode(String str, String encoding)方法。例如：</span><br></pre></td></tr></table></figure></p><p>Cookie cookie = new Cookie(URLEncoder.encode(“姓名”,”UTF-8”),URLEncoder.encode(“刘静华”,”UTF-8”));<br>response.addCookie(cookie);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">注意：Cookie中保存中文只能编码，一般使用UTF-8编码即可。由于浏览器每次请求服务器都会携带Cookie，因此Cookie内容不宜过多，否则影响速度。Cookie的内容应该少而精。</span><br><span class="line">### 设置Cookie的所有属性</span><br><span class="line">&amp;emsp;&amp;emsp;除了name与value之外，Cookie还具有其他几个常用的属性。每个睡醒对应一个getter和setter方法。Cookie类的所有属性如下表所示：</span><br><span class="line"></span><br><span class="line">| 属性名称 | 描述 |</span><br><span class="line">| ------ | ------ |</span><br><span class="line">| String name | 该Cookie的名称。Cookie一旦创建，名称不可更改。 | </span><br><span class="line">| Object value | 该Cookie的值。如果值为Unicode字符，需要为字符编码。如果值为二进制数据，则需要使用BASE64编码。 | </span><br><span class="line">| int maxAge | 该Cookie失效的时间，单位秒。如果为正数，则该Cookie在maxAge秒之后失效。如果为负数，该Cookie为临时Cookie，关闭浏览器即失效，浏览器也不会以任何形式保存该Cookie。如果为0，表示删除该Cookie。默认为-1. | </span><br><span class="line">| boolean secure | 该Cookie是否仅被使用安全协议传输。安全协议有：HTTPS、SSL等，在网络上传输数据之前先加密。默认为false |</span><br><span class="line">| String path | 该Cookie的使用路径。如果设置为&quot;/sessionWeb/&quot;,则只有contextPath为&quot;/sessionWeb&quot;的程序可以访问该Cookie。如果设置为&quot;/&quot;,则本域名下contextPath都可以访问该Cookie。注意最后一个字符必须为&quot;/&quot; | </span><br><span class="line">| String domain | 可以访问该Cookie的域名。如果设置为&quot;.google.com&quot;，则所有以&quot;google.com&quot;结尾的域名都可以访问该Cookie。注意第一个字符必须为&quot;.&quot; | </span><br><span class="line">| String comment | 该Cookie的用处说明。浏览器显示Cookie信息的时候显示该说明 | </span><br><span class="line">| int version | 该Cookie使用的版本号。0表示遵循Netscape的Cookie规范，1表示遵循W3C的RFC2109规范 |</span><br><span class="line">### Cookie的分类</span><br><span class="line"></span><br><span class="line">- 会话级别的Cookie：默认的。关闭了浏览器Cookie就销毁了。</span><br><span class="line">- 持久级别的Cookie：需要设置有效时长的。关闭浏览器也不会销毁的Cookie。</span><br><span class="line">- setMaxAge(int expiry):以秒为单位的时间，超过该时间之后Cookie会自动销毁。setMaxAge(0),手动删除持久性的Cookie。（前提：path和name必须一致）</span><br><span class="line">- setPath(String uri);设置Cookie的有效路径</span><br><span class="line">- (1)cookie.setPath(&quot;/day16/demo&quot;):表示day16项目下,【demo目录】下所有的servlet，都可以访问当前cookie。但”/day16“或&quot;/day16/aaa&quot;将不能访问；</span><br><span class="line">- (2)cookie.setPath(&quot;/day16&quot;);表示【day16项目】下的所有servlet都可以访问当前cookie；</span><br><span class="line">- (3)cookie.setPath(&quot;/&quot;);表示【tomcat下】的所有的web项目，都可以访问当前cookie。</span><br><span class="line"></span><br><span class="line">- cookie唯一表示：</span><br><span class="line">- 唯一标示：domain + path + name（类似Java中包+类名）</span><br><span class="line">- domain域名，不同的网站使用的是不同的域名，cookie就不同</span><br><span class="line">- path路径，通过cookie.setPath(...)设置的内容</span><br><span class="line">- name cookie名称，通过new Cookie(name, ...)确定的内容</span><br><span class="line">- 例如：以下表示的是两个cookie，可以同时存在。</span><br><span class="line">- /web/a/b/cookieName</span><br><span class="line">- /web/a/cookieName</span><br><span class="line">- 如果路径和名称一样，两次addCookie(),后者将覆盖前者</span><br><span class="line">### Cookie的有效期</span><br><span class="line">&amp;emsp;&amp;emsp;Cookie的maxAge决定着Cookie的有效期，单位为秒。Cookie中通过getMaxAge()与setMaxAge(int maxAge)方法来读写maxAge属性。  </span><br><span class="line">&amp;emsp;&amp;emsp;如果maxAge属性为正数，则表示该Cookie会在maxAge秒之后自动失效。浏览器会将maxAge为正数的Cookie持久化即写到对应的Cookie文件中。无论客户关闭了浏览器还是电脑，只要还在maxAge秒之前，登录网站时，该Cookie仍然有效。下面代码中的Cookie信息将永远有效：</span><br></pre></td></tr></table></figure></p><p>Cookie cookie = new Cookie(“username”,”helloweenvsfei”);<br>cookie.setMaxAge(Integer.MAX_VALUE);<br>response.addCookie(cookie);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;如果maxAge是负数，则表示该Cookie仅在本浏览器窗口及本窗口打开的子窗口内有效，关闭窗口后该Cookie即失效。maxAge为负数的Cookie，为临时性Cookie，不会被持久化，不会被写到Cookie文件中.Cookie信息保存在浏览器内存中，因此关闭浏览器该Cookie就消失了。Cookie默认的maxAge值为-1.  </span><br><span class="line">&amp;emsp;&amp;emsp;如果maxAge为0则表示删除该Cookie。Cookie机制没有提供删除Cookie的方法，因此通过设置Cookie即时失效实现删除Cookie的效果。失效的Cookie会被浏览器从Cookie文件或者内存中删除。例如：</span><br></pre></td></tr></table></figure></p><p>Cookie cookie = new Cookie(“username”,”helloweenvsfei”);<br>cookie.setMaxAge(0);<br>response.addCookie(cookie);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;response对象提供的Cookie操作方法只有一个添加操作add(Cookie cookie)。要想修改Cookie只能使用一个同名的Cookie来覆盖原来的Cookie，达到修改的目的。删除时只需把setMaxAge修改为0即可。</span><br><span class="line">### Cookie的修改、删除</span><br><span class="line">&amp;emsp;&amp;emsp;Cookie并不提供修改、删除操作。如果要修改某个Cookie，只需要新建一个同名的Cookie，并添加到response中覆盖原来的Cookie。  </span><br><span class="line">&amp;emsp;&amp;emsp;如果要删除某个Cookie，需要新建一个同名的Cookie，并将maxAge设置为0，并添加到response中覆盖原来的Cookie。注意是0而不是负数。  </span><br><span class="line">&amp;emsp;&amp;emsp;修改、删除Cookie时，新建的Cookie除value、maxAge之外的所有属性，例如：name、path、domain等，都要与原Cookie完全一样。否则，浏览器将视为两个不同的Cookie不予覆盖，导致修改、删除失败。</span><br><span class="line">### Cookie的域名</span><br><span class="line">&amp;emsp;&amp;emsp;Cookie是不可跨域名的，这是由Cookie的隐私安全机制决定的。隐私安全机制能够禁止网站非法获取其他网站的Cookie。</span><br><span class="line">&amp;emsp;&amp;emsp;正常情况下，同一个一级域名下的两个二级域名如www.helloweenvsfei.com和images.helloweenvsfei.com也不能交互使用Cookie,因为二者的域名并不严格相同。如果想所有helloweenvsfei.com名下的二级域名都可以使用该Cookie，需要设置Cookie的domain参数，例如：</span><br></pre></td></tr></table></figure></p><p>Cookie cookie = new Cookie(“time”,”20080808”);<br>cookie.setDomain(“.helloweenvsfei.com”);<br>cookie.setPath(“/“);<br>cookie.setMaxAge(Integer.MAX_VALUE);</p><p>response.addCookie(cookie);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注意：domain参数必须以点(&quot;.&quot;)开始。另外，name相同但domain不同的两个Cookie是两个不同的Cookie。如果想要两个域名完全不同的网站共有Cookie，可以生成两个Cookie，domain属性分别为两个域名，输出到客户端。</span><br><span class="line">### Cookie的路径</span><br><span class="line">&amp;emsp;&amp;emsp;domain属性决定运行访问Cookie的域名，而path属性决定允许访问Cookie的路径(ContextPath)。例如，如果只允许/sessionWeb/下的程序使用Cookie:</span><br></pre></td></tr></table></figure></p><p>Cookie cookie = new Cookie(“time”,”20080808”);<br>cookie.setPath(“/session/“);</p><p>response.addCookie(cookie);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设置为&quot;/&quot;时允许所有路径使用Cookie。path属性需要使用符号&quot;/&quot;结尾。name相同但domain不相同的两个Cookie也是两个不同的Cookie。</span><br><span class="line">### Cookie的安全属性</span><br><span class="line">&amp;emsp;&amp;emsp;HTTP协议不仅是无状态的，而且是不安全的。使用HTTP协议的数据不经过任何加密就直接在网络上传播，有被劫的可能。使用HTTP协议传输很机密的内容是一种隐患。如果不希望Cookie在HTTP等非安全协议中传输，可以设置Cookie的secure属性为true。浏览器只会在HTTPS和SSL等安全协议中传输此类Cookie。如下所示：</span><br></pre></td></tr></table></figure></p><p>Cookie cookie = new Cookie(“time”,”20080808”);<br>cookie.setSecure(true);</p><p>response.addCookie(cookie);<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">secure属性并不能对Cookie内容进行加密，因而不能保证绝对的安全性。如果需要高安全性，需要在程序中对Cookie内容加密、解密，以防泄密。</span><br><span class="line">### JavaScript操作Cookie</span><br><span class="line">&amp;emsp;&amp;emsp;Cookie是保存在浏览器端的，因此浏览器具有操作Cookie的先决条件。浏览器可以使用脚本程序如JavaScript等操作Cookie。例如：</span><br></pre></td></tr></table></figure></p><p><script>document.write(document.cookie);</script><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#### 使用Cookie可以进行永久登录，只要把maxAge的属性调长即可。</span><br><span class="line">## 有了Cookie为什么还有Session</span><br><span class="line"></span><br><span class="line">- Cookie有大小和个数的限制。Session存到服务器端的技术，没有大小和个数的限制</span><br><span class="line">- Cookie相对于Session而言不安全</span><br><span class="line">## Session机制</span><br><span class="line">&amp;emsp;&amp;emsp;除了使用Cookie，Web应用程序中还经常使用Session来记录客户端状态。Session是服务器端使用的一种记录客户端状态的机制，使用上比Cookie简单一些，但相应的，也增加了服务器的存储压力。</span><br><span class="line">### 什么是Session</span><br><span class="line">&amp;emsp;&amp;emsp;Session是另一种记录客户状态的机制，Session保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是Session。客户端浏览器再次访问时，只需要从该Session中查找该客户的状态就可以了。  </span><br><span class="line">### Session技术</span><br><span class="line">&amp;emsp;&amp;emsp;Session技术是将数据存储在服务器端的技术，会为每个客户端都创建一块内存空间来存储客户的数据，但客户端需要每次都携带一个标识ID去服务器中寻找属于自己的内存空间（当客户端后续访问服务器时，只要将标识号传给服务器，服务器就能判断出该服务是由哪个客户端发送的，从而选择与之）。所以Session的实现基于Cookie，Session需要借助Cookie存储客户的唯一标识JSESSIONID。</span><br><span class="line">![Cookie在浏览器和服务器之间传输的过程](Cookie和Session/Session保存用户信息的过程.jpg)</span><br><span class="line"></span><br><span class="line">&amp;emsp;&amp;emsp;在Session这里需要了解如下三个问题：  </span><br><span class="line">&amp;emsp;&amp;emsp;1).怎样获得属于本客户端的session对象（内存区域）？  </span><br><span class="line">&amp;emsp;&amp;emsp;2).怎样向session中存取数据(session也是一个域对象)?  </span><br><span class="line">&amp;emsp;&amp;emsp;3).session对象的生命周期？  </span><br><span class="line"></span><br><span class="line">1).获得Session对象</span><br></pre></td></tr></table></figure></p><p>HttpSession session = request.getSession();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">此方法会获得专属于当前会话的Session对象，如果服务器端没有该会话的Session对象会创建一个新的Session返回，如果已经有了属于该会话的Session直接将已有的Session返回(实质是指JSESSIONID判断该客户是否在服务器上已经存在session了)</span><br><span class="line">2).向session中存取数据  </span><br><span class="line">&amp;emsp;&amp;emsp;Session是存储区域的对象，所以session也有以下三个方法：</span><br><span class="line"></span><br><span class="line">- session.setAttribute(String name, Object obj);</span><br><span class="line">- session.getAttribute(String name);</span><br><span class="line">- session.removeAttribute(String name);</span><br><span class="line"></span><br><span class="line">3).Session对象的生命周期</span><br><span class="line">创建：第一次执行request.getSession()时创建  </span><br><span class="line">销毁：  </span><br><span class="line">(I)服务器(非正常)关闭时;  </span><br><span class="line">(II)session过期/失效(默认30分钟)  </span><br><span class="line">问题：时间的起点算  从何时开始计算30分钟？   </span><br><span class="line">从不操作服务器的资源开始计时</span><br><span class="line"></span><br><span class="line">可以在web.xml中进行配置</span><br></pre></td></tr></table></figure></p><p><session-config><br>    <session-timeout>30</session-timeout><br></session-config><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(III)手动销毁session</span><br></pre></td></tr></table></figure></p><p>session.invalidate();<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作用范围：默认在一次会话中，一次会话中任何资源公用一个session对象。  </span><br><span class="line">面试题：浏览器关闭，session就销毁了，对不对？不对</span><br><span class="line">### 实现用户登录</span><br><span class="line">&amp;emsp;&amp;emsp;Session对应的类是javax.servlet.http.HttpSession类。每个来访者对应一个Session对象，所有该客户的状态信息都保存在这个Session对象中。Session对象是在客户端第一次请求服务器的时候创建的。Session也是一种key-value的属性对，通过getAttribute(String key)和setAttribute(String key, Object value)方法读写客户状态信息。Servlet中通过request.getSession()或者request.getSession(boolean create)方法获取该客户的Session，这两个方法都用于返回与当前请求相关的HttpSession对象。不同的是，第一个getSession()方法根据传递的参数来创建新的HttpSession对象，如果参数为true，则在相关的HttpSession对象不存在时创建并返回新的HttpSession对象，否则不创建新的HttpSession对象，而是返回null。第二个getSession()方法相当于第一个方法参数为true时的情况，在相关的HttpSession对象不存在时总是创建新的HttpSession对象。这里只是getSession()的一个获取方式，例如：</span><br></pre></td></tr></table></figure></p><p>HttpSession session = request.getSession();<br>session.getAttribute(“loginTime”, new Date());</p><p>out.println(“登录时间为： “ + (Date)session.getAttribute(“loginTime”));<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;request还可以使用getSession(boolean create)来获取Session。区别是如果该客户的Session不存在，request.getSession()方法会返回null，而getSession(true)会先创建Session再将Session返回。  </span><br><span class="line">&amp;emsp;&amp;emsp;Servlet中必须使用request来编程式获取HttpSession对象，而JSP中内置了Session隐藏对象，可以直接使用。如果使用声明了&lt;%@ page session=&quot;false&quot; %&gt;,则Session隐藏对象不可用。  </span><br><span class="line">&amp;emsp;&amp;emsp;登录页面验证用户登录信息，如果登录正确，就把用户信息以及登录时间保存进Session，然后跳转到另一页面。另一页面中从Session中获取信息，并将用户资料显示出来。当多个客户端执行程序时，服务器会保存多个客户端的Session。获取Session的时候也不需要声明获取谁的Session。Session机制决定了当前客户只会获取到自己的Session，而不会获取到别人的Session。各客户的Session也彼此独立，互不可见。</span><br><span class="line">### Session的生命周期</span><br><span class="line">&amp;emsp;&amp;emsp;Session保存在服务器端。为了获得更高的存取速度，服务器一般把Session放入内存。每个用户都会有一个独立的Session。如果Session内容过于复杂，当大量客户访问服务器时可能会导致内存溢出。所以，Session中的信息要尽量精简。  </span><br><span class="line">&amp;emsp;&amp;emsp;Session在用户第一次访问服务器的时候自动创建。注意只有访问JSP、Servlet等程序时才会创建Session，只访问HTML、IMAGE等静态资源并不会创建Session。如果尚未生成Session，也可以使用request.getSession(true)强制生成Session。  </span><br><span class="line">&amp;emsp;&amp;emsp;Session生成后，只要用户继续访问，服务器就会更新Session的最后访问时间，并维护该Session。用户每访问服务器一次，无论是否读写Session，服务器都认为该用户的Session&quot;活跃(active)&quot;了一次。</span><br><span class="line"></span><br><span class="line">### Session的有效期</span><br><span class="line">&amp;emsp;&amp;emsp;由于会有越来越多的用户访问服务器，因此Session也会越来越多。为了防止内存溢出，服务器会把长时间没有活跃的Session从内存删除。这个时间就是Session的超时时间。如果超过了超时时间没访问过服务器，Session就会自动失效。  </span><br><span class="line">&amp;emsp;&amp;emsp;Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(long interval)修改。  </span><br><span class="line">&amp;emsp;&amp;emsp;Session的超时时间也可以在web.xml中修改。另外，通过调用Session的invalidate()方法也可以使Session失效。</span><br><span class="line"></span><br><span class="line">### Session的常用方法</span><br><span class="line">&amp;emsp;&amp;emsp;Session中包括各种方法，用起来比Cookie方法得多。其常用方法如下表所示：</span><br><span class="line"></span><br><span class="line">| 属性名称 | 描述 |</span><br><span class="line">| ------ | ------ |</span><br><span class="line">| void setAttribute(String attribute, Object value) | 设置Session属性。value参数可以为任何Java Object。通常为Java Bean。value信息不宜过大 | </span><br><span class="line">| String getAttribute(String attribute) | 返回Session属性 | </span><br><span class="line">| Enumeration getAttributeNames() | 返回Session中存在的属性名 | </span><br><span class="line">| void removeAttribute(String attribute) | 移除Session属性 |</span><br><span class="line">| String getId() | 返回Session的ID。该ID由服务器自动创建，不会重复 | </span><br><span class="line">| long getCreationTime() | 返回Session的创建日期，这个时间是创建Session的时间与1970年1月1日00:00:00之间时间差的毫秒表示形式。返回类型为long，常被转换为Date类型。 | </span><br><span class="line">| long getLastAccessedTime() | 返回Session的最后活跃时间。返回类型为long | </span><br><span class="line">| int getMaxInactiveInterval | 返回服务器的超时时间。单位为秒。超时该时间没有访问，服务器认为该Session失效。 |</span><br><span class="line">| int setMaxInactiveInterval(int second) | 设置Session的超时时间。单位为秒。 |</span><br><span class="line">| boolean isNew() | 返回该Session是否是新创建的 | </span><br><span class="line">| void invalidate() | 使该Session失效 | </span><br><span class="line">| ServletContext getServletContext() | 用于返回当前HttpSession对象所属于的WEB应用程序对象，即代表当前WEB应用程序的ServletContext对象 | </span><br><span class="line">&amp;emsp;&amp;emsp;Tomcat中Session的默认超时时间是20分钟。通过setMaxInactiveInterval(int seconds)修改超时时间。可以修改web.xml改变Session的默认超时时间。例如修改为60分钟：</span><br></pre></td></tr></table></figure></p><p><session-config><br>    <!--单位：分钟--><br>    <session-timeout>60</session-timeout></session-config></p><p><session-config><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">### Session对浏览器的要求</span><br><span class="line">&amp;emsp;&amp;emsp;虽然Session保存在服务器，对客户端透明，但其正常运行仍然需要客户端浏览器的支持。因为Session使用Cookie作为识别标志。（服务器想客户端发送一个名为JSESSIONID的cookie来判断是否是同一个用户）</span><br><span class="line">### URL地址重写</span><br><span class="line">&amp;emsp;&amp;emsp;URL地址重写是对客户端不支持Cookie的解决方案。URL地址重写的原理是将该用户Session的id信息重写到URL地址中。服务器能够解析重写后的URL获取Session的id。即使客户端不支持Cookie，也可以使用Session来记录用户状态。HttpServletResponse类提供了encodeURL(String url)实现URL地址重写，例如：</span><br></pre></td></tr></table></figure></session-config></p><p><td><br>    &lt;a href=”&lt;%response.encodeURL(“index.jsp?c=1&amp;wd=Java”)%&gt;”&gt;<br></td><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;该方法会自动判断客户端是否支持Cookie。如果客户端支持Cookie，会将URL原封不动地输出来。如果客户端不支持Cookie，则会将用户Session的id重写到URL中。重写后的输出可能如下所示：</span><br></pre></td></tr></table></figure></p><p><td><br>    &lt;a href=index.jsp;jsessionid=0CCD096E7F8D97B0BE608AFDC3E1931E?c=1&amp;wd=Java”&gt;Homepage<br></td><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&amp;emsp;&amp;emsp;即在文件名的后面，在URL参数的前面添加了字符串&quot;;jsessionid=XXX&quot;。其中XXX为Session的id。添加的jessionid字符串既不会影响请求的文件名，也不会影响提交的地址栏参数。用户单机这个链接的时候会把Session的id通过URL提交到服务器上，服务器通过解析URL地址获得Session的id。  </span><br><span class="line">&amp;emsp;&amp;emsp;如果是页面重定向，URL地址重写可以为：</span><br></pre></td></tr></table></figure></p><p>&lt;%<br>    if(“admin”.equals(username)){<br>        response.sendRedirect(response.encodeRedirectURL(“admin.jsp”));<br>        return;<br>    }<br>%&gt;<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">效果跟response.encodeURL(String url)是一样的：如果客户端支持Cookie，生成原URL地址，如果不支持Cookie，传回重写后的带有jsessionid字符串的地址。  </span><br><span class="line">&amp;emsp;&amp;emsp;注意：Tomcat判断客户端浏览器是否支持Cookie的依据是请求中是否含有Cookie。尽管客户端可能会支持Cookie，但由于第一次请求时不会携带任何Cookie，URL地址重写后的地址中仍然会带有jsessionid，当第二次访问时服务器就已经在浏览器中写入Cookie了，因此URL地址重写后的地址中就不会带有jsessionid了。</span><br><span class="line">### Session中禁止使用Cookie</span><br><span class="line">&amp;emsp;&amp;emsp;Java Web规范支持通过配置的方式禁用Cookie。可以通过以下方式进行配置，打开项目下的WebRoot下的META-INF文件夹，打开context.xml（如果没有则创建），编辑内容如下：</span><br></pre></td></tr></table></figure></p><p>&lt;?xml version=’1.0’ encoding=’UTF-8’&gt;</p><p><context path="/项目名" cookies="false"><br></context><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">或者修改Tomcat全局的conf/context.xml修改内容如下：</span><br></pre></td></tr></table></figure></p><p><context cookies="false"><br>    <!--中间内容省略--><br>    …….<br></context><br><code>`</code><br>&emsp;&emsp;部署后Tomcat便不会自动生成名JSESSIONID的Cookie，Session也不会以Cookie为识别标志，而仅仅以重写后的URL地址作为识别标志了。<br>&emsp;&emsp;注意：该配置只是禁止Session使用Cookie作为识别标志，并不能阻止其他的Cookie读写。即服务器不会自动维护名为JSESSIONID的Cookie了，但程序中仍然可以读写其他的Cookie。</p><h2 id="Session与Cookie比较"><a href="#Session与Cookie比较" class="headerlink" title="Session与Cookie比较"></a>Session与Cookie比较</h2><ul><li>从存取方式比较：Cookie中只能保存ASCII字符串，如果需要存取Unicode字符或者二进制数据，需要进行UTF-8，GBK或者BASE64等方式的编码。Cookie中也不能直接存取Java对象。若要存储比较复杂的信息，使用Cookie是比较困难的。Session中可以存取任何类型的数据，包括而不限于String、Integer、List、Map等。Session中也可以直接保存Java Bean乃至任何Java类，对象等。使用起来非常方便。可以把Session看作是一个Java容器类。  </li><li>从隐私安全上比较：Cookie存储在客户端浏览器中，而Session存储在服务器上。如果选用Cookie，敏感的信息如账号密码尽量不要写到Cookie中。而Session放在服务器中，任何隐私都可以。</li><li>从有效期上比较：Cookie可以实现永久有效的效果。而Session由于依赖名为JSESSIONID的Cookie，而Cookie的JSESSIONID的maxAge默认为-1，只要关闭浏览器该Session就会失效，因此Session不能实现信息有效的永久存储。使用URL地址重写也不能实现。而且如果设置Session的超时时间过长，服务器累积的Session就会越多，越容易导致内存溢出。</li><li>从对服务器上的负担比较：Session是保存在服务器端的，每个用户都会产生一个Session。如果并发访问的用户非常多，会产生非常多的Session，消耗大量的内存。而Cookie保存在客户端，不占用服务器资源。如果并发浏览的用户非常多，Cookie是一个很好的选择。</li><li>从浏览器支持上比较：Cookie是需要客户端浏览器支持的。如果客户端禁用了Cookie，或者不支持Cookie，则会话跟踪会失效。如果客户端浏览器不支持Cookie，需要使用Session以及URL地址重写。需要注意的是所有用到Session程序的URL都要使用response.encodeURL(String URL)或者response.encodeRedirectURL(String url)进行URL地址重写，否则导致Session会话跟踪失败。如果客户端支持Cookie，则Cookie既可以设为本浏览器窗口以及子窗口内有效（把maxAge设为-1），也可以设为所有浏览器窗口内有效(把maxAge设为某个大于0的整数)。但Session只能在本浏览器窗口以及其子窗口内有效。如果两个浏览器窗口互不相干，它们将使用两个不同的Session。</li><li>从跨域名上比较：Cookie可以通过设置setDomain(String url)实现跨域名的访问。而Session则不会支持跨域名访问。Session仅在他所在的域名内有效。</li></ul><h2 id="作用域总结："><a href="#作用域总结：" class="headerlink" title="作用域总结："></a>作用域总结：</h2><h3 id="Servlet三个作用域"><a href="#Servlet三个作用域" class="headerlink" title="Servlet三个作用域"></a>Servlet三个作用域</h3><ul><li>ServletContext：针对一个WEB应用。一个WEB应用只有一个ServletContext对象，使用该对象保存的数据在整个WEB应用中都有效。<ul><li>创建：服务器启动的时候</li><li>销毁：服务器关闭的时候或者项目移除的时候</li></ul></li><li>HttpSession：针对一次会话。使用该对象保存数据，一次会话(多次请求)内数据有效。<ul><li>创建：服务器第一次调用getSession()的时候，一次会话(多次请求)内数据有效。</li><li>销毁：<br>1：非正常关闭服务器(正常关闭：Session被序列化)；<br>2：Session过期了，默认时间是30分钟；<br>3：手动调用Session的invalidate方法；</li></ul></li><li><p>HttpServletRequest：针对一次请求。使用该对象保存数据，一次请求(一个页面，如果是请求转发多个页面)内数据有效</p><ul><li>创建：客户端向服务器发送一次请求</li><li>销毁：服务器为这次请求做出响应之后，销毁request</li></ul></li><li><p>三个作用域对象操作的API相同</p><ul><li>存放数据：setAttribute(name, value)</li><li>获得数据：getAttribute(name)、getAttributeNames()</li><li>删除数据：removeAttribute(name)</li></ul></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="/2018/12/28/Cookie和Session/总结.jpg" alt="总结"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;会话跟踪&quot;&gt;&lt;a href=&quot;#会话跟踪&quot; class=&quot;headerlink&quot; title=&quot;会话跟踪&quot;&gt;&lt;/a&gt;会话跟踪&lt;/h1&gt;&lt;h2 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://blog.letmefly.cc/categories/JavaWeb/"/>
    
    
      <category term="Web" scheme="http://blog.letmefly.cc/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>JSP技术</title>
    <link href="http://blog.letmefly.cc/2018/12/17/JSP%E6%8A%80%E6%9C%AF/"/>
    <id>http://blog.letmefly.cc/2018/12/17/JSP技术/</id>
    <published>2018-12-17T02:41:04.000Z</published>
    <updated>2018-12-28T05:19:32.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP技术"><a href="#JSP技术" class="headerlink" title="JSP技术"></a>JSP技术</h1><h2 id="JSP简介"><a href="#JSP简介" class="headerlink" title="JSP简介"></a>JSP简介</h2><p>&emsp;&emsp;JSP是一种基于本文的程序，其特点是HTML代码与Java程序共同存在。执行JSP会被Tomcat自动编译，这个过程对开发者是透明的、不需要关注的。编译后的JSP跟HttpServlet一样，都是javax.servlet.Servlet接口的子类，因此JSP是另外一种形式的Servlet。JSP与Servlet一样，在服务器端执行的。不同的是先由服务器编译部署成Servlet执行。<br>&emsp;&emsp;一般而言，提到JSP和Servlet时，Servlet一般指的是HttpServlet。如果不特别指明，这里的Servlet一般指HttpServlet而不是Servlet接口。  </p><h3 id="JSP概述"><a href="#JSP概述" class="headerlink" title="JSP概述"></a>JSP概述</h3><p>&emsp;&emsp;JSP全名为Java Server Page，是为了简化Servlet的工作而出现的替代品。Sun公司1997年推出了Servlet API以及第一款Java Web服务器。早期的Java Web层体系结构中只有Servlet。接受用户请求，处理业务逻辑，生成HTML显示结果都是在Servlet中完成的。虽然Servlet可以胜任所有的工作，但是Servlet中不能像PHP、ASP等镶嵌HTML代码，输出HTML比较困难，而且部署过程也比较复杂。<br>&emsp;&emsp;为了克服Servlet的这些弱点，Sun公司在1999年初推出了JSP 1.0.作为对Servlet的一个补充，JSP在生成HMLT代码上比Servlet方便许多，而且不需要特殊部署，只需要复制到服务器下即可运行。JSP程序不需要再web.xml中部署，直接使用地址访问即可。<br>&emsp;&emsp;JSP包括很多技术，包括Java Bean，自定义标签(Custom Tags),EL表达式(Expression Language),JSTL标准标签类库(Java Standard Tag Library)等。</p><h3 id="JSP工作原理"><a href="#JSP工作原理" class="headerlink" title="JSP工作原理"></a>JSP工作原理</h3><p>&emsp;&emsp;JSP是一种Servlet，但是与HttpServlet的工作方式不太一样。HttpServlet是先由源代码编译为class文件后部署到服务器下的，先编译后部署。而JSP则是先部署源代码后编译为class文件的，先部署后编译。JSP会在客户端第一次请求JSP文件时被编译为HttpJspPage类(接口Servlet的一个子类)。该类会被服务器临时存放在服务器工作目录里面。<br>&emsp;&emsp;客户端第一次访问jsp页面时，Tomcat先将jsp文件转化为标准的java文件，存放在Tomcat路径下的work\Catalina\localhost\jsp\org\apache\jsp目录下，并将java文件编译为class文件。该class文件便是JSP对应的Servlet。编译完毕后再运行class文件来响应客户端请求。以后客户端访问该jsp时，服务器将不再重新编译JSP文件，而是直接调用其class文件来响应客户端请求。<br>&emsp;&emsp;由于JSP只会在客户端第一次请求的时候被编译，因此第一次请求JSP时会感觉比较慢。而之后的请求因为不会编译JSP，所以速度快很多。如果将Tomcat保存的JSP编译后的class文件删除，Tomcat也会重新编译JSP。<br>&emsp;&emsp;开发Web的时候需要经常修改JSP。Tomcat可以自动检测到JSP程序的改动。如果检测到JSP源代码发生了改动，Tomcat会在下次客户端请求JSP时重新编译JSP，而不需要重启Tomcat。这种自动检测功能默认是开启的，检测改动会消耗少量的时间。在部署Web应用程序的时候可以在web.xml中将其关闭。<br><img src="/2018/12/17/JSP技术/JSP运行原理.png" alt="JSP运行原理"><br>&emsp;&emsp;JSP的执行过程<br>（1）客户端发出Request请求<br>（2）JSP Container将JSP翻译成Servlet的源代码<br>（3）将产生的Servlet的源代码经编译后，加载到内存中运行<br>（4）把结果Response(响应)发送至客户端<br>&emsp;&emsp;JSP和Servlet的执行效率相差不大，只是第一次执行JSP页面时需要进行编译。<br>&emsp;&emsp;JSP在执行第一次后，会被编译成Servlet的类文件。当再重复调用执行时，就直接执行第一次所产生的Servlet，而不用再重新把JSP编译成Servlet。因此，除了第一次编译会花费比较久的时间之外，JSP和Servlet的执行速度几乎相同了。<br>&emsp;&emsp;执行JSP网页时，通常可以分为两个时期：转译时期(Translation Time)和请求时期(Request Time)<br>(1)JSP文件先要被服务器翻译成Java文件(Servlet),在Tomcat中翻译后的Java文件在tomcat下的work/Catalina/localhost中相应名字的应用目录中。<br>(2)编译成Java文件<br>(3)运行.class文件</p><h3 id="JSP生命周期"><a href="#JSP生命周期" class="headerlink" title="JSP生命周期"></a>JSP生命周期</h3><p>&emsp;&emsp;JSP也是Servlet，运行时只会有一个实例。跟Servlet一样，JSP实例初始化、销毁也会调用Servlet的init()与destroy()方法。另外，JSP还有自己的初始化方法与销毁方法_jspInit()和_jspDestroy()。</p><h2 id="JSP语法"><a href="#JSP语法" class="headerlink" title="JSP语法"></a>JSP语法</h2><p>&emsp;&emsp;JSP是HTML代码与Java代码的混合体，其中HTML部分遵循HTML语法，Java部分遵循Java语法。</p><h3 id="JSP元素与模板数据"><a href="#JSP元素与模板数据" class="headerlink" title="JSP元素与模板数据"></a>JSP元素与模板数据</h3><p>JSP源代码可以分成两部分：模板数据与元素。</p><ul><li>模板数据：JSP中的HTML代码，它的内容是固定的。无论程序怎样运行，模板数据输出到客户端浏览器时都不会发生变化。模板数据不会控制程序的流程，也不会影响程序的运行结果。模板数据写的是什么输出来的就是什么。</li><li>元素：JSP中的Java部分，包括脚本(Script, 也就是JSP中的Java代码)，以及JSP指令(Directive)与JSP标签(Tag)等。元素决定着程序的流程。</li></ul><h3 id="JSP脚本"><a href="#JSP脚本" class="headerlink" title="JSP脚本"></a>JSP脚本</h3><p>&emsp;&emsp;JSP脚本必须用“&lt;%”与“%&gt;“括起来，否则被视为模板数据。“&lt;%”与“%&gt;“中间的部分必须遵循Java语法，否则会发生编译错误。JSP脚本可以出现在JSP文件的任何地方。</p><h3 id="JSP输出"><a href="#JSP输出" class="headerlink" title="JSP输出"></a>JSP输出</h3><p>&emsp;&emsp;在源程序中使用out.println()方法输出，类似于Servlet中的输出。JSP中还可以使用“&lt;%=”与“%&gt;“输出各种类型数据，包括int、double、boolean、String、Object等。使用“&lt;%=”与“%&gt;“输出变量的时候，后面不能有“;”号。输出某个类对象的时候调用该对象的toString()方法（表达式）。</p><h3 id="JSP注释"><a href="#JSP注释" class="headerlink" title="JSP注释"></a>JSP注释</h3><p>&emsp;&emsp;注释是编程中常用的程序元素。JSP中除了可以使用Java注释之外，还可以使用”&lt;%–”与”–%&gt;”引起的JSP注释。JSP注释既可以单行，也可以多行。</p><h3 id="JSP方法"><a href="#JSP方法" class="headerlink" title="JSP方法"></a>JSP方法</h3><p>&emsp;&emsp;JSP中可以声明方法和属性(全局变量)，但是不能直接在“&lt;%”与”%&gt;”以及“&lt;%=”与”%&gt;”之间声明。JSP声明方法或者全局变量时使用另一组符合“&lt;%!”与“%&gt;”(声明标签)。声明的作用范围是整个JSP页面，同时，只在一个JSp页面有效。声明的类型包括：变量，方法，类。</p><h3 id="JSP的if语句"><a href="#JSP的if语句" class="headerlink" title="JSP的if语句"></a>JSP的if语句</h3><p>&emsp;&emsp;JSP中可以使用if语句。if语句块中可以包含大段的HTML代码。如果if语句块包含有HTML代码，if语句块前后必须使用”{“与”}”。</p><h3 id="JSP的for循环"><a href="#JSP的for循环" class="headerlink" title="JSP的for循环"></a>JSP的for循环</h3><p>&emsp;&emsp;JSP中可以使用for语句来循环输出内容。可以使程序流程更加灵活。</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>&emsp;&emsp;while循环和for循环实质上是一样的。while循环可以改写成for循环，for循环也可以改写成while循环。在一个代码块中声明的变量是JSP页面的局部变量，只在当前页面有效。</p><h3 id="JSP的return语句"><a href="#JSP的return语句" class="headerlink" title="JSP的return语句"></a>JSP的return语句</h3><p>&emsp;&emsp;当JSP代码执行过程中需要中途停止而不再继续往下运行时，使用return语句可以终止程序继续运行。return语句会忽略后面的所有语句（包括Java代码和HTML代码），直接结束运行。return之后，后面的代码不再执行，因此注意保持输出的HTML代码完整。</p><h3 id="JSP的break语句"><a href="#JSP的break语句" class="headerlink" title="JSP的break语句"></a>JSP的break语句</h3><p>&emsp;&emsp;break跟return差不多，都能改变程序的运行流程。但return是直接返回，后面的代码不再继续运行，而break是跳出一个程序代码块，如for循环、while循环、switch子句等，程序代码块外层的代码仍会继续执行。另外break只能出现在for、while、switch等代码块的内部，而return不仅可以出现在其内部，也可以出现在其外部。</p><h2 id="JSP指令"><a href="#JSP指令" class="headerlink" title="JSP指令"></a>JSP指令</h2><p>&emsp;&emsp;JSP指令是用来声明JSP页面的一些属性等，如编码方式、文档类型。JSp指令以符号“&lt;%@”开始，以符号”%&gt;”结束。JSP指令格式为&lt;%@ directive {attribute=value}<em>%&gt;。星号(</em>)表示可以有0个或者多个属性。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;该指令中directive位置为page，因此该指令是一个page指令。该指令包含language与contentType两个属性。常见的指令有page、taglib、include等。</p><h3 id="page指令"><a href="#page指令" class="headerlink" title="page指令"></a>page指令</h3><p>&emsp;&emsp;page指令是最常用的指令，用来声明JSP页面的属性等。JSP指令的多个属性可以写在一个page指令中，也可以写在多个指令中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//一个指令写多个属性</span><br><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;%&gt;</span><br><span class="line">//一个指令写一个属性</span><br><span class="line">&lt;%@ page pageEncoding=&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%@ page import=&quot;java.util.*&quot;%&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;但是，无论在哪个page指令里的属性，任何page允许的属性都只能出现一次，否则会出现编译错误。import属性除外，可以出现多次。属性名区分大小写。  </p><table><thead><tr><th>属性名称</th><th>取值范围</th><th>描述</th></tr></thead><tbody><tr><td>language</td><td>java</td><td>指明解释该JSP文件时采用的语言，默认为java</td></tr><tr><td>extends</td><td>任何类的全名</td><td>指明编译该JSP文件时继承哪个类。JSP为Servlet，因此当指明继承普通类时需要实现Servlet的init、destroy等方法</td></tr><tr><td>session</td><td>true,false</td><td>指明该JSP文件内是否内置Session对象。如果为true，则内置Session对象，可直接使用。否则不内置Session对象。默认为true</td></tr><tr><td>import</td><td>任何包名，类名</td><td>引入该JSP中用到的类、包等。import是唯一可以声明多次的page指令属性。一个import属性可以引用多个类，中间用”,”分开。如:&lt;@page import=”java.util.List,java.tuil.ArrayList”&gt;。JSP中下面四个包里的类可以直接使用:java.lang.*, javax.servlet.*, javax.servlet.jsp.*, javax.servlet.http.*</td></tr><tr><td>autoFlush</td><td>true,false</td><td>是否运行缓存。如果为true，则使用out.println()等方法输出的字符串并不是立刻到达客户端服务器的，而是暂时缓存在缓存中，缓存满或者能程序执行完毕执行out.flush()操作时才到客户端。默认为true</td></tr><tr><td>buffer</td><td>none或者数字+kb</td><td>指定缓存大小。当autoFlush设为true时有效，例如:&lt;@page buffer=”10kb”&gt;</td></tr><tr><td>isThreadSafe</td><td>true,false</td><td>指定线程是否安全。如果为true，则运行多个线程同时运行该JSP程序，否则只运行一个线程，其余线程等待。默认为false</td></tr><tr><td>isErrorPage</td><td>true,false</td><td>指定该页面是否为错误处理页面。如果为true，则该JSP内置一个Exception对象exception，可直接使用，否则没有。默认为false</td></tr><tr><td>errorPage</td><td>某个JSP页面的相对路径</td><td>指明一个错误显示页面，如果该JSP程序抛出了一个未捕捉的异常，则跳转到errorPage指定的页面。errorPage指定的页面通常是isErrorPage属性为true，且内置的exception对象为未捕捉的异常</td></tr><tr><td>contentType</td><td>有效的文档类型</td><td>客户端浏览器根据该属性判断文档类型，例如：HTML格式为text/html, 纯文本格式为text/plain, JPG图像为image/jpeg, GIF图像为image/gif, WORD文档为application/msword</td></tr><tr><td>info</td><td>任意字符串</td><td>指明JSP的信息。该信息可以通过Servlet.getServletInfo()方法得到</td></tr><tr><td>trimDirectiveWhitespaces</td><td>true,false</td><td>是否去掉指令前后的空白字符串。默认为false</td></tr></tbody></table><p>&emsp;&emsp;在HTML文件中，空行不影响显示效果。</p><h3 id="include指令"><a href="#include指令" class="headerlink" title="include指令"></a>include指令</h3><p>&emsp;&emsp;include指令只有一种形式:\&lt;%@ include file=”relativeURL” %&gt;。relativeURL为本应用程序内另一个JSP文件或者HTML文件的路径。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//静态包含</span><br><span class="line">&lt;@ include file=&quot;head.jsp&quot;&gt;</span><br><span class="line">&lt;@ include file=&quot;foot.jsp&quot;&gt;</span><br><span class="line"></span><br><span class="line">//如果导航的头有多个还可以使用if语句来动态include某个文件</span><br><span class="line">&lt;%</span><br><span class="line">if(&quot;style&quot;.equals(request.getParameter(&quot;style&quot;)))&#123;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;@ include file=&quot;head.jsp&quot;&gt;</span><br><span class="line">&lt;%</span><br><span class="line">&#125;else&#123;</span><br><span class="line">&lt;@ include file=&quot;foot.jsp&quot;&gt;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">&#125;</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure><h3 id="taglib指令"><a href="#taglib指令" class="headerlink" title="taglib指令"></a>taglib指令</h3><p>&emsp;&emsp;JSP支持标签技术，使用标签功能可以实现视图代码重用，很少量的代码就可以实现很复杂的显示效果。要使用标签功能必须先声明标签库以及标签前缀。taglib指令用来指明JSP页面内使用的JSP标签库。taglib指令有两个属性，uri为类库的地址，prefix为标签的前缀，如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt;</span><br></pre></td></tr></table></figure><h2 id="JSP行为"><a href="#JSP行为" class="headerlink" title="JSP行为"></a>JSP行为</h2><p>&emsp;&emsp;JSP行为(JSP Actions)是一组JSP内置的标签。JSP行为是对常用的JSP功能的抽象与封装，包括两种，自定义JSP行为与标准JSP行为。自定义行为也就是JSP自定义标签。<br>&emsp;&emsp;标准的JSP行为格式为\&lt;jsp:elements {attribute=”value”}* /&gt;</p><h3 id="jsp-include-行为"><a href="#jsp-include-行为" class="headerlink" title="jsp:include\行为"></a><a href="jsp:include\" target="_blank" rel="noopener">jsp:include\</a>行为</h3><p>&emsp;&emsp;include行为用于运行时包含某个文件。如果被包含的文件为JSP程序，则先执行JSP程序，然后把执行的结果包含进来。<br>&emsp;&emsp;include行为的语法为\&lt;jsp:include page=”relativeURI” flush=”true” /&gt;。属性page是必需的，为被包含文件的相对路径，必须为本Web应用程序内的文件。属性flush取值为true或者flase，默认为false，设置读入被保存文件内容前是否清空缓存，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:include flush=&quot;true&quot; page=&quot;/head.jsp&quot;&gt;&lt;/jsp:include&gt;</span><br><span class="line">这里是正文</span><br><span class="line">&lt;jsp:include flush=&quot;true&quot; page=&quot;/foot.jsp&quot;&gt;&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;虽然include指令(&lt;% page include=”relativeURL”%&gt;)与include行为都包含一个文件，但两者的原理与include发生的时刻不同。前者是在编译时包含，包含的是源代码，而后者是在运行时才包含的，而且只包含运行结果。include行为使用request.getRequestDispatcher(“relativeURI”).forward(request, response)。include指令是“先包含，后编译”，在被编译的jsp中已经包含被include时文件内容了。而include行为是“先运行后包含”，在被编译的jsp中没有被include的文件内容。</p><h3 id="使用Java-Bean-POJO"><a href="#使用Java-Bean-POJO" class="headerlink" title="使用Java Bean(POJO)"></a>使用Java Bean(POJO)</h3><p>&emsp;&emsp;Java Bean行为是一组与Java Bean相关的行为，包括useBean行为、setProperty行为、getProperty等。<br>&emsp;&emsp;Java Bean是普通的Java类，也被成为POJO(普通Java对象，Plain Ordinary Java Object)，是Java程序中广泛应用的一种设计模式。Java Bean类只有私有属性与对应的getter与setter方法。<br>&emsp;&emsp;getter方法用于获取该属性，因此getter方法有返回类型。stter方法用于设置该属性，因此是void的，没有返回类型。<br>&emsp;&emsp;useBean行为用于在JSP中定义一个Java Bean对象。useBean行为的格式为\&lt;jsp:useBean id=”beanId” class=”className” scope=”Value” /&gt;。其中的属性如下表：</p><table><thead><tr><th>属性名</th><th>取值范围</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>合法的java变量名称</td><td>指明Java Bean对象的名称。JSP中可以使用该名称引用该Java Bean对象</td></tr><tr><td>class</td><td>Java Bean类的全名</td><td>Java Bean类的全名</td></tr><tr><td>scope</td><td>page,request,session,application</td><td>该Java Bean对象的范围。当为page时，只在该JSP内有效。当为request时，只有当前的request中有效。当为session时，对当前用户有效。当为application时，当前Web应用程序内有效。默认为page</td></tr></tbody></table><p>&emsp;&emsp;useBean行为定义了Java Bean对象后，就可以通过getPropert行为来获取Java Bean属性，或者通过setProperty行为来设置Java Bean属性。getProperty行为格式为\&lt;jsp:getProperty name=”beanName” property=”propertyName” /&gt;。setProperty行为格式为\&lt;jsp:setProperty name=”beanName” preperty=”propertyName” value=”” /&gt;。其中name为Java Bean的名称，也就是useBean行为里的id属性，property为Java Bean属性，value为属性值。</p><h3 id="lt-jsp-forward-gt-行为"><a href="#lt-jsp-forward-gt-行为" class="headerlink" title="\&lt;jsp:forward /&gt;行为"></a>\&lt;jsp:forward /&gt;行为</h3><p>&emsp;&emsp;Servlet中能够通过request.getRequestDispatcher(“someServlet”).forward(request, response)跳转到另一个Servlet或者另一个文件，jsp也可以。\&lt;jsp:forward /&gt;实际上是对forward方法的一个封装，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:forward page=&quot;/somepage.jsp&quot;&gt;</span><br><span class="line">&lt;jsp:param name=&quot;param1&quot; value=&quot;value1&quot;&gt;</span><br><span class="line">&lt;jsp:param name=&quot;param2&quot; value=&quot;value2&quot;&gt;</span><br><span class="line">&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;当使用param参数为1时，该JSP页面将跳转到指定的页面，并且跳转的时候地址栏参数为\&lt;jsp:param /&gt;指定的值。同Servlet一样，跳转动作发生之前不能用任何输出到达客户端浏览器，否则会抛出IllegalStateException。</p><h3 id="lt-jsp-directive-gt-行为"><a href="#lt-jsp-directive-gt-行为" class="headerlink" title="\&lt;jsp:directive /&gt;行为"></a>\&lt;jsp:directive /&gt;行为</h3><p>&emsp;&emsp;\&lt;jsp:directive /&gt;行为相当于JSP指令。\&lt;jsp:directive.page /&gt;行为相当于\&lt;%@ page%&gt;指令，\&lt;jsp:derective.include /&gt;行为相当于\&lt;%@ include%&gt;指令，\&lt;jsp:derective.taglib /&gt;行为相当于\&lt;%@ taglib%&gt;指令，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:directive.page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;jsp:directive.page trimDirectiveWhitespaces=&quot;false&quot; /&gt;</span><br><span class="line">&lt;jsp:directive.page import=&quot;java.util.Date&quot; /&gt;</span><br><span class="line">&lt;jsp:directive.page import=&quot;java.util.List&quot; /&gt;</span><br><span class="line">&lt;jsp:directive.include file=&quot;head.jsp&quot; /&gt;</span><br><span class="line">&lt;jsp:directive.taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot; /&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;\&lt;jsp:directive /&gt;行为与JSP指令可以相互改写。</p><h2 id="JSP隐藏对象"><a href="#JSP隐藏对象" class="headerlink" title="JSP隐藏对象"></a>JSP隐藏对象</h2><p>&emsp;&emsp;JSP中内置了9个隐藏对象，使得JSP比Servlet使用起来更简单，更方便。<br>&emsp;&emsp;JSP内置的隐藏对象有out、request、response、config、session、application、page、pageContext、exception。  </p><h4 id="out输出流对象"><a href="#out输出流对象" class="headerlink" title="out输出流对象"></a>out输出流对象</h4><p>&emsp;&emsp;隐藏对象out是javax.servlet.jsp.JspWriter类的实例。服务器向客户端输出的字符类内容可以通过out对象输出。Out对象的常用方法如下表：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void append(CharSequence cs)</td><td>向out缓存中扩展字符类输出。当缓存满或者执行out.flush()操作时这些内容会输出到客户端浏览器</td></tr><tr><td>void clear()</td><td>清空要输出的内容</td></tr><tr><td>void flush()</td><td>将缓存内容flush到客户端浏览器</td></tr><tr><td>void println(String str)</td><td>向客户端输出内容</td></tr><tr><td>boolean isAutoFlush()</td><td>返回缓存满时是否自动flush。如果为false，缓存满时会抛出异常</td></tr><tr><td>int getBufferSize()</td><td>返回缓存大小。单位KB</td></tr><tr><td>int getRemaining()</td><td>返回缓存剩余大小。单位KB</td></tr></tbody></table><h3 id="request请求对象"><a href="#request请求对象" class="headerlink" title="request请求对象"></a>request请求对象</h3><p>&emsp;&emsp;在Servlet API中，定义了一个HttpServletRequest接口，它继承自ServletRequest接口，专门用来封装HTTP请求消息。由于HTTP请求消息分为请求行、请求消息头和请求消息体三部分，因此在HttpServletRequest接口中定义了获取请求行、请求头和请求消息体的相关方法。在创建Servlet时会覆盖service()方法，或doGet()/doPost()，这些方法都有两个参数，一个为代表请求的request和代表响应的response。service方法中的request类型是ServletRequest，而doGet/doPost方法的request类型是HttpServletRequest，HttpServletRequest是ServletRequest的子接口，功能更加强大。</p><p><img src="/2018/12/17/JSP技术/request的运行流程.jpg" alt="request的运行流程">  </p><p>&emsp;&emsp;隐藏对象request是javax.servlet.ServletRequest类的实例，代表着客户端的请求。request包含客户端的信息以及请求的信息，如请求哪个文件，附带的地址栏参数等。每次客户端请求都会产生一个request实例。当访问Servlet时，会在请求消息的请求行中，包含请求方法、请求资源名、请求路径等信息，为了获取这些信息，在HttpServletRequest接口中，定义了一系列用于获取请求行、请求头、请求参数的方法，Request对象的常用方法如下表：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void attribute(String name, Object value)</td><td>在request中保存一个对象。本页面内或者forward之后的页面中可以通过getAttribute(String name)方法获取该对象</td></tr><tr><td>Object getAttribute(String name)</td><td>从request中获取name对应的对象</td></tr><tr><td>String getMethod()</td><td>该方法用于获取HTTP请求消息中的请求消息，返回提交方式，一般是post或get</td></tr><tr><td>String getParameter(String key)</td><td>返回提交的参数，如果请求消息中没有包含指定名称的参数，getParameter()方法返回null；如果指定名称的参数存在但没有设置值，则返回一个空串；如果请求消息中包含多个该指定名称的参数，getParameter()方法返回第一个出现的参数值。</td></tr><tr><td>String[] getParameterValues(String key)</td><td>返回提交的多个同名参数值。以数组形式返回</td></tr><tr><td>Enumeration getParameterNames()</td><td>返回所有提交的参数名称</td></tr><tr><td>String getParameterMap()</td><td>用于将请求消息中的所有参数名和值装入一个Map对象中返回</td></tr><tr><td>Cookie[] getCookies()</td><td>返回所有的Cookie</td></tr><tr><td>String getContextPath()</td><td>返回应用程序路径（根路径），web应用的名称</td></tr><tr><td>String getRequestURI()</td><td>该方法用于获取请求行中资源名称部分，即位于URL的主机和端口之后、参数部分之前的部分（返回请求的URI路径）,如:/jsp/a.jsp</td></tr><tr><td>void setCharacterEncoding(String encoding)</td><td>设置request的编码方式</td></tr><tr><td>String getHeader(String name)</td><td>获取request头信息</td></tr><tr><td>String getDateHeader(String name)</td><td>该方法用于获取指定头字段的值，并将其按GMT时间格式转换成一个代表日期/时间的长整数，这个长整数是自1970年1月1日0点0分0秒算起的以毫秒为单位的时间值</td></tr><tr><td>Enumeration getHeaders(String name)</td><td>返回一个Enumeration集合对象，该集合对象由请求消息中出现的某个指定名称的所有头字段值组成。多数情况下，一个头字段名在请求消息中只出现一次，但有时候可能出现多次。</td></tr><tr><td>Enumeration getHeaderNames()</td><td>返回所有的request头信息</td></tr><tr><td>int getIntHeader(String name)</td><td>获取指定名称的头字段，并且将其值转为int类型。需要注意的是，如果指定名称的头字段不存在，返回值为-1；如果获取到的头字段的值不能转为int类型，将发生NumberFormatException异常。</td></tr><tr><td>String getContentType()</td><td>获取Content-Type头字段的值，结果为String类型</td></tr><tr><td>String getContentLength()</td><td>获取Content-Type头字段的值，结果为int类型</td></tr><tr><td>String getCharacterEncoding()</td><td>用于返回请求消息的实体部分的字符集编码，通常是从Content-Type头字段中进行提取，结果为String类型</td></tr><tr><td>Dispatcher getRequestDispatcher()</td><td>返回Dispatcher对象。Dispatcher对象可以执行forward操作</td></tr><tr><td>HttpSession getSession()</td><td>返回HttpSession对象</td></tr><tr><td>String getQueryString()</td><td>该方法用于获取请求行中的参数部分，即资源路径后面问好(?)以后的所有内容</td></tr><tr><td>String getProtocol()</td><td>该方法用于获取请求行中的协议名和版本，例如HTTP/1.0或HTTP/1.1</td></tr><tr><td>String getServletPath()</td><td>该方法用于获取Servlet的名称或Servlet所映射的路径</td></tr><tr><td>String getRemoteAddr()</td><td>该方法用于获取请求客户端的IP地址，其格式类似于”192.168.0.3”</td></tr><tr><td>String getRemoteHost()</td><td>该方法用于获取请求客户端的完整主机名，其格式类似于”pcl.itcast.cn”.需要注意的是，如果无法解析出客户机的完整主机名，该方法将会返回客户端的IP地址</td></tr><tr><td>int getRemotePort()</td><td>该方法用于获取请求客户端网络连接的端口号</td></tr><tr><td>String getLocalAddr()</td><td>该方法用于获取Web服务器上接收当前请求网络连接的IP地址</td></tr><tr><td>String getLocalName()</td><td>获取Web服务器上接收当前网络连接IP所对应的主机名</td></tr><tr><td>int getLocalPort()</td><td>获取Web服务器上接收当前网络连接的端口号</td></tr><tr><td>String getServerName()</td><td>用于获取当前请求所指向的主机名，即HTTP请求消息</td></tr><tr><td>int getServerPort()</td><td>用于获取当前请求所连接的服务器端口号，即如果HTTP请求消息中Host头字段所对应的端口号部分</td></tr><tr><td>String getScheme()</td><td>用于获取请求的协议名，例如http、https或ftp</td></tr><tr><td>StringBuffer getRequestURL()</td><td>该方法用于获取客户端发出请求时的完整URL，包括协议、服务器名、端口号、资源路径等信息，但不包括后面的查询参数部分。注意，getRequestURL()方法返回的结果是StringBuffer类型，而不是String类型，这样更便于对结果进行修改</td></tr></tbody></table><h5 id="解决请求参数的中文乱码问题"><a href="#解决请求参数的中文乱码问题" class="headerlink" title="解决请求参数的中文乱码问题"></a>解决请求参数的中文乱码问题</h5><p>&emsp;&emsp;由于HTML设置了浏览器在传递请求参数时，采用的编码方式是UTF-8，但在解码时采用的是默认的ISO8859-1，因此会导致乱码的出现。<br>&emsp;&emsp;解决方法：<br>&emsp;&emsp;在HttpServletRequest接口中，提供了一个setCharacterEncoding()方法，该方法用于设置request对象的解码方式。但该方法只对POST方式有效，对GET方式则无效。<br>&emsp;&emsp;对GET方式的处理需要增加另一语句，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">String name = request.getParameter(&quot;username&quot;);</span><br><span class="line">//需要加入这句话，处理GET方式中文乱码</span><br><span class="line">name = new String(name.getBytes(&quot;iso8859-1&quot;),&quot;utf-8&quot;);</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;request的中文乱码处理流程<br><img src="/2018/12/17/JSP技术/request中文乱码.jpg" alt="request的乱码"><br><img src="/2018/12/17/JSP技术/request的乱码.png" alt="request的乱码"></p><h5 id="通过Request对象传递数据"><a href="#通过Request对象传递数据" class="headerlink" title="通过Request对象传递数据"></a>通过Request对象传递数据</h5><p>&emsp;&emsp;Request对象不仅可以获取一系列数据，还可以通过属性传递数据。在ServletRequest接口中，定义了一系列操作属性的方法，具体如下：</p><ul><li>setAttribute()方法<br>&emsp;&emsp;该方法用于将一个对象与一个名称关联后存储进ServletRequest对象中，其完整语法定义为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void setAttribute(String name, Object o)</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，如果ServletRequest对象中已经存在指定名称的属性，setAttribute()方法将会先删除原来的属性，然后再添加新的属性。如果传递给setAttribute()方法的属性对象为null，则删除指定名称的属性，此时的效果等同于removeAttribute()。</p><ul><li>getAttribute()方法<br>&emsp;&emsp;该方法用于从ServletRequest对象中返回指定名称的属性对象，其完整语法定义为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public String getAttribute(String name)</span><br></pre></td></tr></table></figure><ul><li>removeAttribute()方法<br>&emsp;&emsp;该方法用于从ServletRequest对象中删除指定名称的属性，其完整语法定义为：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void removeAttribute(String name)</span><br></pre></td></tr></table></figure><ul><li>getAttributeNames()方法<br>&emsp;&emsp;该方法用于返回一个包含ServletRequest对象中的所有属性名Enumeration对象，可以对ServletRequest对象中的所有属性进行遍历处理。getAttributeNames()方法的完整语法定义如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public Enumeration getAttributeNames()</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;需要注意的是，只有属于同一个请求中的数据才可以通过ServletRequest对象传递数据。</p><h5 id="RequestDispatcher接口"><a href="#RequestDispatcher接口" class="headerlink" title="RequestDispatcher接口"></a>RequestDispatcher接口</h5><p>&emsp;&emsp;当一个Web资源受到客户端的请求后，如果希望服务器通知另外一个资源去处理请求，这时，除了使用sendRedirect()方法实现请求重定向外，还可以通过RequestDispatcher接口的实例对象来实现。在ServletRequest接口中定义了一个获取RequestDispatcher对象的方法：</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>getRequestDispatcher(String path)</td><td>返回封装了某个路径所指定资源的RequestDispatcher对象。其中参数path必须以”/“开头，用于表示当前Web应用的根目录。需要注意的是，WEB-INF目录中的内容对RequestDispatcher对象也是可见的，因此传递给getRequestDispatcher(String path)方法的资源可以是WEB-INF目录中的文件</td></tr></tbody></table><p>&emsp;&emsp;获取RequestDispatcher对象后，最重要的是通知其他Web资源处理当前的Servlet请求，在RequestDispatcher接口中，定义了两个相关方法</p><table><thead><tr><th>方法声明</th><th>功能描述</th></tr></thead><tbody><tr><td>forward(ServletRequest request, ServletResponse response)</td><td>该方法用于将请求从一个Servlet传递给另外一个Web资源。在Servlet中，可以对请求做一个初步处理，然后通过调用这个方法，将请求给其他资源进行相应。需要注意的是，该方法必须在响应提交给客户端之前被调用，否则将抛出IllegalStateException异常</td></tr><tr><td>include(ServletRequest request, ServletResponse response)</td><td>用于将其他的资源作为当前相应内容包含进来</td></tr></tbody></table><p>&emsp;&emsp;forward()方法可以实现请求转发，include()方法可以实现请求包含。</p><h4 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h4><p>&emsp;&emsp;在Servlet中，如果当前Web资源不想处理请求时，可以通过forward()方法将当前请求传递给其他Web资源进行处理，这种方式称为请求转发。<br><img src="/2018/12/17/JSP技术/forward方法工作原理.jpg" alt="forward方法工作原理"><br>&emsp;&emsp;从图中可以看出，当客户端访问Servlet1时，可以通过forward()方法将请求转发给其他Web资源，其他Web资源处理完请求后，直接将响应结果返回到客户端。</p><h4 id="重定向和请求转发的区别"><a href="#重定向和请求转发的区别" class="headerlink" title="重定向和请求转发的区别"></a>重定向和请求转发的区别</h4><p><img src="/2018/12/17/JSP技术/转发和重定向.png" alt="重定向和请求转发的区别"></p><ul><li>1.重定向的地址栏会发生变化，转发的地址栏不变。</li><li>2.重定向两次请求两次响应，转发一次请求一次响应。</li><li>3.重定向路径需要加工程名，转发的路径不需要加工程名。</li><li>4.重定向可以跳转到任意网站，转发只能在服务器内部进行转发。</li><li>5.重定向不使用request域来传递对象，转发可以传递对象。</li></ul><h4 id="ServletContext域和Request域的生命周期比较"><a href="#ServletContext域和Request域的生命周期比较" class="headerlink" title="ServletContext域和Request域的生命周期比较"></a>ServletContext域和Request域的生命周期比较</h4><p>ServletContext：<br>&emsp;&emsp;创建：服务器启动<br>&emsp;&emsp;销毁：服务器关闭<br>&emsp;&emsp;域的作用范围：整个web应用</p><p>request：<br>&emsp;&emsp;创建：访问时创建request<br>&emsp;&emsp;销毁：响应结束request销毁<br>&emsp;&emsp;域的作用范围：一次请求中</p><h4 id="客户端地址与服务器端地址的写法"><a href="#客户端地址与服务器端地址的写法" class="headerlink" title="客户端地址与服务器端地址的写法"></a>客户端地址与服务器端地址的写法</h4><p>客户端地址：<br>&emsp;&emsp;客户端去访问服务器的地址，服务器外部的地址，特点：写上web应用名称<br>直接输入地址：<br>&emsp;&emsp;重定向</p><p>服务器端地址：<br>&emsp;&emsp;服务器内部资源的跳转的地址，特点，不需要写web应用的名称<br>&emsp;&emsp;转发</p><h3 id="response对象"><a href="#response对象" class="headerlink" title="response对象"></a>response对象</h3><p>&emsp;&emsp;我们在创建Servlet时会覆盖service()方法，或doGet()/doPost(),这些方法都有两个参数，一个为代表请求的request和代表响应response。<br>&emsp;&emsp;在Servlet API中，定义了一个HttpServletResponse接口，它继承自ServletResponse接口，专门用来封装HTTP响应消息。由于HTTP响应消息分为状态行、响应消息头、消息体三部分，因此在HttpServletResponse接口中定义了向客户端发送响应状态码、响应消息头、响应消息体的方法。<br>&emsp;&emsp;隐藏对象response是javax.servlet.ServletResponse类的实例，代表客户端的响应。服务器端的任何输出通过response对象发送到客户端浏览器。每次服务器端都会响应一个response实例。service方法中的response的类型是ServletResponse，而doGet/doPost方法的response的类型是HttpServletResponse，HttpServletResponse是ServletResponse的子接口，功能和方法更加强大。<br>response运行流程<br><img src="/2018/12/17/JSP技术/response运行过程.png" alt="response运行过程"><br><img src="/2018/12/17/JSP技术/response运行过程1.jpg" alt="response运行过程"><br>response的响应如下图所示：<br><img src="/2018/12/17/JSP技术/HTTP响应.jpg" alt="response运行过程"><br>&emsp;&emsp;我们可以设置response的响应行和响应头。</p><h4 id="设置响应行"><a href="#设置响应行" class="headerlink" title="设置响应行"></a>设置响应行</h4><p>&emsp;&emsp;1. 设置响应行状态码：setStatus(int sta)<br>&emsp;&emsp;该方法用于设置HTTP响应消息的状态码，并生成响应状态行。由于响应状态行中的状态描述信息直接与状态码相关，而HTTP版本由服务器确定，因此只要通过setStatus(int status)方法设置了状态码，即可实现状态行的发送。注意，正常情况下，Web服务器会默认产生一个状态码为200的状态行。<br>&emsp;&emsp;2. sendError(int sc)方法<br>&emsp;&emsp;该方法用于发送表示错误信息的状态码，如，404状态码表示找不到客户端请求的资源。在response对象中，提供了两个重载的sendError(int sc)方法，具体如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void sendError(int code) throws java.io.IOException</span><br><span class="line">public void sendError(int code, String message)throws java.io.IOException</span><br></pre></td></tr></table></figure><p>上述重载的两个方法中，第一个方法只发送错误信息的状态码，而第二个方法除了发送状态码外，还增加了一条用于提示说明的文本信息，该文本信息将出现在发送给客户端的正文内容中。</p><h4 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h4><ul><li>addHeader（String name，String value）</li><li>setHeader（String name，String value）</li><li>addIntHeader（String name，int value）</li><li>setIntHeader（String name，int value）</li><li>addDateHeader（String name，long date）</li><li>setDateHeader（String name，long date）</li><li>void setContentLength(int len)</li><li>void setContentType(String type)</li><li>void setLocale(Locale loc)</li><li>void setCharacterEncoding(String charset)  setCharacterEncoding()方法比setContentType()和setLocale()方法的优先权高，它的设置将覆盖setContentType()和setLocale()方法所设置的字符码表。<font color="red">setContentType、setLocale和setCharacterEncoding方法都用于设置字符编码，可以解决乱码问题</font></li></ul><p>&emsp;&emsp;其中add表示添加，set表示设置。</p><h4 id="通过response设置响应体"><a href="#通过response设置响应体" class="headerlink" title="通过response设置响应体"></a>通过response设置响应体</h4><p>(1). 响应体设置文本<br>&emsp;&emsp;PrintWriter getWriter()<br>&emsp;&emsp;获得字符流，通过字符流的write(Stirng s)方法可以将字符串设置到response缓冲区中，随后Tomcat将response缓冲区中的内容组装成Http响应返回给浏览器端。该方法获取的字节输出流对象为PrintWriter类型。由于PrintWriter类型的对象可以直接输出字符文本内容，因此要想输出内容全为字符文本的网页文档，需要使用getWriter()方法。</p><h5 id="关于设置中文乱码的问题"><a href="#关于设置中文乱码的问题" class="headerlink" title="关于设置中文乱码的问题"></a>关于设置中文乱码的问题</h5><p><img src="/2018/12/17/JSP技术/编码错误分析.jpg" alt="编码错误分析"><br>&emsp;&emsp;原因：response缓冲区的默认编码是ISO8859-1，此码表中没有中文，可以通过response的setCharacterEncoding(String charset)设置response编码。</p><p>&emsp;&emsp;如果客户端还是不能正常显示文字：<br>原因：虽然将response缓冲区的编码设置为UTF-8，但浏览器的默认编码是本地系统的编码，由于中文系统客户端浏览器的默认编码是GBK，我们需要手动改成UTF-8<br><img src="/2018/12/17/JSP技术/编码错误分析2.jpg" alt="编码错误分析"><br>&emsp;&emsp;还可以在代码中指定浏览器解析页面的编码方式，通过response的setContentType(String type)方法指定页面解析时的编码是UTF-8，response.setContentType(“text/html;charset=UTF-8”);</p><p>&emsp;&emsp;上面的代码不仅可以指定浏览器解析页面时的编码，同时也内含setCharacterEncoding的功能，所以在实际开发中只要编写response.setContentType(“text/html;charset=UTF-8”);即可解决页面输出中午乱码问题。</p><p>(2). 响应头设置字节<br>&emsp;&emsp;ServletOutputStream getOutputStream()<br>获取字节流，通过该字节流的write(byte[] bytes)可以向response缓冲区中写入字节，然后由Tomcat服务器将字节内容组成Http响应返回给浏览器。该方法所获取的字节输出流对象为ServletOutputStream类型。由于ServletOutputStream是OutputStream的子类，它可以直接输出字节数组中的二进制数据。因此要想输出二进制格式的响应正文，就要使用getOutputStream()方法。</p><font color="red">注意：虽然response对象的getOutputStream()和getWriter()方法都可以发送响应消息体，但他们之间相互排斥，不可以同时使用，否则会发生IllegalStateException异常。</font><p>Response对象的常用方法如下表：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>void clean()</td><td>清空暂存在缓存中的输出</td></tr><tr><td>void addCookie(Cookie cookie)</td><td>设置Cookie</td></tr><tr><td>OutputStream getOutputStream()</td><td>返回服务器输出流。可以通过输出流输出二进制信息</td></tr><tr><td>void sendRedirect(String url)</td><td>使本页面redirect到另一个页面</td></tr><tr><td>void setContentType(String contentType)</td><td>设置文档类型。HTML文档类型为text/html</td></tr><tr><td>PrintWriter getOut()</td><td>返回out对象</td></tr><tr><td>void setHeader(String name, String value)</td><td>设置response头信息</td></tr><tr><td>void setStatus(int status)</td><td>设置response状态码</td></tr></tbody></table><h3 id="config配置对象"><a href="#config配置对象" class="headerlink" title="config配置对象"></a>config配置对象</h3><p>&emsp;&emsp;隐藏对象config是javax.servlet.ServletConfig类的实例。ServletConfig对象封装了配置在web.xml中初始化JSP的参数。JSP中通过config获取这些参数。每个JSP文件共有一个config对象。Config对象的常用方法如下表：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>String getInitParameter(String name)</td><td>返回配置在web.xml中的初始化参数</td></tr><tr><td>Enumeration getInitParameterNames()</td><td>返回所有初始化参数名称</td></tr><tr><td>ServletContext getServletContext()</td><td>返回ServletContext对象</td></tr><tr><td>String getServletName()</td><td>返回Servlet名称</td></tr></tbody></table><h3 id="session会话对象"><a href="#session会话对象" class="headerlink" title="session会话对象"></a>session会话对象</h3><h4 id="什么是会话？"><a href="#什么是会话？" class="headerlink" title="什么是会话？"></a>什么是会话？</h4><p>&emsp;&emsp;会话可以简单理解为：用户打开一个浏览器，点击多个超链接，访问服务器多个web资源，然后关闭浏览器，整个过程称为一个会话。</p><h4 id="会话过程中要解决的一些问题？"><a href="#会话过程中要解决的一些问题？" class="headerlink" title="会话过程中要解决的一些问题？"></a>会话过程中要解决的一些问题？</h4><ul><li>每个用户与服务器进行交互的过程中，各自会有一些数据，程序要想办法保存每个用户数据。</li></ul><p>&emsp;&emsp;隐藏对象session是javax.servlet.http.HttpSession类的实例。session与cookie是记录客户访问信息的两种机制，session用于在服务器端保存用户信息，cookie用于在客户端保存用户信息。Servlet中需要通过request.getSession()获取session对象，而JSP中可以直接使用。如果JSP中配置了\&lt;%@ page seesion=”false”%&gt;,则隐藏对象session不可用。</p><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>Cookie是客户端技术，程序把每个用户的数据以cookie的形式写给用户各自的浏览器。当用户使用浏览器再去访问服务中的web资源时，就会带着各自的数据。这样，web资源处理就是用户各自的数据了。<br>&emsp;&emsp;cookie的作用：</p><ul><li>判断用户上次访问时间：如果是第一次访问，需要输出欢迎，并且记录当前的时间，保存到cookie中，再回写到浏览器端。如果不是第一次访问，获取cookie中的时间，输出时间，并且记录当前的时间，保存到cookie中，再回写到浏览器端。</li></ul><p>&emsp;&emsp;java.servlet.http.Cookie类用于创建一个Cookie，response接口中也定义了一个addCookie方法，它用于在其响应头中增加一个相应的Set-Cookie头字段。同样，request接口中也定义了一个getCookies方法，用于获取客户端提交的Cookie。Cookie类的方法：</p><ul><li>public Cookie(String name, String value)</li><li>setValue与getValue方法</li><li>setMaxAge与getMaxAge方法</li><li>setPath与getPath方法</li><li>setDomain与getDomain方法</li><li>getName方法</li></ul><h5 id="Cookie的细节"><a href="#Cookie的细节" class="headerlink" title="Cookie的细节"></a>Cookie的细节</h5><ul><li>一个Cookie只能只能标识一种信息，它至少含有一个标识该信息的名称(NAME)和设置值(VALUE)</li><li>一个WEB站点可以给一个WEB浏览器发送多个Cookie，一个WEB浏览器也可以存储多个WEB站点提供的Cookie。</li><li>浏览器一般只允许存放300个Cookie，每个站点最多存放20个Cookie，每个Cookie的大小限制为4KB。</li><li>如果创建了一个cookie，并将他发送到浏览器，默认情况下它是一个会话级别的cookie(即存储在浏览器的内存中)，用户退出浏览器之后即被删除。若希望浏览器将该cookie存储在磁盘上，则需要使用maxAge，并给出一个以秒为单位的时间。</li><li>删除持久cookie，可以将cookie最大实效设为0，注意，删除cookie时，path必须一致，否则不会删除。</li></ul><p>cookie的应用<br><img src="/2018/12/17/JSP技术/记录上次访问时间.bmp" alt="cookie的应用"><br><img src="/2018/12/17/JSP技术/记录商品浏览记录.bmp" alt="cookie的应用"></p><h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5><p>&emsp;&emsp;WEB开发中，服务器可以为每个用户浏览器创建一个会话对象(session对象)，注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其他程序时，其他程序可以从用户的session中取出该用户的数据，为用户服务。<br>&emsp;&emsp;Session和Cookie的主要区别在于：</p><ul><li>Cookie是把用户的数据写给用户的浏览器；</li><li>Session技术把用户的数据写到用户独占的Session中（服务器端）</li><li>Session对象由服务器创建，开发人员可以调用request对象的getSession方法得到session对象。</li></ul><p>cookie和session的实现原理：<br><img src="/2018/12/17/JSP技术/cookie和session的原理.bmp" alt="cookie和session的实现原理"><br>购物车的分析<br><img src="/2018/12/17/JSP技术/购物车的分析.bmp" alt="cookie和session的实现原理"><br>&emsp;&emsp;Session是服务器端技术，利用该技术，服务器在运行时可以为每一个用户的浏览器创建一个其独享的session对象，由于session为用户浏览器独享，所以用户在访问服务器的web资源时，可以把各自的数据放在各自的session中，当用户去访问服务器中的其他web资源时，其他web资源再从用户各自的session中取出数据为用户的服务。<br>每个用户对应一个session对象。Session对象的常用方法如下表：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>String getId()</td><td>返回session的id</td></tr><tr><td>Object getAttribute(String name)</td><td>返回session中属性名为name的对象</td></tr><tr><td>Enumeration getAttributeNames()</td><td>返回session的所有属性名</td></tr><tr><td>long getCreationTime()</td><td>返回session创建的时间</td></tr><tr><td>long getLastAccessedTime()</td><td>返回该session最后一次访问的时间</td></tr><tr><td>int getMaxInactiveInterval()</td><td>返回session的最大允许的间隔时间。单位为秒</td></tr><tr><td>void setAttribute(String name, Object value)</td><td>设置session</td></tr><tr><td>void setMaxInactiveInterval(long second)</td><td>设置最大允许的时间间隔</td></tr></tbody></table><h3 id="application应用程序对象"><a href="#application应用程序对象" class="headerlink" title="application应用程序对象"></a>application应用程序对象</h3><p>&emsp;&emsp;隐藏对象application是javax.servlet.ServletContext类的对象。application封装了JSP所在的Web应用程序的信息，如web.xml中配置的全局的初始化信息。Servlet中application对象需要通过ServletConfig.getServletContext()来获取。整个Web应用程序对应一个application对象。Application对象的常用方法如下表：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object getAttribute(String name)</td><td>返回application中属性名为name的对象</td></tr><tr><td>Enumeration getAttributeNames()</td><td>返回application的所有属性名</td></tr><tr><td>void setAttribute(String name, Object value)</td><td>设置application属性</td></tr><tr><td>void removeAttribute(String name)</td><td>移除application属性</td></tr><tr><td>String getInitParameter(String name)</td><td>返回全局初始化参数</td></tr><tr><td>Enumeration getInitParameterNames()</td><td>返回所有的全局初始化参数</td></tr><tr><td>String getMimeType(String filename)</td><td>返回文件的文档类型。例如:getMimeType(“abc.html”)将返回”text/html”</td></tr><tr><td>String getRealPath(String relativePath)</td><td>返回web应用程序内相对网址对应的绝对路径</td></tr></tbody></table><h4 id="Servlet的数据访问范围"><a href="#Servlet的数据访问范围" class="headerlink" title="Servlet的数据访问范围"></a>Servlet的数据访问范围</h4><ul><li>applicationScope servletContext（数据库连接池，配置，线程池，站点访问次数）：每一个Web应用对应一个ServletContext，存放所有用户都可以访问的数据</li><li>session Scope HttpSession（存放与用户相关数据）：存放每个用户自己会话过程中的数据</li><li>request Scope HttpServletRequest</li><li>Servlet处理结果，JSP显示：数据存放在request中，生成新的请求时，原request存放数据丢失<h3 id="page页面对象"><a href="#page页面对象" class="headerlink" title="page页面对象"></a>page页面对象</h3>&emsp;&emsp;隐藏对象page是javax.servlet.jsp.HttpJspPage类的实例。page对象代表当前JSP页面，是当前JSP编译后的Servlet类的对象。page相当于普通Java类中的关键字this。</li></ul><h3 id="pageContext页面上下文对象"><a href="#pageContext页面上下文对象" class="headerlink" title="pageContext页面上下文对象"></a>pageContext页面上下文对象</h3><p>&emsp;&emsp;隐藏对象pageContext是javax.servlet.pageContext类的实例。pageContext对象代表当前JSP页面编译后的内容。通过pageContext能够获取JSP中的资源。pageContext对象的常用方法如下表：</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Object findAttribute(String name)</td><td>在JSP页面中查找变量</td></tr><tr><td>void forward(String url)</td><td>forward到另一个页面</td></tr><tr><td>void setAttribute(String name, Object value)</td><td>设置application属性</td></tr><tr><td>void removeAttribute(String name)</td><td>移除application属性</td></tr><tr><td>Object getAttribute(String name)</td><td>返回属性</td></tr><tr><td>Object getAttribute(String name，int scope)</td><td>返回指定范围内的属性。范围包括PAGE、REQUEST_SCOPE、SESSION_REQUEST、APPLICATION_SCOPE</td></tr><tr><td>JspWriter getOut()</td><td>返回out对象</td></tr><tr><td>Object getPage()</td><td>返回Page对象</td></tr><tr><td>ServletRequest getRequest()</td><td>返回request对象</td></tr><tr><td>ServletResponse getResponse()</td><td>返回response对象</td></tr><tr><td>HttpSession getSession()</td><td>返回session对象</td></tr></tbody></table><h3 id="exception异常对象"><a href="#exception异常对象" class="headerlink" title="exception异常对象"></a>exception异常对象</h3><p>&emsp;&emsp;隐藏对象exception是java.lang.Exception类的对象。exception封装了JSP中抛出的异常信息。要使用exception隐藏对象，需要设置\&lt;%@ page isErrorPage=”true” %&gt;。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html;charset=UTF-8&quot; errorPage=&quot;error.jsp&quot;%&gt;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;error.jsp就是捕获异常要跳转的地址。error.jsp需要设置isErrorPage为true，否则exception隐藏对象将不可用。</p><h2 id="JSP配置"><a href="#JSP配置" class="headerlink" title="JSP配置"></a>JSP配置</h2><p>&emsp;&emsp;JSP文件部署到服务器后可以直接访问，而不必像Servlet必须在web.xml中配置。如果Web应用程序中只包含JSP程序与HTML、图片等静态文件，可以省略web.xml配置文件。当然，JSP也可以在web.xml中配置，个人觉得用的不多，这里不做展示。</p><h2 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h2><p>&emsp;&emsp;JSP中可以使用EL(Expression Language)表达式。EL表达式是用”\${标识符}”括起来的脚本，用来方便地读取对象。EL表达式写在JSP的HTML代码中，而不能写在”&lt;%”与”%&gt;”引起的JSP脚本中。</p><h3 id="EL表达式-1"><a href="#EL表达式-1" class="headerlink" title="EL表达式"></a>EL表达式</h3><p>&emsp;&emsp;EL表达式提供了获取对象以及属性的简单方式，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean id=&quot;person&quot; class=&quot;Person&quot;&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">欢迎您,$&#123;person&#125;</span><br><span class="line">您的年龄是:$&#123;person.age&#125;</span><br><span class="line">您的性别是:$&#123;person.sex&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line"></span><br><span class="line">&lt;%=request.getAttribute(&quot;name&quot;);%&gt; 等价于</span><br><span class="line">$&#123;requestScope.name&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;代码中先使用useBean行为将Person对象放置到request中，再使用EL表达式读取该对象。El表达式也可以读取session中的对象。如果request中不存在名为person的对象，则会去session中查找。常用的方法是setAttribute(String name, Object value)将对象放置到request或者session中。</p><h3 id="隐藏对象"><a href="#隐藏对象" class="headerlink" title="隐藏对象"></a>隐藏对象</h3><p>&emsp;&emsp;EL表达式不仅可以读取request、session中的属性，还可以读取其他JSP隐藏对象的属性，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;param.foo &#125; //读取地址栏参数，相当于request.getParameter(&quot;foo&quot;)</span><br><span class="line">$&#123;initParam.foo &#125; //读取初始化参数，相当于request.getInitParameter(&quot;foo&quot;)</span><br><span class="line">$&#123;header.host &#125; //读取head参数</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;param、initParam、header均返回Map类型对象。对于放置在Map里的对象，还可以使用数组的形式获取到。</p><h3 id="EL表达式运算"><a href="#EL表达式运算" class="headerlink" title="EL表达式运算"></a>EL表达式运算</h3><p>&emsp;&emsp;EL表达式支持简单的运算，包括加(+)、减(-)、乘(*)、除(/或者div)、取余(%或者mod)、三目运算符(exp?var1:var2)<br>&emsp;&emsp;EL表达式也可以支持简单的比较运算，包括大于(&gt;或者gt)，小于(&lt;或者lt)，等于(==或者eq)，不等于(!=或者ne)，大于等于(&gt;=或者ge)，小于等于(&lt;=或者le)等。<br>&emsp;&emsp;多个比较运算可以用且(&amp;&amp;或者and)、或(||或者or)、否(!或者not)以及括号等连接起来。某些比较运算符也适用于字符比较，&lt;、&gt;、==。<br>&emsp;&emsp;字符比较时，如果为大于小于操作EL表达式会调用int compare(char ss)方法完成比较，等于操作时会调用equals()方法来完成比较。<br>&emsp;&emsp;对于Map或者数组类，还可以使用[]取值，或者使用empty判断是否为空，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;param.paramA[0] &#125; //输出提交的paramA参数的第一个值</span><br><span class="line">$&#123;empty param.paramA &#125; //提交的paramA参数是否为空或者个数为0</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;EL表达式不能直接访问普通的方法以及静态属性。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>&emsp;&emsp;JSP是一种简化了的Servlet，最终也会被编译为Servlet类。JSP中Java代码与HTML代码交互在一起，比Servlet更方便地输出HTML代码。JSP中也可以声明方法与变量，初始化时调用_jspInit()，销毁时调用_jspDestroy()。JSP中内置的对象为out、request、response、config、session、page、pageContext、application、exception。<br>&emsp;&emsp;与Servlet相比，JSP更适合与HTML打交道，而Servlet更适合与Java打交道。现在的Java EE（J2EE）系统中，Servlet只用于处理业务逻辑，JSP只用于显示结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSP技术&quot;&gt;&lt;a href=&quot;#JSP技术&quot; class=&quot;headerlink&quot; title=&quot;JSP技术&quot;&gt;&lt;/a&gt;JSP技术&lt;/h1&gt;&lt;h2 id=&quot;JSP简介&quot;&gt;&lt;a href=&quot;#JSP简介&quot; class=&quot;headerlink&quot; title=&quot;JSP
      
    
    </summary>
    
      <category term="JavaWeb" scheme="http://blog.letmefly.cc/categories/JavaWeb/"/>
    
    
      <category term="JSP" scheme="http://blog.letmefly.cc/tags/JSP/"/>
    
  </entry>
  
</feed>
